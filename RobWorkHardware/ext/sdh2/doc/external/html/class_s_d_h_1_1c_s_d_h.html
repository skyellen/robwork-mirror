<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>SDHLibrary-CPP: SDH::cSDH Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespace_s_d_h.html">SDH</a>::<a class="el" href="class_s_d_h_1_1c_s_d_h.html">cSDH</a>
  </div>
</div>
<div class="contents">
<h1>SDH::cSDH Class Reference</h1><!-- doxytag: class="SDH::cSDH" --><!-- doxytag: inherits="SDH::cSDHBase,SDH::cSDHBase" --><code>#include &lt;sdh.h&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for SDH::cSDH:</div>
<div class="dynsection">
<p><center><img src="class_s_d_h_1_1c_s_d_h__inherit__graph.png" border="0" usemap="#_s_d_h_1_1c_s_d_h__inherit__map" alt="Inheritance graph"></center>
<map name="_s_d_h_1_1c_s_d_h__inherit__map">
<area shape="rect" href="class_s_d_h_1_1c_s_d_h_base.html" title="The base class to control the SCHUNK Dexterous Hand." alt="" coords="39,6,337,838"></map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center></div>
<div class="dynheader">
Collaboration diagram for SDH::cSDH:</div>
<div class="dynsection">
<p><center><img src="class_s_d_h_1_1c_s_d_h__coll__graph.png" border="0" usemap="#_s_d_h_1_1c_s_d_h__coll__map" alt="Collaboration graph"></center>
<map name="_s_d_h_1_1c_s_d_h__coll__map">
<area shape="rect" href="class_s_d_h_1_1c_s_d_h_base.html" title="The base class to control the SCHUNK Dexterous Hand." alt="" coords="341,486,640,1318"><area shape="rect" href="class_s_d_h_1_1c_s_d_h_serial.html" title="The class to communicate with a SDH via RS232." alt="" coords="271,1382,441,4678"><area shape="rect" href="class_s_d_h_1_1c_d_b_g.html" title="A class to print colored debug messages." alt="" coords="216,6,328,390"><area shape="rect" href="class_s_d_h_1_1c_serial_base.html" title="Low&#45;level communication class to access a serial port." alt="" coords="5,686,133,1118"><area shape="rect" href="class_s_d_h_1_1c_simple_vector.html" title="A simple vector implementation." alt="" coords="419,14,563,382"><area shape="rect" href="class_s_d_h_1_1c_simple_string_list.html" title="A simple string list. (Fixed maximum number of strings of fixed maximum length)." alt="" coords="157,750,317,1054"><area shape="rect" href="class_s_d_h_1_1c_unit_converter.html" title="Unit conversion class to convert values between physical unit systems." alt="" coords="540,2726,692,3334"></map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="class_s_d_h_1_1c_s_d_h-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
<a class="el" href="class_s_d_h_1_1c_s_d_h.html" title="SDH::cSDH is the end user interface class to control a SDH (SCHUNK Dexterous Hand)...">SDH::cSDH</a> is the end user interface class to control a SDH (SCHUNK Dexterous Hand). 
<p>
A general overview of the structure and architecture used is given <a class="el" href="cpp_8desire_8final_2architecture_8dox.html#sdhlibrary_cpp_architecture_dox_sdhpackage_overview">here</a>.<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd><a class="anchor" name="sdhlibrary_cpp_sdh_h_csdh_axis_vs_fingers"></a><ul>
<li>The <a class="el" href="class_s_d_h_1_1c_s_d_h.html" title="SDH::cSDH is the end user interface class to control a SDH (SCHUNK Dexterous Hand)...">cSDH</a> class provides methods to access the 7 axes of the SDH individually as well as on a finger level.<ul>
<li>When accessing the axes individually then the following axis indices must be used to address an axis / some axes:<ul>
<li>0 : common base axis of finger 0 and 2</li><li>1 : proximal axis of finger 0</li><li>2 : distal axis of finger 0</li><li>3 : proximal axis of finger 1</li><li>4 : distal axis of finger 1</li><li>5 : proximal axis of finger 2</li><li>6 : distal axis of finger 2</li></ul>
</li><li>When accessing the axes on finger level then every finger has 3 axes for a uniform interface of the access methods. Her the following finger axis indices must be used:<ul>
<li>0 : base axis of finger (for finger 1 this is a "virtual" axis with min angle = max angle = 0.0)</li><li>1 : proximal axis of finger</li><li>2 : distal axis of finger <a class="anchor" name="sdhlibrary_cpp_sdh_h_csdh_vector"></a></li></ul>
</li></ul>
</li><li>Vector-like parmeters: The interface functions defined here make full use of the flexibility provided by the STL vector&lt;T&gt; type. I.E. for parameters of functions like axis indices or axis angles not only single numerical values can be given, but also vectors of <code>int</code> or <code>double</code> values. This way the same (overloaded) interface function can address a single axis individually or multiple axes in a call, as required by the application. Such parameters are herein refered to as "vectors".</li><li>Parameters for methods are checked for validity. In case an invalid parameter is given the method throws a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">cSDHErrorInvalidParameter</a> exception. <a class="anchor" name="sdhlibrary_cpp_sdh_h_csdh_unit"></a></li><li>The underlying physical unit system of parameters that do have a unit (like angles, velocities or temperatures) can be adapted to the users or the applications need. See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#sdhlibrary_cpp_sdh_h_unit_conversion_objects">unit conversion</a> objects". The default converter objects are set as the uc_* member variables (<a class="el" href="class_s_d_h_1_1c_s_d_h.html#bcb9da3cf0236c0e09cdd7af1a78225e" title="unit convert for (axis) angles: default = SDH::cSDH::uc_angle_degrees">uc_angle</a>, <a class="el" href="class_s_d_h_1_1c_s_d_h.html#81c208eb64b0954dfef4182575ff6bc9" title="unit convert for (axis) angular velocities: default = SDH::cSDH::uc_angular_velocity_degrees_per_sec...">uc_angular_velocity</a>, <a class="el" href="class_s_d_h_1_1c_s_d_h.html#8dc039c618c3383d5fefd85d41866f9e" title="unit convert for (axis) angular accelerations: default = SDH::cSDH::uc_angular_acceleration_degrees_...">uc_angular_acceleration</a>, <a class="el" href="class_s_d_h_1_1c_s_d_h.html#7479296b9f0c7300dc50452c7c929bc2" title="unit convert for times: default = uc_time_seconds">uc_time</a>, <a class="el" href="class_s_d_h_1_1c_s_d_h.html#844b1311f5be6eb5474157d9c24e7a5e" title="unit convert for temperatures: default = SDH::cSDH::uc_temperature_celsius">uc_temperature</a>, <a class="el" href="class_s_d_h_1_1c_s_d_h.html#b16893e67eb1273cd95adcd6c0d5e631" title="unit converter for position: default = SDH::cSDH::uc_position_millimeter">uc_position</a>). The units are changed in the communication between user application and <a class="el" href="class_s_d_h_1_1c_s_d_h.html" title="SDH::cSDH is the end user interface class to control a SDH (SCHUNK Dexterous Hand)...">cSDH</a> object instance only (USERAPP and SDHLibrary-CPP in the <a class="el" href="cpp_8desire_8final_2architecture_8dox.html#sdhlibrary_cpp_architecture_dox_sdhpackage_overview">overview</a> figure"). For now the SDH firmware knows only about its internal unit system.</li></ul>
</dd></dl>
<hr>
 <table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Kinematic parameters of the Hand</h2></td></tr>
<tr><td colspan="2"><a class="anchor" name="sdhlibrary_cpp_sdh_h_kinematic_vars"></a> <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#bc579960bc538eb63ed84012d3971a4b">l1</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">length of limb 1 (proximal joint to distal joint) in mm  <a href="#bc579960bc538eb63ed84012d3971a4b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#ccaacfad7c5bcc0a9287ae2a235bc95c">l2</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">length of limb 2 (distal joint to fingertip) in mm  <a href="#ccaacfad7c5bcc0a9287ae2a235bc95c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#87537330abbd2528f9dccaa105e427f6">d</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#74c5c97f01a7a5452fa58412360f20af">h</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; std::vector<br>
&lt; double &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#892296c192f86303bd4c2dad020996d0">offset</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_s_d_h_1_1c_serial_base.html">cSerialBase</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#3b788fb2f79a32502a29f0550c659539">com</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_s_d_h_1_1c_s_d_h_serial.html">cSDHSerial</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#e21dadd89dbf2e0316414ea0127d9326">comm_interface</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The object to interface with the SDH attached via serial RS232 or CAN.  <a href="#e21dadd89dbf2e0316414ea0127d9326"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#5edad78d5abca94b036a582c053556b0">SetDebugOutput</a> (std::ostream *debuglog)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">change the stream to use for debug messages  <a href="#5edad78d5abca94b036a582c053556b0"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Kinematic parameters of the Hand</h2></td></tr>
<tr><td colspan="2"><a class="anchor" name="sdhlibrary_cpp_sdh_h_kinematic_vars"></a> <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; std::vector<br>
&lt; double &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#892296c192f86303bd4c2dad020996d0">offset</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_s_d_h_1_1c_serial_base.html">cSerialBase</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#3b788fb2f79a32502a29f0550c659539">com</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#5edad78d5abca94b036a582c053556b0">SetDebugOutput</a> (std::ostream *debuglog)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">change the stream to use for debug messages  <a href="#5edad78d5abca94b036a582c053556b0"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Miscellaneous methods</h2></td></tr>
<tr><td colspan="2"><a class="anchor" name="sdhlibrary_cpp_sdh_h_csdh_misc"></a> <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#816313af63165f45b31bada0e7986648">IsVirtualAxis</a> (int iAxis)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return <code>true</code> if index <em>iAxis</em> refers to a virtual axis.  <a href="#816313af63165f45b31bada0e7986648"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#5319f1ad161fb0b671106948c8ffe515">UseRadians</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#ea0dd8a17e872ee94facea0dbadd6895">UseDegrees</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#8fbc15a1e8ecc1c4ba3c443360a07e9d">GetFingerNumberOfAxes</a> (int iFinger)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#c7e8f246a6c6c0502ceda09880831be0">GetFingerAxisIndex</a> (int iFinger, int iFingerAxis)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">char const *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#d5ebbb82415f064945ec7476bbfe836c">GetFirmwareRelease</a> (void)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">char const *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#bb2c373d78c30ff8cd5dcb8b3c5fad69">GetInfo</a> (char const *what)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#448d044af20e6a1d2ffe674ebd0ea1e7">GetTemperature</a> (std::vector&lt; int &gt; const &amp;sensors)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#ac95911b4547325bf2f0af1a0af9e0e9">GetTemperature</a> (int iSensor)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static char const *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#6b3a201726288b58f7515995f22ddda3">GetLibraryRelease</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static char const *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#4d3480853847207adbdba2e20a87ccf1">GetLibraryName</a> (void)</td></tr>

<tr><td colspan="2"><br><h2>Miscellaneous methods</h2></td></tr>
<tr><td colspan="2"><a class="anchor" name="sdhlibrary_cpp_sdh_h_csdh_misc"></a> <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#3df97ff34a8bb697a9d883928c492cc0">IsVirtualAxis</a> (int iAxis)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return <code>true</code> if index <em>iAxis</em> refers to a virtual axis.  <a href="#3df97ff34a8bb697a9d883928c492cc0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#45fb825338c104ee620178babaaa4509">UseRadians</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#590995e561ac2d1a5bb0c840e0c31287">UseDegrees</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#78994c553339d90ecd29e55e52d671f7">GetFingerNumberOfAxes</a> (int iFinger)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#d409bd282545da7cc0384501f7c05130">GetFingerAxisIndex</a> (int iFinger, int iFingerAxis)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">char const *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#7556511eb9cf81c4bcb68430e70418ce">GetFirmwareRelease</a> (void)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">char const *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#fb9751f28fde3347cccb4dbe9ecfe2e2">GetInfo</a> (char const *what)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#15581ff5a50219a49e3085114f289431">GetTemperature</a> (std::vector&lt; int &gt; const &amp;sensors)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#a11b48c0b8104f74870378a6675b6791">GetTemperature</a> (int iSensor)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static char const *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#98cd1199edb7c6436be1d4c9d2bb892d">GetLibraryRelease</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static char const *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#420d4888ad31c07b44ae47617a0a33eb">GetLibraryName</a> (void)</td></tr>

<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#712b0b80382f1e1e5229ad7bec6cdc4d">eMotorCurrentMode</a> { <br>
&nbsp;&nbsp;<a class="el" href="class_s_d_h_1_1c_s_d_h.html#712b0b80382f1e1e5229ad7bec6cdc4da0a075991ceba063aff574398f8ff05e">eMCM_MOVE</a> = 0, 
<a class="el" href="class_s_d_h_1_1c_s_d_h.html#712b0b80382f1e1e5229ad7bec6cdc4d63872c18691513275682b347c68732b5">eMCM_GRIP</a> = 1, 
<a class="el" href="class_s_d_h_1_1c_s_d_h.html#712b0b80382f1e1e5229ad7bec6cdc4d690e9bb2611fe2a597bb2b9443856fe1">eMCM_HOLD</a> = 2, 
<a class="el" href="class_s_d_h_1_1c_s_d_h.html#712b0b80382f1e1e5229ad7bec6cdc4dd06a5321282cd5a7ab04475059df7f63">eMCM_DIMENSION</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="class_s_d_h_1_1c_s_d_h.html#712b0b80382f1e1e5229ad7bec6cdc4da0a075991ceba063aff574398f8ff05e">eMCM_MOVE</a> = 0, 
<a class="el" href="class_s_d_h_1_1c_s_d_h.html#712b0b80382f1e1e5229ad7bec6cdc4d63872c18691513275682b347c68732b5">eMCM_GRIP</a> = 1, 
<a class="el" href="class_s_d_h_1_1c_s_d_h.html#712b0b80382f1e1e5229ad7bec6cdc4d690e9bb2611fe2a597bb2b9443856fe1">eMCM_HOLD</a> = 2, 
<a class="el" href="class_s_d_h_1_1c_s_d_h.html#712b0b80382f1e1e5229ad7bec6cdc4dd06a5321282cd5a7ab04475059df7f63">eMCM_DIMENSION</a>
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the motor current can be set specifically for these modes:  <a href="class_s_d_h_1_1c_s_d_h.html#712b0b80382f1e1e5229ad7bec6cdc4d">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#b5f553148de415980dd90cb92f30b54b">eAxisState</a> { <br>
&nbsp;&nbsp;<a class="el" href="class_s_d_h_1_1c_s_d_h.html#b5f553148de415980dd90cb92f30b54bd966c9e6d1145850dd60e12bdce4f5dc">eAS_IDLE</a> =  0, 
<a class="el" href="class_s_d_h_1_1c_s_d_h.html#b5f553148de415980dd90cb92f30b54bdc62e02ed19a432396a9d4ea968d0676">eAS_POSITIONING</a>, 
<a class="el" href="class_s_d_h_1_1c_s_d_h.html#b5f553148de415980dd90cb92f30b54b52c8e94f5f0f5c7418a24882dbb8ce05">eAS_SPEED_MODE</a>, 
<a class="el" href="class_s_d_h_1_1c_s_d_h.html#b5f553148de415980dd90cb92f30b54b09f097ac98da3f3fd1525b05c4d46b0a">eAS_NOT_INITIALIZED</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="class_s_d_h_1_1c_s_d_h.html#b5f553148de415980dd90cb92f30b54b13f7039cb7faa7831ea8507e49f43963">eAS_CW_BLOCKED</a>, 
<a class="el" href="class_s_d_h_1_1c_s_d_h.html#b5f553148de415980dd90cb92f30b54bdd03e29e1e252c9e64e84450d1c109a0">eAS_CCW_BLOCKED</a>, 
<a class="el" href="class_s_d_h_1_1c_s_d_h.html#b5f553148de415980dd90cb92f30b54bcbf7c13f3b209937e332166c228fa021">eAS_DISABLED</a>, 
<a class="el" href="class_s_d_h_1_1c_s_d_h.html#b5f553148de415980dd90cb92f30b54b7bb4b393269bf39e9ad91385207e318d">eAS_LIMITS_REACHED</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="class_s_d_h_1_1c_s_d_h.html#b5f553148de415980dd90cb92f30b54be8b914c1eb4139fc85c92d82e8c63414">eAS_DIMENSION</a>, 
<a class="el" href="class_s_d_h_1_1c_s_d_h.html#b5f553148de415980dd90cb92f30b54bd966c9e6d1145850dd60e12bdce4f5dc">eAS_IDLE</a> =  0, 
<a class="el" href="class_s_d_h_1_1c_s_d_h.html#b5f553148de415980dd90cb92f30b54bdc62e02ed19a432396a9d4ea968d0676">eAS_POSITIONING</a>, 
<a class="el" href="class_s_d_h_1_1c_s_d_h.html#b5f553148de415980dd90cb92f30b54b52c8e94f5f0f5c7418a24882dbb8ce05">eAS_SPEED_MODE</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="class_s_d_h_1_1c_s_d_h.html#b5f553148de415980dd90cb92f30b54b09f097ac98da3f3fd1525b05c4d46b0a">eAS_NOT_INITIALIZED</a>, 
<a class="el" href="class_s_d_h_1_1c_s_d_h.html#b5f553148de415980dd90cb92f30b54b13f7039cb7faa7831ea8507e49f43963">eAS_CW_BLOCKED</a>, 
<a class="el" href="class_s_d_h_1_1c_s_d_h.html#b5f553148de415980dd90cb92f30b54bdd03e29e1e252c9e64e84450d1c109a0">eAS_CCW_BLOCKED</a>, 
<a class="el" href="class_s_d_h_1_1c_s_d_h.html#b5f553148de415980dd90cb92f30b54bcbf7c13f3b209937e332166c228fa021">eAS_DISABLED</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="class_s_d_h_1_1c_s_d_h.html#b5f553148de415980dd90cb92f30b54b7bb4b393269bf39e9ad91385207e318d">eAS_LIMITS_REACHED</a>, 
<a class="el" href="class_s_d_h_1_1c_s_d_h.html#b5f553148de415980dd90cb92f30b54be8b914c1eb4139fc85c92d82e8c63414">eAS_DIMENSION</a>
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The state of an axis (see TPOSCON_STATE in global.h of the SDH firmware).  <a href="class_s_d_h_1_1c_s_d_h.html#b5f553148de415980dd90cb92f30b54b">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#712b0b80382f1e1e5229ad7bec6cdc4d">eMotorCurrentMode</a> { <br>
&nbsp;&nbsp;<a class="el" href="class_s_d_h_1_1c_s_d_h.html#712b0b80382f1e1e5229ad7bec6cdc4da0a075991ceba063aff574398f8ff05e">eMCM_MOVE</a> = 0, 
<a class="el" href="class_s_d_h_1_1c_s_d_h.html#712b0b80382f1e1e5229ad7bec6cdc4d63872c18691513275682b347c68732b5">eMCM_GRIP</a> = 1, 
<a class="el" href="class_s_d_h_1_1c_s_d_h.html#712b0b80382f1e1e5229ad7bec6cdc4d690e9bb2611fe2a597bb2b9443856fe1">eMCM_HOLD</a> = 2, 
<a class="el" href="class_s_d_h_1_1c_s_d_h.html#712b0b80382f1e1e5229ad7bec6cdc4dd06a5321282cd5a7ab04475059df7f63">eMCM_DIMENSION</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="class_s_d_h_1_1c_s_d_h.html#712b0b80382f1e1e5229ad7bec6cdc4da0a075991ceba063aff574398f8ff05e">eMCM_MOVE</a> = 0, 
<a class="el" href="class_s_d_h_1_1c_s_d_h.html#712b0b80382f1e1e5229ad7bec6cdc4d63872c18691513275682b347c68732b5">eMCM_GRIP</a> = 1, 
<a class="el" href="class_s_d_h_1_1c_s_d_h.html#712b0b80382f1e1e5229ad7bec6cdc4d690e9bb2611fe2a597bb2b9443856fe1">eMCM_HOLD</a> = 2, 
<a class="el" href="class_s_d_h_1_1c_s_d_h.html#712b0b80382f1e1e5229ad7bec6cdc4dd06a5321282cd5a7ab04475059df7f63">eMCM_DIMENSION</a>
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the motor current can be set specifically for these modes:  <a href="class_s_d_h_1_1c_s_d_h.html#712b0b80382f1e1e5229ad7bec6cdc4d">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#b5f553148de415980dd90cb92f30b54b">eAxisState</a> { <br>
&nbsp;&nbsp;<a class="el" href="class_s_d_h_1_1c_s_d_h.html#b5f553148de415980dd90cb92f30b54bd966c9e6d1145850dd60e12bdce4f5dc">eAS_IDLE</a> =  0, 
<a class="el" href="class_s_d_h_1_1c_s_d_h.html#b5f553148de415980dd90cb92f30b54bdc62e02ed19a432396a9d4ea968d0676">eAS_POSITIONING</a>, 
<a class="el" href="class_s_d_h_1_1c_s_d_h.html#b5f553148de415980dd90cb92f30b54b52c8e94f5f0f5c7418a24882dbb8ce05">eAS_SPEED_MODE</a>, 
<a class="el" href="class_s_d_h_1_1c_s_d_h.html#b5f553148de415980dd90cb92f30b54b09f097ac98da3f3fd1525b05c4d46b0a">eAS_NOT_INITIALIZED</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="class_s_d_h_1_1c_s_d_h.html#b5f553148de415980dd90cb92f30b54b13f7039cb7faa7831ea8507e49f43963">eAS_CW_BLOCKED</a>, 
<a class="el" href="class_s_d_h_1_1c_s_d_h.html#b5f553148de415980dd90cb92f30b54bdd03e29e1e252c9e64e84450d1c109a0">eAS_CCW_BLOCKED</a>, 
<a class="el" href="class_s_d_h_1_1c_s_d_h.html#b5f553148de415980dd90cb92f30b54bcbf7c13f3b209937e332166c228fa021">eAS_DISABLED</a>, 
<a class="el" href="class_s_d_h_1_1c_s_d_h.html#b5f553148de415980dd90cb92f30b54b7bb4b393269bf39e9ad91385207e318d">eAS_LIMITS_REACHED</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="class_s_d_h_1_1c_s_d_h.html#b5f553148de415980dd90cb92f30b54be8b914c1eb4139fc85c92d82e8c63414">eAS_DIMENSION</a>, 
<a class="el" href="class_s_d_h_1_1c_s_d_h.html#b5f553148de415980dd90cb92f30b54bd966c9e6d1145850dd60e12bdce4f5dc">eAS_IDLE</a> =  0, 
<a class="el" href="class_s_d_h_1_1c_s_d_h.html#b5f553148de415980dd90cb92f30b54bdc62e02ed19a432396a9d4ea968d0676">eAS_POSITIONING</a>, 
<a class="el" href="class_s_d_h_1_1c_s_d_h.html#b5f553148de415980dd90cb92f30b54b52c8e94f5f0f5c7418a24882dbb8ce05">eAS_SPEED_MODE</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="class_s_d_h_1_1c_s_d_h.html#b5f553148de415980dd90cb92f30b54b09f097ac98da3f3fd1525b05c4d46b0a">eAS_NOT_INITIALIZED</a>, 
<a class="el" href="class_s_d_h_1_1c_s_d_h.html#b5f553148de415980dd90cb92f30b54b13f7039cb7faa7831ea8507e49f43963">eAS_CW_BLOCKED</a>, 
<a class="el" href="class_s_d_h_1_1c_s_d_h.html#b5f553148de415980dd90cb92f30b54bdd03e29e1e252c9e64e84450d1c109a0">eAS_CCW_BLOCKED</a>, 
<a class="el" href="class_s_d_h_1_1c_s_d_h.html#b5f553148de415980dd90cb92f30b54bcbf7c13f3b209937e332166c228fa021">eAS_DISABLED</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="class_s_d_h_1_1c_s_d_h.html#b5f553148de415980dd90cb92f30b54b7bb4b393269bf39e9ad91385207e318d">eAS_LIMITS_REACHED</a>, 
<a class="el" href="class_s_d_h_1_1c_s_d_h.html#b5f553148de415980dd90cb92f30b54be8b914c1eb4139fc85c92d82e8c63414">eAS_DIMENSION</a>
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The state of an axis (see TPOSCON_STATE in global.h of the SDH firmware).  <a href="class_s_d_h_1_1c_s_d_h.html#b5f553148de415980dd90cb92f30b54b">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#e1999e6293f4e503d6d629adcee2e958">cSDH</a> (bool _use_radians=false, bool _use_fahrenheit=false, int _debug_level=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor of <a class="el" href="class_s_d_h_1_1c_s_d_h.html" title="SDH::cSDH is the end user interface class to control a SDH (SCHUNK Dexterous Hand)...">cSDH</a> class.  <a href="#e1999e6293f4e503d6d629adcee2e958"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#a7b86bd5218e79355c05c9257a504d1d">~cSDH</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#e12663e7fd837a5709790f708047fa59">cSDH</a> (bool _use_radians=false, bool _use_fahrenheit=false, int _debug_level=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor of <a class="el" href="class_s_d_h_1_1c_s_d_h.html" title="SDH::cSDH is the end user interface class to control a SDH (SCHUNK Dexterous Hand)...">cSDH</a> class.  <a href="#e12663e7fd837a5709790f708047fa59"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#59f2c42d8c364da341a85d3441f8620c">~cSDH</a> ()</td></tr>

<tr><td colspan="2"><div class="groupHeader">Communication methods</div></td></tr>
<tr><td colspan="2"><div class="groupText"><a class="anchor" name="sdhlibrary_cpp_sdh_h_csdh_communication"></a> <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#9bc5161da5f49ebe7a0345c05865a84d">OpenRS232</a> (int _port=0, unsigned long _baudrate=115200, double _timeout=-1, char const *_device_format_string=&quot;/dev/ttyS%<a class="el" href="class_s_d_h_1_1c_s_d_h.html#87537330abbd2528f9dccaa105e427f6">d</a>&quot;)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#a850c6f73b8fd06a37851eda019a6ec2">OpenCAN_ESD</a> (int _net=0, unsigned long _baudrate=1000000, double _timeout=0.0, int32_t _id_read=43, int32_t _id_write=42)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#442d66ae38024e6ce112a9de56c0426e">OpenCAN_ESD</a> (<a class="el" href="namespace_s_d_h.html#d644157c3633dee69e0523c30272bc43">NTCAN_HANDLE</a> _ntcan_handle, double _timeout=0.0, int32_t _id_read=43, int32_t _id_write=42)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#1649fb2b3e2e3552f09cf517ebc81ce1">OpenCAN_PEAK</a> (unsigned long _baudrate=1000000, double _timeout=0.0, int32_t _id_read=43, int32_t _id_write=42, const char *device=&quot;/dev/pcanusb0&quot;)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#1327d49edf33b704af4840f8f3bb8022">OpenCAN_PEAK</a> (HANDLE _handle, double _timeout=0.0, int32_t _id_read=43, int32_t _id_write=42)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#0e1850d4007313a924f255ab66973b7c">Close</a> (bool leave_enabled=false)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#6ee64093e4780da152320f8de537fe34">IsOpen</a> (void)  throw ()</td></tr>

<tr><td colspan="2"><div class="groupHeader">Auxiliary movement methods</div></td></tr>
<tr><td colspan="2"><div class="groupText"><a class="anchor" name="sdhlibrary_cpp_sdh_h_csdh_auxilliary"></a> <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#7f71a82ab4074fb32c39b09aa56a6ab6">EmergencyStop</a> (void)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#22ecf8087e812233234c3f81c7b811d6">Stop</a> (void)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#1a36b28e64f6b404205b924e9e55f781">SetController</a> (<a class="el" href="class_s_d_h_1_1c_s_d_h_base.html#610f29a16806030c12e25bf83d89abbd">cSDHBase::eControllerType</a> controller)  throw ( cSDHLibraryException* )</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_s_d_h_1_1c_s_d_h_base.html#610f29a16806030c12e25bf83d89abbd">eControllerType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#f7405f6e9fbd7c82beb0118bf212e173">GetController</a> (void)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#37af32c5dc1153c53524537ba5b460f5">SetVelocityProfile</a> (<a class="el" href="class_s_d_h_1_1c_s_d_h_base.html#024f2645cbaa93a6cca8632a56408cc1">eVelocityProfile</a> velocity_profile)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_s_d_h_1_1c_s_d_h_base.html#024f2645cbaa93a6cca8632a56408cc1">eVelocityProfile</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#54c9569ac8e4bbcc144b6d8679929a79">GetVelocityProfile</a> (void)  throw (cSDHLibraryException*)</td></tr>

<tr><td colspan="2"><div class="groupHeader">Methods to access SDH on axis-level</div></td></tr>
<tr><td colspan="2"><div class="groupText"><a class="anchor" name="sdhlibrary_cpp_sdh_h_csdh_axis"></a> <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#483d0e5db3acab3dbdf012fdafd49089">SetAxisMotorCurrent</a> (std::vector&lt; int &gt; const &amp;axes, std::vector&lt; double &gt; const &amp;motor_currents, <a class="el" href="class_s_d_h_1_1c_s_d_h.html#712b0b80382f1e1e5229ad7bec6cdc4d">eMotorCurrentMode</a> mode=eMCM_MOVE)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#fc3046c2e957ee95eda1e61dde389adf">SetAxisMotorCurrent</a> (int iAxis, double motor_current, <a class="el" href="class_s_d_h_1_1c_s_d_h.html#712b0b80382f1e1e5229ad7bec6cdc4d">eMotorCurrentMode</a> mode=eMCM_MOVE)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#0a45116eb8edbb9c5700431d67968d6e">GetAxisMotorCurrent</a> (std::vector&lt; int &gt; const &amp;axes, <a class="el" href="class_s_d_h_1_1c_s_d_h.html#712b0b80382f1e1e5229ad7bec6cdc4d">eMotorCurrentMode</a> mode=eMCM_MOVE)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#7a5d62417bdf142e6cf57b40277e500a">GetAxisMotorCurrent</a> (int iAxis, <a class="el" href="class_s_d_h_1_1c_s_d_h.html#712b0b80382f1e1e5229ad7bec6cdc4d">eMotorCurrentMode</a> mode=eMCM_MOVE)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#270bf0af4a0bb3f3e8cbe4e1931d7dfd">SetAxisEnable</a> (std::vector&lt; int &gt; const &amp;axes, std::vector&lt; double &gt; const &amp;states)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#988759f8400905534fa5e5bcc032dbf4">SetAxisEnable</a> (int iAxis=All, double state=1.0)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#40df6819257ce8634e8d0db4b678cfef">SetAxisEnable</a> (std::vector&lt; int &gt; const &amp;axes, std::vector&lt; bool &gt; const &amp;states)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#60975160fe4a5cc7d1f7f80d5ab05a1c">SetAxisEnable</a> (int iAxis=All, bool state=true)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#e9845847fa4ab972699d79b25e61de3c">GetAxisEnable</a> (std::vector&lt; int &gt; const &amp;axes)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#653fff0ee151151babf10f1c6e1f0aef">GetAxisEnable</a> (int iAxis)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; <a class="el" href="class_s_d_h_1_1c_s_d_h.html#b5f553148de415980dd90cb92f30b54b">eAxisState</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#d6a6595deb75b468fe8e230c5f356136">GetAxisActualState</a> (std::vector&lt; int &gt; const &amp;axes)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#b5f553148de415980dd90cb92f30b54b">eAxisState</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#51d250e208d3d829e40bc1e4c3413640">GetAxisActualState</a> (int iAxis)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#ddce51bc94cec44f4fe652e168c7ad44">WaitAxis</a> (std::vector&lt; int &gt; const &amp;axes, double timeout=-1.0)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#38fb5c717c3850c40a3dc557d83e3ced">WaitAxis</a> (int iAxis, double timeout=-1.0)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#f14021a2e8c95353d64f86b9208a0904">SetAxisTargetAngle</a> (std::vector&lt; int &gt; const &amp;axes, std::vector&lt; double &gt; const &amp;angles)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#079b2a7c493eab45984ea64b773124a3">SetAxisTargetAngle</a> (int iAxis, double angle)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#f3f5d34fe7fdabb0d6822a79e856e5d1">GetAxisTargetAngle</a> (std::vector&lt; int &gt; const &amp;axes)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#37e84aed060f18bd0581a491cf7c3123">GetAxisTargetAngle</a> (int iAxis)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#9a429222a54007b1e966cd6d2001c10a">GetAxisActualAngle</a> (std::vector&lt; int &gt; const &amp;axes)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#318a0395f2483fba7fd232365b610c70">GetAxisActualAngle</a> (int iAxis)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#9f27d454810035a480e2989ed471fcad">SetAxisTargetVelocity</a> (std::vector&lt; int &gt; const &amp;axes, std::vector&lt; double &gt; const &amp;velocities)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#2bde8d04f76fe8c56a076f2843616e40">SetAxisTargetVelocity</a> (int iAxis, double velocity)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#7bab675982757994c774a9ed1baa30b3">GetAxisTargetVelocity</a> (std::vector&lt; int &gt; const &amp;axes)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#7ceceb1884ef7e5b3d601bf8174e540b">GetAxisTargetVelocity</a> (int iAxis)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#9824173a1618ef9486349a2b99196242">GetAxisLimitVelocity</a> (std::vector&lt; int &gt; const &amp;axes)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#0ca4c1473934ba6ed468d68be66f5fe9">GetAxisLimitVelocity</a> (int iAxis)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#d70ae2e08313f32a6c2f80061f4ff1a3">GetAxisLimitAcceleration</a> (std::vector&lt; int &gt; const &amp;axes)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#45d26862cee701b9f45bfe7c6f1e9c4c">GetAxisLimitAcceleration</a> (int iAxis)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#3e88d83d6cc7e03362bfad2da9d5630e">GetAxisActualVelocity</a> (std::vector&lt; int &gt;const &amp;axes)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#dbf81a0ec719384676d3e4817a308edc">GetAxisActualVelocity</a> (int iAxis)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#3e741ff4ff6bcb387f32e9ff9928e45b">GetAxisReferenceVelocity</a> (std::vector&lt; int &gt;const &amp;axes)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#084b4ef840f147ac7cd4dfa5532cffc3">GetAxisReferenceVelocity</a> (int iAxis)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#4849b377325f407b464ebcd324f4510b">SetAxisTargetAcceleration</a> (std::vector&lt; int &gt;const &amp;axes, std::vector&lt; double &gt;const &amp;accelerations)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#d1a4568a8808ea3ea824cc15faffc127">SetAxisTargetAcceleration</a> (int iAxis, double acceleration)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#8148b4f44c2631ce0f7b1e2dfc450831">GetAxisTargetAcceleration</a> (std::vector&lt; int &gt;const &amp;axes)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#07c6b856a2dd244036686aaeb40965cd">GetAxisTargetAcceleration</a> (int iAxis)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#c2b8ad56584f8ac5a5d0ff010ef8fc54">GetAxisMinAngle</a> (std::vector&lt; int &gt; const &amp;axes)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#301351d4a00cc942c6b3cafd5b6f0d2d">GetAxisMinAngle</a> (int iAxis)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#d12978c317ec5a3ea785453e8907e46f">GetAxisMaxAngle</a> (std::vector&lt; int &gt; const &amp;axes)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#c77ca1ad96d5f7e63cb513b176f9e94c">GetAxisMaxAngle</a> (int iAxis)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#3494e3b5bc533764be487cf057850f79">GetAxisMaxVelocity</a> (std::vector&lt; int &gt; const &amp;axes)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#db06920236cba9b86f529452a5cffc47">GetAxisMaxVelocity</a> (int iAxis)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#f62c9a768ef8ab7f721b6b390de40935">GetAxisMaxAcceleration</a> (std::vector&lt; int &gt; const &amp;axes)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#c2176ca2a159dfa038b249ccc41ae808">GetAxisMaxAcceleration</a> (int iAxis)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#a52181be374dd44517e0b2fef09130c1">MoveAxis</a> (std::vector&lt; int &gt;const &amp;axes, bool sequ=true)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#112b655f39c71eacb4b407fce1cc3f2a">MoveAxis</a> (int iAxis, bool sequ=true)  throw (cSDHLibraryException*)</td></tr>

<tr><td colspan="2"><div class="groupHeader">Methods to access SDH on finger-level</div></td></tr>
<tr><td colspan="2"><div class="groupText"><a class="anchor" name="sdhlibrary_cpp_sdh_h_csdh_finger"></a> <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#4246f404decae71bfea1ff4b27e4cbb6">SetFingerEnable</a> (std::vector&lt; int &gt; const &amp;fingers, std::vector&lt; double &gt; const &amp;states)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#d7d76fcf094c1c37a1ecfe5911a9c186">SetFingerEnable</a> (int iFinger, double state=1.0)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#8e2db3c372a62078954c4eb21396af73">SetFingerEnable</a> (std::vector&lt; int &gt; const &amp;fingers, std::vector&lt; bool &gt; const &amp;states)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#cfb60044e845bc4dd736b8731eb88035">SetFingerEnable</a> (int iFinger, bool state)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#1037c7d5b94845cfc65cb82defca07fe">GetFingerEnable</a> (std::vector&lt; int &gt; const &amp;fingers)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#381455ae42c3d39b4fadf40da7352cb6">GetFingerEnable</a> (int iFinger)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#ba34c83c19e7c5338e6fc09bbf1cebcf">SetFingerTargetAngle</a> (int iFinger, std::vector&lt; double &gt; const &amp;angles)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#c078e2f72e4b6006fe95d8711aceb2ef">SetFingerTargetAngle</a> (int iFinger, double a0, double a1, double a2)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#18c5a988ce669f2d46def2a1f0f779b4">GetFingerTargetAngle</a> (int iFinger)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#2a96a70cf10eea86fefcb47a55e26b0e">GetFingerTargetAngle</a> (int iFinger, double &amp;a0, double &amp;a1, double &amp;a2)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#15777eae7e03b863055834e2cfe87f7d">GetFingerActualAngle</a> (int iFinger)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#c2e42748f9c6979959e8e6f1e155a7ec">GetFingerActualAngle</a> (int iFinger, double &amp;a0, double &amp;a1, double &amp;a2)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#b6a45970a183452da7c7307d88e4fddd">GetFingerMinAngle</a> (int iFinger)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#d7070a86df73d6cf51c3e25ca465f337">GetFingerMinAngle</a> (int iFinger, double &amp;a0, double &amp;a1, double &amp;a2)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#2eb23046335fb06eb5d82b05dffa60a3">GetFingerMaxAngle</a> (int iFinger)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#eb5e5c49e9c9547931f6d1cf12ad400c">GetFingerMaxAngle</a> (int iFinger, double &amp;a0, double &amp;a1, double &amp;a2)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#37bebabf01e96b9e28aab5b015915514">GetFingerXYZ</a> (int iFinger, std::vector&lt; double &gt; const &amp;angles)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#1077543dc0254aa62b296def80ad3130">GetFingerXYZ</a> (int iFinger, double a0, double a1, double a2)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#67baba337dd775a0c8798b7f82738d6d">MoveFinger</a> (std::vector&lt; int &gt;const &amp;fingers, bool sequ=true)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#ca98ac669705fe8491fb860a97c4ea21">MoveFinger</a> (int iFinger, bool sequ=true)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#91ecc6595c68f2c6f00d31ffaea22a60">MoveHand</a> (bool sequ=true)  throw (cSDHLibraryException*)</td></tr>

<tr><td colspan="2"><div class="groupHeader">Methods to access %SDH grip skills</div></td></tr>
<tr><td colspan="2"><div class="groupText"><a class="anchor" name="sdhlibrary_cpp_sdh_h_csdh_grip"></a> <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#579ccdb07f5d218c4b4309e45ae80325">GetGripMaxVelocity</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#1af5350393024630009896e5191a5f94">GripHand</a> (<a class="el" href="class_s_d_h_1_1c_s_d_h_base.html#77b4811e6b0d574a30fe4ccf7d5e7672">eGraspId</a> grip, double close, double velocity, bool sequ=true)  throw (cSDHLibraryException*)</td></tr>

<tr><td colspan="2"><div class="groupHeader">Communication methods</div></td></tr>
<tr><td colspan="2"><div class="groupText"><a class="anchor" name="sdhlibrary_cpp_sdh_h_csdh_communication"></a> <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#2cd8b7c3dcc184de22117c8b17088c10">OpenRS232</a> (int _port=0, unsigned long _baudrate=115200, double _timeout=-1, char const *_device_format_string=&quot;/dev/ttyS%<a class="el" href="class_s_d_h_1_1c_s_d_h.html#87537330abbd2528f9dccaa105e427f6">d</a>&quot;)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#d747bd92682e9983b5a880722cbd1cb0">OpenCAN_ESD</a> (int _net=0, unsigned long _baudrate=1000000, double _timeout=0.0, <a class="el" href="namespace_s_d_h.html#0592c3b027265b9c6d6625e5f7cc189f">Int32</a> _id_read=43, <a class="el" href="namespace_s_d_h.html#0592c3b027265b9c6d6625e5f7cc189f">Int32</a> _id_write=42)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#ff5d621140324dc94bba1d78e2eb9732">OpenCAN_ESD</a> (<a class="el" href="namespace_s_d_h.html#d644157c3633dee69e0523c30272bc43">NTCAN_HANDLE</a> _ntcan_handle, double _timeout=0.0, <a class="el" href="namespace_s_d_h.html#0592c3b027265b9c6d6625e5f7cc189f">Int32</a> _id_read=43, <a class="el" href="namespace_s_d_h.html#0592c3b027265b9c6d6625e5f7cc189f">Int32</a> _id_write=42)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#f039da74d116fffd0373a5777c4d3e84">OpenCAN_PEAK</a> (unsigned long _baudrate=1000000, double _timeout=0.0, <a class="el" href="namespace_s_d_h.html#0592c3b027265b9c6d6625e5f7cc189f">Int32</a> _id_read=43, <a class="el" href="namespace_s_d_h.html#0592c3b027265b9c6d6625e5f7cc189f">Int32</a> _id_write=42, const char *device=&quot;/dev/pcanusb0&quot;)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#516c1bb43d9de5c9af592898e4ae825c">OpenCAN_PEAK</a> (<a class="el" href="namespace_s_d_h.html#17953114f0d151147e596e49e698dcf7">PCAN_HANDLE</a> _handle, double _timeout=0.0, <a class="el" href="namespace_s_d_h.html#0592c3b027265b9c6d6625e5f7cc189f">Int32</a> _id_read=43, <a class="el" href="namespace_s_d_h.html#0592c3b027265b9c6d6625e5f7cc189f">Int32</a> _id_write=42)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#a2c184b28b70513d26f9b711c7d10ef4">Close</a> (bool leave_enabled=false)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#49e010285f563e7a4ae319018bd7c09f">IsOpen</a> (void)  throw ()</td></tr>

<tr><td colspan="2"><div class="groupHeader">Auxiliary movement methods</div></td></tr>
<tr><td colspan="2"><div class="groupText"><a class="anchor" name="sdhlibrary_cpp_sdh_h_csdh_auxilliary"></a> <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#06652e793265a38cf9cd68534d70338f">EmergencyStop</a> (void)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#b358488ff0109fd5ea3d494511bbc332">Stop</a> (void)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#2d385f777077fe43c812120642145289">SetController</a> (<a class="el" href="class_s_d_h_1_1c_s_d_h_base.html#610f29a16806030c12e25bf83d89abbd">cSDHBase::eControllerType</a> controller)  throw ( cSDHLibraryException* )</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_s_d_h_1_1c_s_d_h_base.html#610f29a16806030c12e25bf83d89abbd">eControllerType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#295dacc909e8e377ce4894caafbd3efd">GetController</a> (void)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#2956f857a687f88a647969ec82d08756">SetVelocityProfile</a> (<a class="el" href="class_s_d_h_1_1c_s_d_h_base.html#024f2645cbaa93a6cca8632a56408cc1">eVelocityProfile</a> velocity_profile)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_s_d_h_1_1c_s_d_h_base.html#024f2645cbaa93a6cca8632a56408cc1">eVelocityProfile</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#ad8d32000ee2472270a449082d7d9ada">GetVelocityProfile</a> (void)  throw (cSDHLibraryException*)</td></tr>

<tr><td colspan="2"><div class="groupHeader">Methods to access SDH on axis-level</div></td></tr>
<tr><td colspan="2"><div class="groupText"><a class="anchor" name="sdhlibrary_cpp_sdh_h_csdh_axis"></a> <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#9aeda8b024547100a1d1ccb349ff2414">SetAxisMotorCurrent</a> (std::vector&lt; int &gt; const &amp;axes, std::vector&lt; double &gt; const &amp;motor_currents, <a class="el" href="class_s_d_h_1_1c_s_d_h.html#712b0b80382f1e1e5229ad7bec6cdc4d">eMotorCurrentMode</a> mode=eMCM_MOVE)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#599cfc7a5e6cad3f48509612fb8061c9">SetAxisMotorCurrent</a> (int iAxis, double motor_current, <a class="el" href="class_s_d_h_1_1c_s_d_h.html#712b0b80382f1e1e5229ad7bec6cdc4d">eMotorCurrentMode</a> mode=eMCM_MOVE)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#ab0fff919290a372837c42f37831ba58">GetAxisMotorCurrent</a> (std::vector&lt; int &gt; const &amp;axes, <a class="el" href="class_s_d_h_1_1c_s_d_h.html#712b0b80382f1e1e5229ad7bec6cdc4d">eMotorCurrentMode</a> mode=eMCM_MOVE)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#60b13d32ac395e20429a7fdcc77d9d9e">GetAxisMotorCurrent</a> (int iAxis, <a class="el" href="class_s_d_h_1_1c_s_d_h.html#712b0b80382f1e1e5229ad7bec6cdc4d">eMotorCurrentMode</a> mode=eMCM_MOVE)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#a276e94651c0ad40e569e43486b1b1ef">SetAxisEnable</a> (std::vector&lt; int &gt; const &amp;axes, std::vector&lt; double &gt; const &amp;states)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#531b4a64ac39c61db3214fb9d00ed438">SetAxisEnable</a> (int iAxis=All, double state=1.0)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#6f10f412bce390ed85af76086e666d77">SetAxisEnable</a> (std::vector&lt; int &gt; const &amp;axes, std::vector&lt; bool &gt; const &amp;states)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#6418b2f6f2acc91dce5c7347652a4ba3">SetAxisEnable</a> (int iAxis=All, bool state=true)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#530e11bf3b8bf7fdba54a5c9c7150cfc">GetAxisEnable</a> (std::vector&lt; int &gt; const &amp;axes)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#8d8d6a76a8e81a32509ad3cd95091c34">GetAxisEnable</a> (int iAxis)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; <a class="el" href="class_s_d_h_1_1c_s_d_h.html#b5f553148de415980dd90cb92f30b54b">eAxisState</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#cae1a38dae1b663f14868f3dd9f6e9db">GetAxisActualState</a> (std::vector&lt; int &gt; const &amp;axes)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#b5f553148de415980dd90cb92f30b54b">eAxisState</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#250b704684a5ecee8c05d359ca953450">GetAxisActualState</a> (int iAxis)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#4ab31d14f0da9b8cf23948cd9a894485">WaitAxis</a> (std::vector&lt; int &gt; const &amp;axes, double timeout=-1.0)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#4d9b57c99d3f350b32c9d5f41ca3ab1e">WaitAxis</a> (int iAxis, double timeout=-1.0)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#3a116b9ccdb5e05c6f5fbf9cd78ae2c9">SetAxisTargetAngle</a> (std::vector&lt; int &gt; const &amp;axes, std::vector&lt; double &gt; const &amp;angles)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#d51fe77cc80cd12e68c375c72a1f3722">SetAxisTargetAngle</a> (int iAxis, double angle)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#cf19050a8683914a0e2c2c157c1eb599">GetAxisTargetAngle</a> (std::vector&lt; int &gt; const &amp;axes)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#d89e5e69c4e1ea5f0700f46033da1e4d">GetAxisTargetAngle</a> (int iAxis)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#17927d32a415312baf17759c4625779b">GetAxisActualAngle</a> (std::vector&lt; int &gt; const &amp;axes)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#3c0ad4255d850eceea30fd88f1d95d38">GetAxisActualAngle</a> (int iAxis)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#cca3f17cce0cb3bc7c5662aaadb7af57">SetAxisTargetVelocity</a> (std::vector&lt; int &gt; const &amp;axes, std::vector&lt; double &gt; const &amp;velocities)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#280565f4bb82ea0e90966cbf0932b88d">SetAxisTargetVelocity</a> (int iAxis, double velocity)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#245e28f18d25a3f1409bcd803d2cd69a">GetAxisTargetVelocity</a> (std::vector&lt; int &gt; const &amp;axes)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#36c8071c0db3e66a7d14d05bfa093dc7">GetAxisTargetVelocity</a> (int iAxis)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#71bdd7ba710b65c25719ebe34ce7f32e">GetAxisLimitVelocity</a> (std::vector&lt; int &gt; const &amp;axes)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#b2c7ace95a9705b63e4680e38cc0a31b">GetAxisLimitVelocity</a> (int iAxis)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#c3e9249a68187d9bd206b80008ac6dc6">GetAxisLimitAcceleration</a> (std::vector&lt; int &gt; const &amp;axes)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#031364bfcb90023f3f31fa53e7e92487">GetAxisLimitAcceleration</a> (int iAxis)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#3f1819ddd81a4360fd09569d4a332492">GetAxisActualVelocity</a> (std::vector&lt; int &gt;const &amp;axes)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#bcc7c1f7054ad59faa31547a1108b3cf">GetAxisActualVelocity</a> (int iAxis)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#52b90acfdb27d3a1101f18e5b50f1c11">GetAxisReferenceVelocity</a> (std::vector&lt; int &gt;const &amp;axes)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#5afc15e1866148b7f84de084a384693f">GetAxisReferenceVelocity</a> (int iAxis)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#de124d4d2c0af8a452436f9a8af1f7dc">SetAxisTargetAcceleration</a> (std::vector&lt; int &gt;const &amp;axes, std::vector&lt; double &gt;const &amp;accelerations)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#ca70dc0050cbc0a40676f92bf05488f1">SetAxisTargetAcceleration</a> (int iAxis, double acceleration)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#dd6c5e7880d0fef34d5a610c5cf6c3f8">GetAxisTargetAcceleration</a> (std::vector&lt; int &gt;const &amp;axes)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#a22a2c14c8f1a39fc0f5b56069a42791">GetAxisTargetAcceleration</a> (int iAxis)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#db0de094c9cdd1d9e2749c63e1aeeb64">GetAxisMinAngle</a> (std::vector&lt; int &gt; const &amp;axes)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#0f5c6f7376e92135e7116714b9a6853d">GetAxisMinAngle</a> (int iAxis)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#fb5de902b53b4819ec9d86e83a3a646b">GetAxisMaxAngle</a> (std::vector&lt; int &gt; const &amp;axes)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#2d3a5f135c2ed3adea95f47c4b22209b">GetAxisMaxAngle</a> (int iAxis)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#a2db56e2125830e2670365d24b1994f6">GetAxisMaxVelocity</a> (std::vector&lt; int &gt; const &amp;axes)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#2d5985478e1bfb7183a3adffe0cd3ae6">GetAxisMaxVelocity</a> (int iAxis)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#77b81cd9d1fd2485e00c56bf0109e0ed">GetAxisMaxAcceleration</a> (std::vector&lt; int &gt; const &amp;axes)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#12c98d0559eca3f25974d0de67cb93b4">GetAxisMaxAcceleration</a> (int iAxis)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#bb33108543e81540ce17705e837ed54d">MoveAxis</a> (std::vector&lt; int &gt;const &amp;axes, bool sequ=true)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#cecaf65810c9fc16868e9980fcbf6204">MoveAxis</a> (int iAxis, bool sequ=true)  throw (cSDHLibraryException*)</td></tr>

<tr><td colspan="2"><div class="groupHeader">Methods to access SDH on finger-level</div></td></tr>
<tr><td colspan="2"><div class="groupText"><a class="anchor" name="sdhlibrary_cpp_sdh_h_csdh_finger"></a> <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#b5d9758efb25947cb363d037b17adc21">SetFingerEnable</a> (std::vector&lt; int &gt; const &amp;fingers, std::vector&lt; double &gt; const &amp;states)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#d46a1dc341e307ab053b98b50317e328">SetFingerEnable</a> (int iFinger, double state=1.0)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#7a5037fbff82d34eb47fc91fd516b921">SetFingerEnable</a> (std::vector&lt; int &gt; const &amp;fingers, std::vector&lt; bool &gt; const &amp;states)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#27b344e7929e2a33767957dcd5c69673">SetFingerEnable</a> (int iFinger, bool state)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#6d4772f468b551976b2c4d26228e3f2d">GetFingerEnable</a> (std::vector&lt; int &gt; const &amp;fingers)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#0b586dd9f1434f06062df3af1e507f92">GetFingerEnable</a> (int iFinger)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#e27bd1e53e6f8e232f83436711213e8b">SetFingerTargetAngle</a> (int iFinger, std::vector&lt; double &gt; const &amp;angles)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#e392128c9200b5c85d10125a44fbc7c6">SetFingerTargetAngle</a> (int iFinger, double a0, double a1, double a2)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#73828a841ebaadf20ccca5a2027a0e25">GetFingerTargetAngle</a> (int iFinger)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#9b935b79913c571628d98ab87c07ccef">GetFingerTargetAngle</a> (int iFinger, double &amp;a0, double &amp;a1, double &amp;a2)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#3a4557f390f381811e269827a3d162cc">GetFingerActualAngle</a> (int iFinger)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#0ccde4824bca6a75bfc08802e9af4e9b">GetFingerActualAngle</a> (int iFinger, double &amp;a0, double &amp;a1, double &amp;a2)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#aa8171aba2ad6f2cd5cad263a1401816">GetFingerMinAngle</a> (int iFinger)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#ae71bf00895a3428bfb1b928f59ec867">GetFingerMinAngle</a> (int iFinger, double &amp;a0, double &amp;a1, double &amp;a2)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#0e322deeefdefd5a6ffc3bec094ad78f">GetFingerMaxAngle</a> (int iFinger)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#efd262ffbc73f97c60f6abe3156d42ba">GetFingerMaxAngle</a> (int iFinger, double &amp;a0, double &amp;a1, double &amp;a2)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#760d6b6685148b72735f355eb9f7b3b2">GetFingerXYZ</a> (int iFinger, std::vector&lt; double &gt; const &amp;angles)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#d547b00ac9cfdaf6d0a6d4cfcccf598a">GetFingerXYZ</a> (int iFinger, double a0, double a1, double a2)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#aff8495428a7994c9c2133c92544e8bf">MoveFinger</a> (std::vector&lt; int &gt;const &amp;fingers, bool sequ=true)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#d0192d4ab6ae17eb4dda3314decbb1fa">MoveFinger</a> (int iFinger, bool sequ=true)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#151e9915f406308789f14a8b1afafc8e">MoveHand</a> (bool sequ=true)  throw (cSDHLibraryException*)</td></tr>

<tr><td colspan="2"><div class="groupHeader">Methods to access %SDH grip skills</div></td></tr>
<tr><td colspan="2"><div class="groupText"><a class="anchor" name="sdhlibrary_cpp_sdh_h_csdh_grip"></a> <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#897e52482bbf1f44b070cd8be816b357">GetGripMaxVelocity</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#5084831a54a6a8e94be7e70295cc92fe">GripHand</a> (<a class="el" href="class_s_d_h_1_1c_s_d_h_base.html#77b4811e6b0d574a30fe4ccf7d5e7672">eGraspId</a> grip, double close, double velocity, bool sequ=true)  throw (cSDHLibraryException*)</td></tr>

<tr><td colspan="2"><br><h2>Public Attributes</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Predefined index vector objects</div></td></tr>
<tr><td colspan="2"><div class="groupText"><a class="anchor" name="sdhlibrary_cpp_sdh_h_index_vectors"></a> <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; int &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#157b6e1209a43939b0baf5193ca62ddc">all_axes</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A vector with indices of all axes (in natural order), including the virtual axis.  <a href="#157b6e1209a43939b0baf5193ca62ddc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; int &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#4b213bcda9acbcee7030bc6e5d48d6cf">all_real_axes</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A vector with indices of all real axes (in natural order), excluding the virtual axis.  <a href="#4b213bcda9acbcee7030bc6e5d48d6cf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; int &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#c799c1a91dd82c1d71f627b5496a0afa">all_fingers</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A vector with indices of all fingers (in natural order).  <a href="#c799c1a91dd82c1d71f627b5496a0afa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; int &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#eb72f5095c4a1ad79964b9ef4a5c7bc4">all_temperature_sensors</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A vector with indices of all temperature sensors.  <a href="#eb72f5095c4a1ad79964b9ef4a5c7bc4"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Predefined unit conversion objects</div></td></tr>
<tr><td colspan="2"><div class="groupText"><a class="anchor" name="sdhlibrary_cpp_sdh_h_unit_conversion_ptrs"></a><p>
Pointers to the unit converter objects used by this cSDH object.<p>
The refered objects convert values between different unit systems. Example: convert angle values between <em>degrees</em> and <em>radians</em>, temperatures between <em>degrees</em> <em>celsius</em> and <em>degrees</em> <em>fahrenheit</em> or the like.<p>
A cSDH object uses these converter objects to convert between external (user) and internal (SDH) units. The user can easily change the converter object that is used for a certain kind of unit. This way a cSDH object can easily report and accept parameters in the user or application specific unit system.<p>
Additionally, users can easily add conversion objects for their own, even more user- or application-specific unit systems. <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#bcb9da3cf0236c0e09cdd7af1a78225e">uc_angle</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">unit convert for (axis) angles: default = <a class="el" href="class_s_d_h_1_1c_s_d_h.html#128db2c199bab6ee328be4df7fd7f24f" title="Default converter for angles (internal unit == external unit): degrees.">SDH::cSDH::uc_angle_degrees</a>  <a href="#bcb9da3cf0236c0e09cdd7af1a78225e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#81c208eb64b0954dfef4182575ff6bc9">uc_angular_velocity</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">unit convert for (axis) angular velocities: default = <a class="el" href="class_s_d_h_1_1c_s_d_h.html#15ff510d1954ea58e34251fcc3a5cb34" title="Default converter for angular velocities (internal unit == external unit): degrees...">SDH::cSDH::uc_angular_velocity_degrees_per_second</a>  <a href="#81c208eb64b0954dfef4182575ff6bc9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#8dc039c618c3383d5fefd85d41866f9e">uc_angular_acceleration</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">unit convert for (axis) angular accelerations: default = <a class="el" href="class_s_d_h_1_1c_s_d_h.html#37e1c49a2cc7d6599306c71ed2b2b00f" title="Default converter for angular accelerations (internal unit == external unit): degrees...">SDH::cSDH::uc_angular_acceleration_degrees_per_second_squared</a>  <a href="#8dc039c618c3383d5fefd85d41866f9e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#7479296b9f0c7300dc50452c7c929bc2">uc_time</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">unit convert for times: default = uc_time_seconds  <a href="#7479296b9f0c7300dc50452c7c929bc2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#844b1311f5be6eb5474157d9c24e7a5e">uc_temperature</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">unit convert for temperatures: default = <a class="el" href="class_s_d_h_1_1c_s_d_h.html#3a16fe0f08ebb82d79edf1a7fa502c2f" title="Default converter for temparatures (internal unit == external unit): degrees celsius...">SDH::cSDH::uc_temperature_celsius</a>  <a href="#844b1311f5be6eb5474157d9c24e7a5e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#57bb98bd30adf2189a62f31388bc6bae">uc_motor_current</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">unit converter for motor curent: default = <a class="el" href="class_s_d_h_1_1c_s_d_h.html#d81dfd6cad39b84734a1bc39e48e2fdd" title="Default converter for motor current (internal unit == external unit): Ampere.">SDH::cSDH::uc_motor_current_ampere</a>  <a href="#57bb98bd30adf2189a62f31388bc6bae"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#b16893e67eb1273cd95adcd6c0d5e631">uc_position</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">unit converter for position: default = <a class="el" href="class_s_d_h_1_1c_s_d_h.html#2a5abd24424bf5a92c3b74819d26cdc5" title="Default converter for position (internal unit == external unit): millimeter.">SDH::cSDH::uc_position_millimeter</a>  <a href="#b16893e67eb1273cd95adcd6c0d5e631"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Predefined index vector objects</div></td></tr>
<tr><td colspan="2"><div class="groupText"><a class="anchor" name="sdhlibrary_cpp_sdh_h_index_vectors"></a> <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; int &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#157b6e1209a43939b0baf5193ca62ddc">all_axes</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A vector with indices of all axes (in natural order), including the virtual axis.  <a href="#157b6e1209a43939b0baf5193ca62ddc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; int &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#4b213bcda9acbcee7030bc6e5d48d6cf">all_real_axes</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A vector with indices of all real axes (in natural order), excluding the virtual axis.  <a href="#4b213bcda9acbcee7030bc6e5d48d6cf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; int &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#c799c1a91dd82c1d71f627b5496a0afa">all_fingers</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A vector with indices of all fingers (in natural order).  <a href="#c799c1a91dd82c1d71f627b5496a0afa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; int &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#eb72f5095c4a1ad79964b9ef4a5c7bc4">all_temperature_sensors</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A vector with indices of all temperature sensors.  <a href="#eb72f5095c4a1ad79964b9ef4a5c7bc4"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Predefined unit conversion objects</div></td></tr>
<tr><td colspan="2"><div class="groupText"><a class="anchor" name="sdhlibrary_cpp_sdh_h_unit_conversion_ptrs"></a><p>
Pointers to the unit converter objects used by this cSDH object.<p>
The refered objects convert values between different unit systems. Example: convert angle values between <em>degrees</em> and <em>radians</em>, temperatures between <em>degrees</em> <em>celsius</em> and <em>degrees</em> <em>fahrenheit</em> or the like.<p>
A cSDH object uses these converter objects to convert between external (user) and internal (SDH) units. The user can easily change the converter object that is used for a certain kind of unit. This way a cSDH object can easily report and accept parameters in the user or application specific unit system.<p>
Additionally, users can easily add conversion objects for their own, even more user- or application-specific unit systems. <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#bcb9da3cf0236c0e09cdd7af1a78225e">uc_angle</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">unit convert for (axis) angles: default = <a class="el" href="class_s_d_h_1_1c_s_d_h.html#128db2c199bab6ee328be4df7fd7f24f" title="Default converter for angles (internal unit == external unit): degrees.">SDH::cSDH::uc_angle_degrees</a>  <a href="#bcb9da3cf0236c0e09cdd7af1a78225e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#81c208eb64b0954dfef4182575ff6bc9">uc_angular_velocity</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">unit convert for (axis) angular velocities: default = <a class="el" href="class_s_d_h_1_1c_s_d_h.html#15ff510d1954ea58e34251fcc3a5cb34" title="Default converter for angular velocities (internal unit == external unit): degrees...">SDH::cSDH::uc_angular_velocity_degrees_per_second</a>  <a href="#81c208eb64b0954dfef4182575ff6bc9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#8dc039c618c3383d5fefd85d41866f9e">uc_angular_acceleration</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">unit convert for (axis) angular accelerations: default = <a class="el" href="class_s_d_h_1_1c_s_d_h.html#37e1c49a2cc7d6599306c71ed2b2b00f" title="Default converter for angular accelerations (internal unit == external unit): degrees...">SDH::cSDH::uc_angular_acceleration_degrees_per_second_squared</a>  <a href="#8dc039c618c3383d5fefd85d41866f9e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#7479296b9f0c7300dc50452c7c929bc2">uc_time</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">unit convert for times: default = uc_time_seconds  <a href="#7479296b9f0c7300dc50452c7c929bc2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#844b1311f5be6eb5474157d9c24e7a5e">uc_temperature</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">unit convert for temperatures: default = <a class="el" href="class_s_d_h_1_1c_s_d_h.html#3a16fe0f08ebb82d79edf1a7fa502c2f" title="Default converter for temparatures (internal unit == external unit): degrees celsius...">SDH::cSDH::uc_temperature_celsius</a>  <a href="#844b1311f5be6eb5474157d9c24e7a5e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#57bb98bd30adf2189a62f31388bc6bae">uc_motor_current</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">unit converter for motor curent: default = <a class="el" href="class_s_d_h_1_1c_s_d_h.html#d81dfd6cad39b84734a1bc39e48e2fdd" title="Default converter for motor current (internal unit == external unit): Ampere.">SDH::cSDH::uc_motor_current_ampere</a>  <a href="#57bb98bd30adf2189a62f31388bc6bae"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#b16893e67eb1273cd95adcd6c0d5e631">uc_position</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">unit converter for position: default = <a class="el" href="class_s_d_h_1_1c_s_d_h.html#2a5abd24424bf5a92c3b74819d26cdc5" title="Default converter for position (internal unit == external unit): millimeter.">SDH::cSDH::uc_position_millimeter</a>  <a href="#b16893e67eb1273cd95adcd6c0d5e631"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Attributes</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Predefined unit conversion objecs</div></td></tr>
<tr><td colspan="2"><div class="groupText"><a class="anchor" name="sdhlibrary_cpp_sdh_h_unit_conversion_objects"></a><p>
Some predefined cUnitConverter unit conversion objects to convert values between different unit systems. These are static members since the converter objects do not depend on the individiual cSDH object.<p>
For every physical unit used in the cSDH class there is at least one (most of the time more than one) predefined unit converter. For example for angles there are <em>radians</em> and <em>degrees</em>. <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a> const&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#128db2c199bab6ee328be4df7fd7f24f">uc_angle_degrees</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default converter for angles (internal unit == external unit): degrees.  <a href="#128db2c199bab6ee328be4df7fd7f24f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a> const&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#d471654c3963c7fa871061a5dde8f609">uc_angle_radians</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converter for angles: external unit = radians.  <a href="#d471654c3963c7fa871061a5dde8f609"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a> const&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#b9dcca0719b243ad2313e4587e3716d5">uc_time_seconds</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default converter for times (internal unit == external unit): seconds.  <a href="#b9dcca0719b243ad2313e4587e3716d5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a> const&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#4b647e0946acd200b019b29169951ab4">uc_time_milliseconds</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converter for times: external unit = milliseconds.  <a href="#4b647e0946acd200b019b29169951ab4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a> const&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#3a16fe0f08ebb82d79edf1a7fa502c2f">uc_temperature_celsius</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default converter for temparatures (internal unit == external unit): degrees celsius.  <a href="#3a16fe0f08ebb82d79edf1a7fa502c2f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a> const&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#91a8319e68109aeec7f97008572f7177">uc_temperature_fahrenheit</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converter for temperatures: external unit = degrees fahrenheit.  <a href="#91a8319e68109aeec7f97008572f7177"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a> const&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#15ff510d1954ea58e34251fcc3a5cb34">uc_angular_velocity_degrees_per_second</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default converter for angular velocities (internal unit == external unit): degrees / second.  <a href="#15ff510d1954ea58e34251fcc3a5cb34"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a> const&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#a4de0ead7be9184d43f2d9a4dbdeb534">uc_angular_velocity_radians_per_second</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converter for angular velocieties: external unit = radians/second.  <a href="#a4de0ead7be9184d43f2d9a4dbdeb534"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a> const&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#37e1c49a2cc7d6599306c71ed2b2b00f">uc_angular_acceleration_degrees_per_second_squared</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default converter for angular accelerations (internal unit == external unit): degrees / second.  <a href="#37e1c49a2cc7d6599306c71ed2b2b00f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a> const&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#c512eedd92c67e9322f0157b7656c204">uc_angular_acceleration_radians_per_second_squared</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converter for angular velocieties: external unit = radians/second.  <a href="#c512eedd92c67e9322f0157b7656c204"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a> const&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#d81dfd6cad39b84734a1bc39e48e2fdd">uc_motor_current_ampere</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default converter for motor current (internal unit == external unit): Ampere.  <a href="#d81dfd6cad39b84734a1bc39e48e2fdd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a> const&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#002297a9389ad44c6b6b635f62fddad6">uc_motor_current_milliampere</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converter for motor current: external unit = milli Ampere.  <a href="#002297a9389ad44c6b6b635f62fddad6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a> const&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#2a5abd24424bf5a92c3b74819d26cdc5">uc_position_millimeter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default converter for position (internal unit == external unit): millimeter.  <a href="#2a5abd24424bf5a92c3b74819d26cdc5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a> const&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#9c39c381b642d85d059c98b593af7178">uc_position_meter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converter for position: external unit = meter.  <a href="#9c39c381b642d85d059c98b593af7178"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Internal helper methods</div></td></tr>
<tr><td colspan="2"><div class="groupText"><a class="anchor" name="sdhlibrary_cpp_sdh_h_csdh_internal"></a> <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#a8eced47a1f0af0be26a1da3766f0f90">SetAxisValueVector</a> (std::vector&lt; int &gt; const &amp;axes, std::vector&lt; double &gt; const &amp;values, <a class="el" href="namespace_s_d_h.html#2125769495fc86ea25e2fc2181887723">pSetFunction</a> ll_set, <a class="el" href="namespace_s_d_h.html#cbae245111c9c3618d335156ba2e04f7">pGetFunction</a> ll_get, <a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a> const *uc, std::vector&lt; double &gt; const &amp;min_values, std::vector&lt; double &gt; const &amp;max_values, char const *name)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#ff0b88d27ef55ea733912108887790d2">GetAxisValueVector</a> (std::vector&lt; int &gt; const &amp;axes, <a class="el" href="namespace_s_d_h.html#cbae245111c9c3618d335156ba2e04f7">pGetFunction</a> ll_get, <a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a> const *uc, char const *name)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; int &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#e7990e0566bab2192ae725f9aecddf04">ToIndexVector</a> (int index, std::vector&lt; int &gt; &amp;all_replacement, int maxindex, char const *name)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespace_s_d_h.html#2125769495fc86ea25e2fc2181887723">pSetFunction</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#68299d95c3df050b727a63f839adc0ec">GetMotorCurrentModeFunction</a> (<a class="el" href="class_s_d_h_1_1c_s_d_h.html#712b0b80382f1e1e5229ad7bec6cdc4d">eMotorCurrentMode</a> mode)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#07f00798e4d660d1f24e6724ff899b38">_GetFingerXYZ</a> (int fi, std::vector&lt; double &gt; r_angles)  throw (cSDHLibraryException*)</td></tr>

<tr><td colspan="2"><div class="groupHeader">Internal helper methods</div></td></tr>
<tr><td colspan="2"><div class="groupText"><a class="anchor" name="sdhlibrary_cpp_sdh_h_csdh_internal"></a> <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#fb366fc46fff7b6840028bc053f88e5f">SetAxisValueVector</a> (std::vector&lt; int &gt; const &amp;axes, std::vector&lt; double &gt; const &amp;values, <a class="el" href="namespace_s_d_h.html#2125769495fc86ea25e2fc2181887723">pSetFunction</a> ll_set, <a class="el" href="namespace_s_d_h.html#cbae245111c9c3618d335156ba2e04f7">pGetFunction</a> ll_get, <a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a> const *uc, std::vector&lt; double &gt; const &amp;min_values, std::vector&lt; double &gt; const &amp;max_values, char const *name)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#226208ca2312aeab801124ea4004802f">GetAxisValueVector</a> (std::vector&lt; int &gt; const &amp;axes, <a class="el" href="namespace_s_d_h.html#cbae245111c9c3618d335156ba2e04f7">pGetFunction</a> ll_get, <a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a> const *uc, char const *name)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; int &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#47871a0d85a4eadeca0b64c592e98811">ToIndexVector</a> (int index, std::vector&lt; int &gt; &amp;all_replacement, int maxindex, char const *name)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespace_s_d_h.html#2125769495fc86ea25e2fc2181887723">pSetFunction</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#d32ec1d5fed635ab5a656ead26928731">GetMotorCurrentModeFunction</a> (<a class="el" href="class_s_d_h_1_1c_s_d_h.html#712b0b80382f1e1e5229ad7bec6cdc4d">eMotorCurrentMode</a> mode)  throw (cSDHLibraryException*)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#11b4b8ae7bc600bb502d7e42f9743456">_GetFingerXYZ</a> (int fi, std::vector&lt; double &gt; r_angles)  throw (cSDHLibraryException*)</td></tr>

<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#3cd0859b0389fc608884ae8efd027d41">NUMBER_OF_AXES_PER_FINGER</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The number of axis per finger (for finger 1 this includes the "virtual" base axis).  <a href="#3cd0859b0389fc608884ae8efd027d41"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#35c9f020727af4798822aae99f333275">NUMBER_OF_VIRTUAL_AXES</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The number of virtual axes.  <a href="#35c9f020727af4798822aae99f333275"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#4ab4ed09ed69f35e554de6c4e4bd5368">nb_all_axes</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The number of all axes including virtual axes.  <a href="#4ab4ed09ed69f35e554de6c4e4bd5368"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; int &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#662368ab129bb5c1fdfe6d4daad79957">finger_number_of_axes</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mapping of finger index to number of real axes of fingers:.  <a href="#662368ab129bb5c1fdfe6d4daad79957"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; std::vector&lt; int &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#df0c8a9654dd2009d3d5d8402ec3cc83">finger_axis_index</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mapping of finger index, finger axis index to axis index:.  <a href="#df0c8a9654dd2009d3d5d8402ec3cc83"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#8000fdeb249c0ba27c0e4af39271324f">f_zeros_v</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Vector of 3 epsilon values.  <a href="#8000fdeb249c0ba27c0e4af39271324f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#c365f6580d9d323ce4c4f62b2ee55c5c">f_ones_v</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Vector of 3 1.0 values.  <a href="#c365f6580d9d323ce4c4f62b2ee55c5c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#7d5ad2d98ddf0bedb5727077b2d174b1">zeros_v</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Vector of nb_all_axes 0.0 values.  <a href="#7d5ad2d98ddf0bedb5727077b2d174b1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#fcc291c929ce6272f9bfd57023e7e291">ones_v</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Vector of nb_all_axes 1.0 values.  <a href="#fcc291c929ce6272f9bfd57023e7e291"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#251ba34b893b1869a762e8e8884d09c8">f_min_motor_current_v</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Minimum allowed motor currents (in internal units (Ampere)), including the virtual axis.  <a href="#251ba34b893b1869a762e8e8884d09c8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#c2a56629fe34ac72d6cc1ad5cbde2ed0">f_max_motor_current_v</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maximum allowed motor currents (in internal units (Ampere)), including the virtual axis.  <a href="#c2a56629fe34ac72d6cc1ad5cbde2ed0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#c65462197f02ea542d4a34206c866a20">f_min_angle_v</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Minimum allowed axis angles (in internal units (degrees)), including the virtual axis.  <a href="#c65462197f02ea542d4a34206c866a20"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#bd406a461d7fd466b6ae8708b1011e0c">f_max_angle_v</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maximum allowed axis angles (in internal units (degrees)), including the virtual axis.  <a href="#bd406a461d7fd466b6ae8708b1011e0c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#b7e83851fdc4d64017b62e1a062ea742">f_min_velocity_v</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Minimum allowed axis velocity (in internal units (degrees/second)), including the virtual axis.  <a href="#b7e83851fdc4d64017b62e1a062ea742"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#3ec3baeb713e23b6585be21d54f43b21">f_max_velocity_v</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maximum allowed axis velocity (in internal units (degrees/second)), including the virtual axis.  <a href="#3ec3baeb713e23b6585be21d54f43b21"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#51c6309e76ea3cf2de543cffd4bc94d6">f_min_acceleration_v</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Minimum allowed axis acceleration (in internal units (degrees/(second * second))), including the virtual axis.  <a href="#51c6309e76ea3cf2de543cffd4bc94d6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#c9d421f2e8f0c6da67071f3b8a07eff0">f_max_acceleration_v</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maximum allowed axis acceleration (in internal units (degrees/(second * second))), including the virtual axis.  <a href="#c9d421f2e8f0c6da67071f3b8a07eff0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#c8da2aa15adef9b959c9d4322f9fc2f1">grip_max_velocity</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maximum allowed grip velocity (in internal units (degrees/second)).  <a href="#c8da2aa15adef9b959c9d4322f9fc2f1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; int &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#662368ab129bb5c1fdfe6d4daad79957">finger_number_of_axes</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mapping of finger index to number of real axes of fingers:.  <a href="#662368ab129bb5c1fdfe6d4daad79957"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; std::vector&lt; int &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#df0c8a9654dd2009d3d5d8402ec3cc83">finger_axis_index</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mapping of finger index, finger axis index to axis index:.  <a href="#df0c8a9654dd2009d3d5d8402ec3cc83"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#8000fdeb249c0ba27c0e4af39271324f">f_zeros_v</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Vector of 3 epsilon values.  <a href="#8000fdeb249c0ba27c0e4af39271324f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#c365f6580d9d323ce4c4f62b2ee55c5c">f_ones_v</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Vector of 3 1.0 values.  <a href="#c365f6580d9d323ce4c4f62b2ee55c5c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#7d5ad2d98ddf0bedb5727077b2d174b1">zeros_v</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Vector of nb_all_axes 0.0 values.  <a href="#7d5ad2d98ddf0bedb5727077b2d174b1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#fcc291c929ce6272f9bfd57023e7e291">ones_v</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Vector of nb_all_axes 1.0 values.  <a href="#fcc291c929ce6272f9bfd57023e7e291"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#251ba34b893b1869a762e8e8884d09c8">f_min_motor_current_v</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Minimum allowed motor currents (in internal units (Ampere)), including the virtual axis.  <a href="#251ba34b893b1869a762e8e8884d09c8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#c2a56629fe34ac72d6cc1ad5cbde2ed0">f_max_motor_current_v</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maximum allowed motor currents (in internal units (Ampere)), including the virtual axis.  <a href="#c2a56629fe34ac72d6cc1ad5cbde2ed0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#c65462197f02ea542d4a34206c866a20">f_min_angle_v</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Minimum allowed axis angles (in internal units (degrees)), including the virtual axis.  <a href="#c65462197f02ea542d4a34206c866a20"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#bd406a461d7fd466b6ae8708b1011e0c">f_max_angle_v</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maximum allowed axis angles (in internal units (degrees)), including the virtual axis.  <a href="#bd406a461d7fd466b6ae8708b1011e0c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#b7e83851fdc4d64017b62e1a062ea742">f_min_velocity_v</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Minimum allowed axis velocity (in internal units (degrees/second)), including the virtual axis.  <a href="#b7e83851fdc4d64017b62e1a062ea742"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#3ec3baeb713e23b6585be21d54f43b21">f_max_velocity_v</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maximum allowed axis velocity (in internal units (degrees/second)), including the virtual axis.  <a href="#3ec3baeb713e23b6585be21d54f43b21"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#51c6309e76ea3cf2de543cffd4bc94d6">f_min_acceleration_v</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Minimum allowed axis acceleration (in internal units (degrees/(second * second))), including the virtual axis.  <a href="#51c6309e76ea3cf2de543cffd4bc94d6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#c9d421f2e8f0c6da67071f3b8a07eff0">f_max_acceleration_v</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maximum allowed axis acceleration (in internal units (degrees/(second * second))), including the virtual axis.  <a href="#c9d421f2e8f0c6da67071f3b8a07eff0"></a><br></td></tr>
</table>
<hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="712b0b80382f1e1e5229ad7bec6cdc4d"></a><!-- doxytag: member="SDH::cSDH::eMotorCurrentMode" ref="712b0b80382f1e1e5229ad7bec6cdc4d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_s_d_h_1_1c_s_d_h.html#712b0b80382f1e1e5229ad7bec6cdc4d">SDH::cSDH::eMotorCurrentMode</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
the motor current can be set specifically for these modes: 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="712b0b80382f1e1e5229ad7bec6cdc4da0a075991ceba063aff574398f8ff05e"></a><!-- doxytag: member="eMCM_MOVE" ref="712b0b80382f1e1e5229ad7bec6cdc4da0a075991ceba063aff574398f8ff05e" args="" -->eMCM_MOVE</em>&nbsp;</td><td>
The motor currents used while "moving" with a <a class="el" href="class_s_d_h_1_1c_s_d_h.html#91ecc6595c68f2c6f00d31ffaea22a60">MoveHand()</a> or <a class="el" href="class_s_d_h_1_1c_s_d_h.html#67baba337dd775a0c8798b7f82738d6d">MoveFinger()</a> command. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="712b0b80382f1e1e5229ad7bec6cdc4d63872c18691513275682b347c68732b5"></a><!-- doxytag: member="eMCM_GRIP" ref="712b0b80382f1e1e5229ad7bec6cdc4d63872c18691513275682b347c68732b5" args="" -->eMCM_GRIP</em>&nbsp;</td><td>
The motor currents used while "gripping" with a <a class="el" href="class_s_d_h_1_1c_s_d_h.html#1af5350393024630009896e5191a5f94">GripHand()</a> command. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="712b0b80382f1e1e5229ad7bec6cdc4d690e9bb2611fe2a597bb2b9443856fe1"></a><!-- doxytag: member="eMCM_HOLD" ref="712b0b80382f1e1e5229ad7bec6cdc4d690e9bb2611fe2a597bb2b9443856fe1" args="" -->eMCM_HOLD</em>&nbsp;</td><td>
The motor currents used after "gripping" with a <a class="el" href="class_s_d_h_1_1c_s_d_h.html#1af5350393024630009896e5191a5f94">GripHand()</a> command (i.e. "holding"). </td></tr>
<tr><td valign="top"><em><a class="anchor" name="712b0b80382f1e1e5229ad7bec6cdc4dd06a5321282cd5a7ab04475059df7f63"></a><!-- doxytag: member="eMCM_DIMENSION" ref="712b0b80382f1e1e5229ad7bec6cdc4dd06a5321282cd5a7ab04475059df7f63" args="" -->eMCM_DIMENSION</em>&nbsp;</td><td>
Endmarker and Dimension. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="712b0b80382f1e1e5229ad7bec6cdc4da0a075991ceba063aff574398f8ff05e"></a><!-- doxytag: member="eMCM_MOVE" ref="712b0b80382f1e1e5229ad7bec6cdc4da0a075991ceba063aff574398f8ff05e" args="" -->eMCM_MOVE</em>&nbsp;</td><td>
The motor currents used while "moving" with a <a class="el" href="class_s_d_h_1_1c_s_d_h.html#91ecc6595c68f2c6f00d31ffaea22a60">MoveHand()</a> or <a class="el" href="class_s_d_h_1_1c_s_d_h.html#67baba337dd775a0c8798b7f82738d6d">MoveFinger()</a> command. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="712b0b80382f1e1e5229ad7bec6cdc4d63872c18691513275682b347c68732b5"></a><!-- doxytag: member="eMCM_GRIP" ref="712b0b80382f1e1e5229ad7bec6cdc4d63872c18691513275682b347c68732b5" args="" -->eMCM_GRIP</em>&nbsp;</td><td>
The motor currents used while "gripping" with a <a class="el" href="class_s_d_h_1_1c_s_d_h.html#1af5350393024630009896e5191a5f94">GripHand()</a> command. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="712b0b80382f1e1e5229ad7bec6cdc4d690e9bb2611fe2a597bb2b9443856fe1"></a><!-- doxytag: member="eMCM_HOLD" ref="712b0b80382f1e1e5229ad7bec6cdc4d690e9bb2611fe2a597bb2b9443856fe1" args="" -->eMCM_HOLD</em>&nbsp;</td><td>
The motor currents used after "gripping" with a <a class="el" href="class_s_d_h_1_1c_s_d_h.html#1af5350393024630009896e5191a5f94">GripHand()</a> command (i.e. "holding"). </td></tr>
<tr><td valign="top"><em><a class="anchor" name="712b0b80382f1e1e5229ad7bec6cdc4dd06a5321282cd5a7ab04475059df7f63"></a><!-- doxytag: member="eMCM_DIMENSION" ref="712b0b80382f1e1e5229ad7bec6cdc4dd06a5321282cd5a7ab04475059df7f63" args="" -->eMCM_DIMENSION</em>&nbsp;</td><td>
Endmarker and Dimension. </td></tr>
</table>
</dl>

</div>
</div><p>
<a class="anchor" name="b5f553148de415980dd90cb92f30b54b"></a><!-- doxytag: member="SDH::cSDH::eAxisState" ref="b5f553148de415980dd90cb92f30b54b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_s_d_h_1_1c_s_d_h.html#b5f553148de415980dd90cb92f30b54b">SDH::cSDH::eAxisState</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The state of an axis (see TPOSCON_STATE in global.h of the SDH firmware). 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="b5f553148de415980dd90cb92f30b54bd966c9e6d1145850dd60e12bdce4f5dc"></a><!-- doxytag: member="eAS_IDLE" ref="b5f553148de415980dd90cb92f30b54bd966c9e6d1145850dd60e12bdce4f5dc" args="" -->eAS_IDLE</em>&nbsp;</td><td>
axis is idle </td></tr>
<tr><td valign="top"><em><a class="anchor" name="b5f553148de415980dd90cb92f30b54bdc62e02ed19a432396a9d4ea968d0676"></a><!-- doxytag: member="eAS_POSITIONING" ref="b5f553148de415980dd90cb92f30b54bdc62e02ed19a432396a9d4ea968d0676" args="" -->eAS_POSITIONING</em>&nbsp;</td><td>
the goal position has not been reached yet </td></tr>
<tr><td valign="top"><em><a class="anchor" name="b5f553148de415980dd90cb92f30b54b52c8e94f5f0f5c7418a24882dbb8ce05"></a><!-- doxytag: member="eAS_SPEED_MODE" ref="b5f553148de415980dd90cb92f30b54b52c8e94f5f0f5c7418a24882dbb8ce05" args="" -->eAS_SPEED_MODE</em>&nbsp;</td><td>
axis is in speed mode </td></tr>
<tr><td valign="top"><em><a class="anchor" name="b5f553148de415980dd90cb92f30b54b09f097ac98da3f3fd1525b05c4d46b0a"></a><!-- doxytag: member="eAS_NOT_INITIALIZED" ref="b5f553148de415980dd90cb92f30b54b09f097ac98da3f3fd1525b05c4d46b0a" args="" -->eAS_NOT_INITIALIZED</em>&nbsp;</td><td>
axis is not initialized or doesn't exist </td></tr>
<tr><td valign="top"><em><a class="anchor" name="b5f553148de415980dd90cb92f30b54b13f7039cb7faa7831ea8507e49f43963"></a><!-- doxytag: member="eAS_CW_BLOCKED" ref="b5f553148de415980dd90cb92f30b54b13f7039cb7faa7831ea8507e49f43963" args="" -->eAS_CW_BLOCKED</em>&nbsp;</td><td>
axis is blocked in counterwise direction </td></tr>
<tr><td valign="top"><em><a class="anchor" name="b5f553148de415980dd90cb92f30b54bdd03e29e1e252c9e64e84450d1c109a0"></a><!-- doxytag: member="eAS_CCW_BLOCKED" ref="b5f553148de415980dd90cb92f30b54bdd03e29e1e252c9e64e84450d1c109a0" args="" -->eAS_CCW_BLOCKED</em>&nbsp;</td><td>
axis is blocked is blocked in against counterwise direction </td></tr>
<tr><td valign="top"><em><a class="anchor" name="b5f553148de415980dd90cb92f30b54bcbf7c13f3b209937e332166c228fa021"></a><!-- doxytag: member="eAS_DISABLED" ref="b5f553148de415980dd90cb92f30b54bcbf7c13f3b209937e332166c228fa021" args="" -->eAS_DISABLED</em>&nbsp;</td><td>
axis is disabled </td></tr>
<tr><td valign="top"><em><a class="anchor" name="b5f553148de415980dd90cb92f30b54b7bb4b393269bf39e9ad91385207e318d"></a><!-- doxytag: member="eAS_LIMITS_REACHED" ref="b5f553148de415980dd90cb92f30b54b7bb4b393269bf39e9ad91385207e318d" args="" -->eAS_LIMITS_REACHED</em>&nbsp;</td><td>
position limits reached and axis stopped </td></tr>
<tr><td valign="top"><em><a class="anchor" name="b5f553148de415980dd90cb92f30b54be8b914c1eb4139fc85c92d82e8c63414"></a><!-- doxytag: member="eAS_DIMENSION" ref="b5f553148de415980dd90cb92f30b54be8b914c1eb4139fc85c92d82e8c63414" args="" -->eAS_DIMENSION</em>&nbsp;</td><td>
Endmarker and Dimension. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="b5f553148de415980dd90cb92f30b54bd966c9e6d1145850dd60e12bdce4f5dc"></a><!-- doxytag: member="eAS_IDLE" ref="b5f553148de415980dd90cb92f30b54bd966c9e6d1145850dd60e12bdce4f5dc" args="" -->eAS_IDLE</em>&nbsp;</td><td>
axis is idle </td></tr>
<tr><td valign="top"><em><a class="anchor" name="b5f553148de415980dd90cb92f30b54bdc62e02ed19a432396a9d4ea968d0676"></a><!-- doxytag: member="eAS_POSITIONING" ref="b5f553148de415980dd90cb92f30b54bdc62e02ed19a432396a9d4ea968d0676" args="" -->eAS_POSITIONING</em>&nbsp;</td><td>
the goal position has not been reached yet </td></tr>
<tr><td valign="top"><em><a class="anchor" name="b5f553148de415980dd90cb92f30b54b52c8e94f5f0f5c7418a24882dbb8ce05"></a><!-- doxytag: member="eAS_SPEED_MODE" ref="b5f553148de415980dd90cb92f30b54b52c8e94f5f0f5c7418a24882dbb8ce05" args="" -->eAS_SPEED_MODE</em>&nbsp;</td><td>
axis is in speed mode </td></tr>
<tr><td valign="top"><em><a class="anchor" name="b5f553148de415980dd90cb92f30b54b09f097ac98da3f3fd1525b05c4d46b0a"></a><!-- doxytag: member="eAS_NOT_INITIALIZED" ref="b5f553148de415980dd90cb92f30b54b09f097ac98da3f3fd1525b05c4d46b0a" args="" -->eAS_NOT_INITIALIZED</em>&nbsp;</td><td>
axis is not initialized or doesn't exist </td></tr>
<tr><td valign="top"><em><a class="anchor" name="b5f553148de415980dd90cb92f30b54b13f7039cb7faa7831ea8507e49f43963"></a><!-- doxytag: member="eAS_CW_BLOCKED" ref="b5f553148de415980dd90cb92f30b54b13f7039cb7faa7831ea8507e49f43963" args="" -->eAS_CW_BLOCKED</em>&nbsp;</td><td>
axis is blocked in counterwise direction </td></tr>
<tr><td valign="top"><em><a class="anchor" name="b5f553148de415980dd90cb92f30b54bdd03e29e1e252c9e64e84450d1c109a0"></a><!-- doxytag: member="eAS_CCW_BLOCKED" ref="b5f553148de415980dd90cb92f30b54bdd03e29e1e252c9e64e84450d1c109a0" args="" -->eAS_CCW_BLOCKED</em>&nbsp;</td><td>
axis is blocked is blocked in against counterwise direction </td></tr>
<tr><td valign="top"><em><a class="anchor" name="b5f553148de415980dd90cb92f30b54bcbf7c13f3b209937e332166c228fa021"></a><!-- doxytag: member="eAS_DISABLED" ref="b5f553148de415980dd90cb92f30b54bcbf7c13f3b209937e332166c228fa021" args="" -->eAS_DISABLED</em>&nbsp;</td><td>
axis is disabled </td></tr>
<tr><td valign="top"><em><a class="anchor" name="b5f553148de415980dd90cb92f30b54b7bb4b393269bf39e9ad91385207e318d"></a><!-- doxytag: member="eAS_LIMITS_REACHED" ref="b5f553148de415980dd90cb92f30b54b7bb4b393269bf39e9ad91385207e318d" args="" -->eAS_LIMITS_REACHED</em>&nbsp;</td><td>
position limits reached and axis stopped </td></tr>
<tr><td valign="top"><em><a class="anchor" name="b5f553148de415980dd90cb92f30b54be8b914c1eb4139fc85c92d82e8c63414"></a><!-- doxytag: member="eAS_DIMENSION" ref="b5f553148de415980dd90cb92f30b54be8b914c1eb4139fc85c92d82e8c63414" args="" -->eAS_DIMENSION</em>&nbsp;</td><td>
Endmarker and Dimension. </td></tr>
</table>
</dl>

</div>
</div><p>
<a class="anchor" name="712b0b80382f1e1e5229ad7bec6cdc4d"></a><!-- doxytag: member="SDH::cSDH::eMotorCurrentMode" ref="712b0b80382f1e1e5229ad7bec6cdc4d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_s_d_h_1_1c_s_d_h.html#712b0b80382f1e1e5229ad7bec6cdc4d">SDH::cSDH::eMotorCurrentMode</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
the motor current can be set specifically for these modes: 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="712b0b80382f1e1e5229ad7bec6cdc4da0a075991ceba063aff574398f8ff05e"></a><!-- doxytag: member="eMCM_MOVE" ref="712b0b80382f1e1e5229ad7bec6cdc4da0a075991ceba063aff574398f8ff05e" args="" -->eMCM_MOVE</em>&nbsp;</td><td>
The motor currents used while "moving" with a <a class="el" href="class_s_d_h_1_1c_s_d_h.html#91ecc6595c68f2c6f00d31ffaea22a60">MoveHand()</a> or <a class="el" href="class_s_d_h_1_1c_s_d_h.html#67baba337dd775a0c8798b7f82738d6d">MoveFinger()</a> command. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="712b0b80382f1e1e5229ad7bec6cdc4d63872c18691513275682b347c68732b5"></a><!-- doxytag: member="eMCM_GRIP" ref="712b0b80382f1e1e5229ad7bec6cdc4d63872c18691513275682b347c68732b5" args="" -->eMCM_GRIP</em>&nbsp;</td><td>
The motor currents used while "gripping" with a <a class="el" href="class_s_d_h_1_1c_s_d_h.html#1af5350393024630009896e5191a5f94">GripHand()</a> command. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="712b0b80382f1e1e5229ad7bec6cdc4d690e9bb2611fe2a597bb2b9443856fe1"></a><!-- doxytag: member="eMCM_HOLD" ref="712b0b80382f1e1e5229ad7bec6cdc4d690e9bb2611fe2a597bb2b9443856fe1" args="" -->eMCM_HOLD</em>&nbsp;</td><td>
The motor currents used after "gripping" with a <a class="el" href="class_s_d_h_1_1c_s_d_h.html#1af5350393024630009896e5191a5f94">GripHand()</a> command (i.e. "holding"). </td></tr>
<tr><td valign="top"><em><a class="anchor" name="712b0b80382f1e1e5229ad7bec6cdc4dd06a5321282cd5a7ab04475059df7f63"></a><!-- doxytag: member="eMCM_DIMENSION" ref="712b0b80382f1e1e5229ad7bec6cdc4dd06a5321282cd5a7ab04475059df7f63" args="" -->eMCM_DIMENSION</em>&nbsp;</td><td>
Endmarker and Dimension. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="712b0b80382f1e1e5229ad7bec6cdc4da0a075991ceba063aff574398f8ff05e"></a><!-- doxytag: member="eMCM_MOVE" ref="712b0b80382f1e1e5229ad7bec6cdc4da0a075991ceba063aff574398f8ff05e" args="" -->eMCM_MOVE</em>&nbsp;</td><td>
The motor currents used while "moving" with a <a class="el" href="class_s_d_h_1_1c_s_d_h.html#91ecc6595c68f2c6f00d31ffaea22a60">MoveHand()</a> or <a class="el" href="class_s_d_h_1_1c_s_d_h.html#67baba337dd775a0c8798b7f82738d6d">MoveFinger()</a> command. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="712b0b80382f1e1e5229ad7bec6cdc4d63872c18691513275682b347c68732b5"></a><!-- doxytag: member="eMCM_GRIP" ref="712b0b80382f1e1e5229ad7bec6cdc4d63872c18691513275682b347c68732b5" args="" -->eMCM_GRIP</em>&nbsp;</td><td>
The motor currents used while "gripping" with a <a class="el" href="class_s_d_h_1_1c_s_d_h.html#1af5350393024630009896e5191a5f94">GripHand()</a> command. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="712b0b80382f1e1e5229ad7bec6cdc4d690e9bb2611fe2a597bb2b9443856fe1"></a><!-- doxytag: member="eMCM_HOLD" ref="712b0b80382f1e1e5229ad7bec6cdc4d690e9bb2611fe2a597bb2b9443856fe1" args="" -->eMCM_HOLD</em>&nbsp;</td><td>
The motor currents used after "gripping" with a <a class="el" href="class_s_d_h_1_1c_s_d_h.html#1af5350393024630009896e5191a5f94">GripHand()</a> command (i.e. "holding"). </td></tr>
<tr><td valign="top"><em><a class="anchor" name="712b0b80382f1e1e5229ad7bec6cdc4dd06a5321282cd5a7ab04475059df7f63"></a><!-- doxytag: member="eMCM_DIMENSION" ref="712b0b80382f1e1e5229ad7bec6cdc4dd06a5321282cd5a7ab04475059df7f63" args="" -->eMCM_DIMENSION</em>&nbsp;</td><td>
Endmarker and Dimension. </td></tr>
</table>
</dl>

</div>
</div><p>
<a class="anchor" name="b5f553148de415980dd90cb92f30b54b"></a><!-- doxytag: member="SDH::cSDH::eAxisState" ref="b5f553148de415980dd90cb92f30b54b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_s_d_h_1_1c_s_d_h.html#b5f553148de415980dd90cb92f30b54b">SDH::cSDH::eAxisState</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The state of an axis (see TPOSCON_STATE in global.h of the SDH firmware). 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="b5f553148de415980dd90cb92f30b54bd966c9e6d1145850dd60e12bdce4f5dc"></a><!-- doxytag: member="eAS_IDLE" ref="b5f553148de415980dd90cb92f30b54bd966c9e6d1145850dd60e12bdce4f5dc" args="" -->eAS_IDLE</em>&nbsp;</td><td>
axis is idle </td></tr>
<tr><td valign="top"><em><a class="anchor" name="b5f553148de415980dd90cb92f30b54bdc62e02ed19a432396a9d4ea968d0676"></a><!-- doxytag: member="eAS_POSITIONING" ref="b5f553148de415980dd90cb92f30b54bdc62e02ed19a432396a9d4ea968d0676" args="" -->eAS_POSITIONING</em>&nbsp;</td><td>
the goal position has not been reached yet </td></tr>
<tr><td valign="top"><em><a class="anchor" name="b5f553148de415980dd90cb92f30b54b52c8e94f5f0f5c7418a24882dbb8ce05"></a><!-- doxytag: member="eAS_SPEED_MODE" ref="b5f553148de415980dd90cb92f30b54b52c8e94f5f0f5c7418a24882dbb8ce05" args="" -->eAS_SPEED_MODE</em>&nbsp;</td><td>
axis is in speed mode </td></tr>
<tr><td valign="top"><em><a class="anchor" name="b5f553148de415980dd90cb92f30b54b09f097ac98da3f3fd1525b05c4d46b0a"></a><!-- doxytag: member="eAS_NOT_INITIALIZED" ref="b5f553148de415980dd90cb92f30b54b09f097ac98da3f3fd1525b05c4d46b0a" args="" -->eAS_NOT_INITIALIZED</em>&nbsp;</td><td>
axis is not initialized or doesn't exist </td></tr>
<tr><td valign="top"><em><a class="anchor" name="b5f553148de415980dd90cb92f30b54b13f7039cb7faa7831ea8507e49f43963"></a><!-- doxytag: member="eAS_CW_BLOCKED" ref="b5f553148de415980dd90cb92f30b54b13f7039cb7faa7831ea8507e49f43963" args="" -->eAS_CW_BLOCKED</em>&nbsp;</td><td>
axis is blocked in counterwise direction </td></tr>
<tr><td valign="top"><em><a class="anchor" name="b5f553148de415980dd90cb92f30b54bdd03e29e1e252c9e64e84450d1c109a0"></a><!-- doxytag: member="eAS_CCW_BLOCKED" ref="b5f553148de415980dd90cb92f30b54bdd03e29e1e252c9e64e84450d1c109a0" args="" -->eAS_CCW_BLOCKED</em>&nbsp;</td><td>
axis is blocked is blocked in against counterwise direction </td></tr>
<tr><td valign="top"><em><a class="anchor" name="b5f553148de415980dd90cb92f30b54bcbf7c13f3b209937e332166c228fa021"></a><!-- doxytag: member="eAS_DISABLED" ref="b5f553148de415980dd90cb92f30b54bcbf7c13f3b209937e332166c228fa021" args="" -->eAS_DISABLED</em>&nbsp;</td><td>
axis is disabled </td></tr>
<tr><td valign="top"><em><a class="anchor" name="b5f553148de415980dd90cb92f30b54b7bb4b393269bf39e9ad91385207e318d"></a><!-- doxytag: member="eAS_LIMITS_REACHED" ref="b5f553148de415980dd90cb92f30b54b7bb4b393269bf39e9ad91385207e318d" args="" -->eAS_LIMITS_REACHED</em>&nbsp;</td><td>
position limits reached and axis stopped </td></tr>
<tr><td valign="top"><em><a class="anchor" name="b5f553148de415980dd90cb92f30b54be8b914c1eb4139fc85c92d82e8c63414"></a><!-- doxytag: member="eAS_DIMENSION" ref="b5f553148de415980dd90cb92f30b54be8b914c1eb4139fc85c92d82e8c63414" args="" -->eAS_DIMENSION</em>&nbsp;</td><td>
Endmarker and Dimension. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="b5f553148de415980dd90cb92f30b54bd966c9e6d1145850dd60e12bdce4f5dc"></a><!-- doxytag: member="eAS_IDLE" ref="b5f553148de415980dd90cb92f30b54bd966c9e6d1145850dd60e12bdce4f5dc" args="" -->eAS_IDLE</em>&nbsp;</td><td>
axis is idle </td></tr>
<tr><td valign="top"><em><a class="anchor" name="b5f553148de415980dd90cb92f30b54bdc62e02ed19a432396a9d4ea968d0676"></a><!-- doxytag: member="eAS_POSITIONING" ref="b5f553148de415980dd90cb92f30b54bdc62e02ed19a432396a9d4ea968d0676" args="" -->eAS_POSITIONING</em>&nbsp;</td><td>
the goal position has not been reached yet </td></tr>
<tr><td valign="top"><em><a class="anchor" name="b5f553148de415980dd90cb92f30b54b52c8e94f5f0f5c7418a24882dbb8ce05"></a><!-- doxytag: member="eAS_SPEED_MODE" ref="b5f553148de415980dd90cb92f30b54b52c8e94f5f0f5c7418a24882dbb8ce05" args="" -->eAS_SPEED_MODE</em>&nbsp;</td><td>
axis is in speed mode </td></tr>
<tr><td valign="top"><em><a class="anchor" name="b5f553148de415980dd90cb92f30b54b09f097ac98da3f3fd1525b05c4d46b0a"></a><!-- doxytag: member="eAS_NOT_INITIALIZED" ref="b5f553148de415980dd90cb92f30b54b09f097ac98da3f3fd1525b05c4d46b0a" args="" -->eAS_NOT_INITIALIZED</em>&nbsp;</td><td>
axis is not initialized or doesn't exist </td></tr>
<tr><td valign="top"><em><a class="anchor" name="b5f553148de415980dd90cb92f30b54b13f7039cb7faa7831ea8507e49f43963"></a><!-- doxytag: member="eAS_CW_BLOCKED" ref="b5f553148de415980dd90cb92f30b54b13f7039cb7faa7831ea8507e49f43963" args="" -->eAS_CW_BLOCKED</em>&nbsp;</td><td>
axis is blocked in counterwise direction </td></tr>
<tr><td valign="top"><em><a class="anchor" name="b5f553148de415980dd90cb92f30b54bdd03e29e1e252c9e64e84450d1c109a0"></a><!-- doxytag: member="eAS_CCW_BLOCKED" ref="b5f553148de415980dd90cb92f30b54bdd03e29e1e252c9e64e84450d1c109a0" args="" -->eAS_CCW_BLOCKED</em>&nbsp;</td><td>
axis is blocked is blocked in against counterwise direction </td></tr>
<tr><td valign="top"><em><a class="anchor" name="b5f553148de415980dd90cb92f30b54bcbf7c13f3b209937e332166c228fa021"></a><!-- doxytag: member="eAS_DISABLED" ref="b5f553148de415980dd90cb92f30b54bcbf7c13f3b209937e332166c228fa021" args="" -->eAS_DISABLED</em>&nbsp;</td><td>
axis is disabled </td></tr>
<tr><td valign="top"><em><a class="anchor" name="b5f553148de415980dd90cb92f30b54b7bb4b393269bf39e9ad91385207e318d"></a><!-- doxytag: member="eAS_LIMITS_REACHED" ref="b5f553148de415980dd90cb92f30b54b7bb4b393269bf39e9ad91385207e318d" args="" -->eAS_LIMITS_REACHED</em>&nbsp;</td><td>
position limits reached and axis stopped </td></tr>
<tr><td valign="top"><em><a class="anchor" name="b5f553148de415980dd90cb92f30b54be8b914c1eb4139fc85c92d82e8c63414"></a><!-- doxytag: member="eAS_DIMENSION" ref="b5f553148de415980dd90cb92f30b54be8b914c1eb4139fc85c92d82e8c63414" args="" -->eAS_DIMENSION</em>&nbsp;</td><td>
Endmarker and Dimension. </td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="e1999e6293f4e503d6d629adcee2e958"></a><!-- doxytag: member="SDH::cSDH::cSDH" ref="e1999e6293f4e503d6d629adcee2e958" args="(bool _use_radians=false, bool _use_fahrenheit=false, int _debug_level=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cSDH::cSDH           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>_use_radians</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>_use_fahrenheit</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>_debug_level</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor of <a class="el" href="class_s_d_h_1_1c_s_d_h.html" title="SDH::cSDH is the end user interface class to control a SDH (SCHUNK Dexterous Hand)...">cSDH</a> class. 
<p>
Creates an new object of type <a class="el" href="class_s_d_h_1_1c_s_d_h.html" title="SDH::cSDH is the end user interface class to control a SDH (SCHUNK Dexterous Hand)...">cSDH</a>. One such object is needed for each SDH that you want to control. The constructor initializes internal data structures. A connection the SDH is <b>not</b> yet established, see <a class="el" href="class_s_d_h_1_1c_s_d_h.html#9bc5161da5f49ebe7a0345c05865a84d">OpenRS232()</a> on how to do that.<p>
After an object is created the user can adjust the unit systems used to set/report parameters to/from SDH. This is shown in the example code below. The default units used (if not overwritten by constructor parameters) are:<ul>
<li><code>degrees</code> [] for (axis) angles</li><li><code>degrees</code> <code>per</code> <code>second</code> [/s] for (axis) angular velocities</li><li><code>seconds</code> [s] for times</li><li><code>degrees</code> <code>celsius</code> [C] for temperatures</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_use_radians</em>&nbsp;</td><td>: Flag, if true then use radians and radians/second to set/report (axis) angles and angular velocities instead of default degrees and degrees/s. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_use_fahrenheit</em>&nbsp;</td><td>: Flag, if true then use degrees fahrenheit to report temperatures instead of default degrees celsius. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_debug_level</em>&nbsp;</td><td>: The level of debug messages to print<ul>
<li>0: (default) no messages</li><li>1: messages of this <a class="el" href="class_s_d_h_1_1c_s_d_h.html" title="SDH::cSDH is the end user interface class to control a SDH (SCHUNK Dexterous Hand)...">cSDH</a> instance</li><li>2: like 1 plus messages of the inner <a class="el" href="class_s_d_h_1_1c_s_d_h_serial.html" title="The class to communicate with a SDH via RS232.">cSDHSerial</a> instance</li></ul>
</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Examples:</b></dt><dd></dd></dl>
Common use: <div class="fragment"><pre class="fragment">         <span class="comment">// Include the cSDH interface</span>
<span class="preprocessor">         #include &lt;sdh.h&gt;</span>

         <span class="comment">// Create a cSDH object 'hand'.</span>
         <a class="code" href="class_s_d_h_1_1c_s_d_h.html#e1999e6293f4e503d6d629adcee2e958" title="Constructor of cSDH class.">cSDH</a> hand();
</pre></div><p>
The mentioned change of a unit system can be done like this: <div class="fragment"><pre class="fragment">         <span class="comment">// Assuming 'hand' is a cSDH object ...</span>

         <span class="comment">// override default unit converter for (axis) angles:</span>
         hand.uc_angle = &amp;<a class="code" href="class_s_d_h_1_1c_s_d_h.html#d471654c3963c7fa871061a5dde8f609" title="Converter for angles: external unit = radians.">cSDH::uc_angle_radians</a>;

         <span class="comment">// override default unit converter for (axis) angular velocities:</span>
         hand.uc_angular_velocity = &amp;<a class="code" href="class_s_d_h_1_1c_s_d_h.html#a4de0ead7be9184d43f2d9a4dbdeb534" title="Converter for angular velocieties: external unit = radians/second.">cSDH::uc_angular_velocity_radians_per_second</a>;

         <span class="comment">// override default unit converter for (axis) angular accelerations:</span>
         hand.uc_angular_acceleration = &amp;<a class="code" href="class_s_d_h_1_1c_s_d_h.html#c512eedd92c67e9322f0157b7656c204" title="Converter for angular velocieties: external unit = radians/second.">cSDH::uc_angular_acceleration_radians_per_second_squared</a>;

         <span class="comment">// instead of the last 3 calls the following shortcut could be used:</span>
         hand.UseRadians();

         <span class="comment">// override default unit converter for times:</span>
         hand.uc_time  = &amp;<a class="code" href="class_s_d_h_1_1c_s_d_h.html#4b647e0946acd200b019b29169951ab4" title="Converter for times: external unit = milliseconds.">cSDH::uc_time_milliseconds</a>;

         <span class="comment">// override default unit converter for temperatures:</span>
         hand.uc_temperature = &amp;<a class="code" href="class_s_d_h_1_1c_s_d_h.html#91a8319e68109aeec7f97008572f7177" title="Converter for temperatures: external unit = degrees fahrenheit.">cSDH::uc_temperature_fahrenheit</a>;

         <span class="comment">// override default unit converter for positions:</span>
         hand.uc_position = &amp;<a class="code" href="class_s_d_h_1_1c_s_d_h.html#9c39c381b642d85d059c98b593af7178" title="Converter for position: external unit = meter.">cSDH::uc_position_meter</a>;
</pre></div><p>
For convenience the most common settings can be specified as bool parameters for the constructor, like in:<p>
<div class="fragment"><pre class="fragment">         <span class="comment">// Include the cSDH interface</span>
<span class="preprocessor">         #include &lt;sdh.h&gt;</span>

         <span class="comment">// Create a cSDH object 'hand' that uses</span>
         <span class="comment">// - the non default radians and radians/s units,</span>
         <span class="comment">// - the default temperature in degrees celsius,</span>
         <span class="comment">// - A debug level of 2</span>
         <a class="code" href="class_s_d_h_1_1c_s_d_h.html#e1999e6293f4e503d6d629adcee2e958" title="Constructor of cSDH class.">cSDH</a> hand( <span class="keyword">true</span>, <span class="keyword">false</span>, 2 );
</pre></div><p>
<hr>
 
<p>
unit convert for times: default = uc_time_seconds<p>
unit convert for temperatures: default = <a class="el" href="class_s_d_h_1_1c_s_d_h.html#3a16fe0f08ebb82d79edf1a7fa502c2f" title="Default converter for temparatures (internal unit == external unit): degrees celsius...">uc_temperature_celsius</a><p>
unit converter for motor curent: default = <a class="el" href="class_s_d_h_1_1c_s_d_h.html#d81dfd6cad39b84734a1bc39e48e2fdd" title="Default converter for motor current (internal unit == external unit): Ampere.">uc_motor_current_ampere</a><p>
unit converter for position: default = <a class="el" href="class_s_d_h_1_1c_s_d_h.html#2a5abd24424bf5a92c3b74819d26cdc5" title="Default converter for position (internal unit == external unit): millimeter.">uc_position_millimeter</a><p>
The number of axis per finger (for finger 1 this includes the "virtual" base axis)<p>
The number of virtual axes<p>
Mapping of finger index to number of real axes of fingers:<p>
Mapping of finger index, finger axis index to axis index:<p>
Maximum allowed grip velocity (in internal units (degrees/second)) 
</div>
</div><p>
<a class="anchor" name="a7b86bd5218e79355c05c9257a504d1d"></a><!-- doxytag: member="SDH::cSDH::~cSDH" ref="a7b86bd5218e79355c05c9257a504d1d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cSDH::~cSDH           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Virtual destructor to make compiler happy<p>
If the connection to the SDH hardware/firmware is still open then the connection is closed, which will stop the axis controllers (and thus prevent overheating). 
</div>
</div><p>
<a class="anchor" name="e12663e7fd837a5709790f708047fa59"></a><!-- doxytag: member="SDH::cSDH::cSDH" ref="e12663e7fd837a5709790f708047fa59" args="(bool _use_radians=false, bool _use_fahrenheit=false, int _debug_level=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SDH::cSDH::cSDH           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>_use_radians</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>_use_fahrenheit</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>_debug_level</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor of <a class="el" href="class_s_d_h_1_1c_s_d_h.html" title="SDH::cSDH is the end user interface class to control a SDH (SCHUNK Dexterous Hand)...">cSDH</a> class. 
<p>
Creates an new object of type <a class="el" href="class_s_d_h_1_1c_s_d_h.html" title="SDH::cSDH is the end user interface class to control a SDH (SCHUNK Dexterous Hand)...">cSDH</a>. One such object is needed for each SDH that you want to control. The constructor initializes internal data structures. A connection the SDH is <b>not</b> yet established, see <a class="el" href="class_s_d_h_1_1c_s_d_h.html#9bc5161da5f49ebe7a0345c05865a84d">OpenRS232()</a> on how to do that.<p>
After an object is created the user can adjust the unit systems used to set/report parameters to/from SDH. This is shown in the example code below. The default units used (if not overwritten by constructor parameters) are:<ul>
<li><code>degrees</code> [] for (axis) angles</li><li><code>degrees</code> <code>per</code> <code>second</code> [/s] for (axis) angular velocities</li><li><code>seconds</code> [s] for times</li><li><code>degrees</code> <code>celsius</code> [C] for temperatures</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_use_radians</em>&nbsp;</td><td>: Flag, if true then use radians and radians/second to set/report (axis) angles and angular velocities instead of default degrees and degrees/s. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_use_fahrenheit</em>&nbsp;</td><td>: Flag, if true then use degrees fahrenheit to report temperatures instead of default degrees celsius. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_debug_level</em>&nbsp;</td><td>: The level of debug messages to print<ul>
<li>0: (default) no messages</li><li>1: messages of this <a class="el" href="class_s_d_h_1_1c_s_d_h.html" title="SDH::cSDH is the end user interface class to control a SDH (SCHUNK Dexterous Hand)...">cSDH</a> instance</li><li>2: like 1 plus messages of the inner <a class="el" href="class_s_d_h_1_1c_s_d_h_serial.html" title="The class to communicate with a SDH via RS232.">cSDHSerial</a> instance</li></ul>
</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Examples:</b></dt><dd></dd></dl>
Common use: <div class="fragment"><pre class="fragment">         <span class="comment">// Include the cSDH interface</span>
<span class="preprocessor">         #include &lt;sdh.h&gt;</span>

         <span class="comment">// Create a cSDH object 'hand'.</span>
         <a class="code" href="class_s_d_h_1_1c_s_d_h.html#e1999e6293f4e503d6d629adcee2e958" title="Constructor of cSDH class.">cSDH</a> hand();
</pre></div><p>
The mentioned change of a unit system can be done like this: <div class="fragment"><pre class="fragment">         <span class="comment">// Assuming 'hand' is a cSDH object ...</span>

         <span class="comment">// override default unit converter for (axis) angles:</span>
         hand.uc_angle = &amp;<a class="code" href="class_s_d_h_1_1c_s_d_h.html#d471654c3963c7fa871061a5dde8f609" title="Converter for angles: external unit = radians.">cSDH::uc_angle_radians</a>;

         <span class="comment">// override default unit converter for (axis) angular velocities:</span>
         hand.uc_angular_velocity = &amp;<a class="code" href="class_s_d_h_1_1c_s_d_h.html#a4de0ead7be9184d43f2d9a4dbdeb534" title="Converter for angular velocieties: external unit = radians/second.">cSDH::uc_angular_velocity_radians_per_second</a>;

         <span class="comment">// override default unit converter for (axis) angular accelerations:</span>
         hand.uc_angular_acceleration = &amp;<a class="code" href="class_s_d_h_1_1c_s_d_h.html#c512eedd92c67e9322f0157b7656c204" title="Converter for angular velocieties: external unit = radians/second.">cSDH::uc_angular_acceleration_radians_per_second_squared</a>;

         <span class="comment">// instead of the last 3 calls the following shortcut could be used:</span>
         hand.UseRadians();

         <span class="comment">// override default unit converter for times:</span>
         hand.uc_time  = &amp;<a class="code" href="class_s_d_h_1_1c_s_d_h.html#4b647e0946acd200b019b29169951ab4" title="Converter for times: external unit = milliseconds.">cSDH::uc_time_milliseconds</a>;

         <span class="comment">// override default unit converter for temperatures:</span>
         hand.uc_temperature = &amp;<a class="code" href="class_s_d_h_1_1c_s_d_h.html#91a8319e68109aeec7f97008572f7177" title="Converter for temperatures: external unit = degrees fahrenheit.">cSDH::uc_temperature_fahrenheit</a>;

         <span class="comment">// override default unit converter for positions:</span>
         hand.uc_position = &amp;<a class="code" href="class_s_d_h_1_1c_s_d_h.html#9c39c381b642d85d059c98b593af7178" title="Converter for position: external unit = meter.">cSDH::uc_position_meter</a>;
</pre></div><p>
For convenience the most common settings can be specified as bool parameters for the constructor, like in:<p>
<div class="fragment"><pre class="fragment">         <span class="comment">// Include the cSDH interface</span>
<span class="preprocessor">         #include &lt;sdh.h&gt;</span>

         <span class="comment">// Create a cSDH object 'hand' that uses</span>
         <span class="comment">// - the non default radians and radians/s units,</span>
         <span class="comment">// - the default temperature in degrees celsius,</span>
         <span class="comment">// - A debug level of 2</span>
         <a class="code" href="class_s_d_h_1_1c_s_d_h.html#e1999e6293f4e503d6d629adcee2e958" title="Constructor of cSDH class.">cSDH</a> hand( <span class="keyword">true</span>, <span class="keyword">false</span>, 2 );
</pre></div><p>
<hr>
 
</div>
</div><p>
<a class="anchor" name="59f2c42d8c364da341a85d3441f8620c"></a><!-- doxytag: member="SDH::cSDH::~cSDH" ref="59f2c42d8c364da341a85d3441f8620c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual SDH::cSDH::~cSDH           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Virtual destructor to make compiler happy<p>
If the connection to the SDH hardware/firmware is still open then the connection is closed, which will stop the axis controllers (and thus prevent overheating). 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="5edad78d5abca94b036a582c053556b0"></a><!-- doxytag: member="SDH::cSDH::SetDebugOutput" ref="5edad78d5abca94b036a582c053556b0" args="(std::ostream *debuglog)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SDH::cSDH::SetDebugOutput           </td>
          <td>(</td>
          <td class="paramtype">std::ostream *&nbsp;</td>
          <td class="paramname"> <em>debuglog</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
change the stream to use for debug messages 
<p>

<p>Reimplemented from <a class="el" href="class_s_d_h_1_1c_s_d_h_base.html#3507208d616c6218423e2df0f7d75ce3">SDH::cSDHBase</a>.</p>

</div>
</div><p>
<a class="anchor" name="a8eced47a1f0af0be26a1da3766f0f90"></a><!-- doxytag: member="SDH::cSDH::SetAxisValueVector" ref="a8eced47a1f0af0be26a1da3766f0f90" args="(std::vector&lt; int &gt; const &amp;axes, std::vector&lt; double &gt; const &amp;values, pSetFunction ll_set, pGetFunction ll_get, cUnitConverter const *uc, std::vector&lt; double &gt; const &amp;min_values, std::vector&lt; double &gt; const &amp;max_values, char const *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cSDH::SetAxisValueVector           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>axes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_s_d_h.html#2125769495fc86ea25e2fc2181887723">pSetFunction</a>&nbsp;</td>
          <td class="paramname"> <em>ll_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_s_d_h.html#cbae245111c9c3618d335156ba2e04f7">pGetFunction</a>&nbsp;</td>
          <td class="paramname"> <em>ll_get</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a> const *&nbsp;</td>
          <td class="paramname"> <em>uc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>min_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>max_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Generic set function: set some given axes to given values<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axes</em>&nbsp;</td><td>- a vector of axis indices </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>values</em>&nbsp;</td><td>- a vector of values </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ll_set</em>&nbsp;</td><td>- a pointer to the low level set function to use </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ll_get</em>&nbsp;</td><td>- a pointer to the low level get function to use (for those axes where the given value is NaN) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uc</em>&nbsp;</td><td>- a pointer to the unit converter object to use before sending values to <em>ll_set</em> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>min_values</em>&nbsp;</td><td>- a vector with the minimum allowed values </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max_values</em>&nbsp;</td><td>- a vector with the maximum allowed values </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>- a string with the name of the values (for constructing error message)</td></tr>
  </table>
</dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd><ul>
<li>The length of the <em>axis</em> and <em>values</em> vector must match.</li><li>The indices can be given in any order, but the order of the elements of <em>axes</em> and <em>values</em> must match too. I.e. <code>values</code>[i] will be applied to axis <code>axes</code>[i] (not axis <code>i</code>)</li><li>The indices are checked if they are valid axis indices.</li><li>The values are checked if they are in the allowed range [<em>min_values</em> .. <em>f_max_values</em>], i.e. it is checked that <code>value</code>[i], converted to the internal unit system by <em>uc-&gt;ToInternal()</em>, is in [<em>min_values</em>[axes[i]] .. <em>max_values</em>[axes[i]]].</li><li>If <b>any</b> index or value is invalid then <b>none</b> of the specified values is sent to the SDH, instead a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown. </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="ff0b88d27ef55ea733912108887790d2"></a><!-- doxytag: member="SDH::cSDH::GetAxisValueVector" ref="ff0b88d27ef55ea733912108887790d2" args="(std::vector&lt; int &gt; const &amp;axes, pGetFunction ll_get, cUnitConverter const *uc, char const *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; cSDH::GetAxisValueVector           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>axes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_s_d_h.html#cbae245111c9c3618d335156ba2e04f7">pGetFunction</a>&nbsp;</td>
          <td class="paramname"> <em>ll_get</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a> const *&nbsp;</td>
          <td class="paramname"> <em>uc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Generic get function: get some given axes values<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axes</em>&nbsp;</td><td>- a vector of axis indices </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ll_get</em>&nbsp;</td><td>- a pointer to the low level get function to use </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uc</em>&nbsp;</td><td>- a pointer to the unit converter object to apply before returning values </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>- a string with the name of the values (for constructing error message)</td></tr>
  </table>
</dl>
<ul>
<li>The indices in <em>axes</em> are checked if they are valid axis indices.</li><li>If <b>any</b> axis index is invalid then a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>A vector of the addressed values for the selected axes.</li><li>The values are converted to external unit system using the <em>uc</em> unit converter object.</li><li>The order of the elements of the <em>axes</em> vector and the returned values vector <em>rv</em> matches. I.e. <code>rv</code>[i] will be the value of axis <code>axes</code>[i] (not axis <code>i</code>). </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="e7990e0566bab2192ae725f9aecddf04"></a><!-- doxytag: member="SDH::cSDH::ToIndexVector" ref="e7990e0566bab2192ae725f9aecddf04" args="(int index, std::vector&lt; int &gt; &amp;all_replacement, int maxindex, char const *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; cSDH::ToIndexVector           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>all_replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>maxindex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Internal helper function: return a vector of checked indices according to index.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>- The index to vectorize or <a class="el" href="class_s_d_h_1_1c_s_d_h_base.html#ab61ed07c53bf24bc87ff5103e74f45a8e09b2cc8bc776a705cd2665fc555881" title="A meta-value that means &quot;access all possible values&quot;.">All</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>all_replacement</em>&nbsp;</td><td>- a vector to return if <em>index</em> is <a class="el" href="class_s_d_h_1_1c_s_d_h_base.html#ab61ed07c53bf24bc87ff5103e74f45a8e09b2cc8bc776a705cd2665fc555881" title="A meta-value that means &quot;access all possible values&quot;.">All</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxindex</em>&nbsp;</td><td>- the <em>index</em> is checked if in [0.. maxindex[ (i.e. not including <em>maxindex</em>) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>- A name for the things index, used to report out of bounds errors</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>If <em>index</em> is <a class="el" href="class_s_d_h_1_1c_s_d_h_base.html#ab61ed07c53bf24bc87ff5103e74f45a8e09b2cc8bc776a705cd2665fc555881" title="A meta-value that means &quot;access all possible values&quot;.">All</a> then <em>all_replacement</em> is returned.</li><li>If <em>index</em> is a single number &gt;= 0 then it is checked if in [0.. maxindex[ and a vector of length 1 is returned containing only <em>index</em>.</li><li>In case <em>index</em> exceeds <em>maxindex</em> a (cSDHErrorInvalidParameter*) exception is thrown. </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="68299d95c3df050b727a63f839adc0ec"></a><!-- doxytag: member="SDH::cSDH::GetMotorCurrentModeFunction" ref="68299d95c3df050b727a63f839adc0ec" args="(eMotorCurrentMode mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_s_d_h.html#2125769495fc86ea25e2fc2181887723">pSetFunction</a> cSDH::GetMotorCurrentModeFunction           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#712b0b80382f1e1e5229ad7bec6cdc4d">eMotorCurrentMode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Internal helper function: return the get/set function of the comm_interface object that is responsible for setting/getting motor currents in <em>mode</em>. 
</div>
</div><p>
<a class="anchor" name="07f00798e4d660d1f24e6724ff899b38"></a><!-- doxytag: member="SDH::cSDH::_GetFingerXYZ" ref="07f00798e4d660d1f24e6724ff899b38" args="(int fi, std::vector&lt; double &gt; r_angles)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; cSDH::_GetFingerXYZ           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>fi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;&nbsp;</td>
          <td class="paramname"> <em>r_angles</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
return cartesian [x,y,z] position in mm of fingertip for finger fi at angles r_angles (rad) 
</div>
</div><p>
<a class="anchor" name="816313af63165f45b31bada0e7986648"></a><!-- doxytag: member="SDH::cSDH::IsVirtualAxis" ref="816313af63165f45b31bada0e7986648" args="(int iAxis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cSDH::IsVirtualAxis           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iAxis</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return <code>true</code> if index <em>iAxis</em> refers to a virtual axis. 
<p>

</div>
</div><p>
<a class="anchor" name="5319f1ad161fb0b671106948c8ffe515"></a><!-- doxytag: member="SDH::cSDH::UseRadians" ref="5319f1ad161fb0b671106948c8ffe515" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cSDH::UseRadians           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Shortcut to set the unit system to radians.<p>
After calling this axis angles are set/reported in radians and angular velocities are set/reported in radians/second<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">         <span class="comment">// Assuming 'hand' is a cSDH object ...</span>

         <span class="comment">// make hand object use radians and radians/second for angles and angular velocities</span>
         hand.UseRadians();
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="ea0dd8a17e872ee94facea0dbadd6895"></a><!-- doxytag: member="SDH::cSDH::UseDegrees" ref="ea0dd8a17e872ee94facea0dbadd6895" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cSDH::UseDegrees           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Shortcut to set the unit system to degrees.<p>
After calling this (axis) angles are set/reported in degrees and angular velocities are set/reported in degrees/second<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">         <span class="comment">// Assuming 'hand' is a cSDH object ...</span>

         <span class="comment">// make hand object use degrees and degrees/second for angles and angular velocities</span>
         hand.UseDegrees();
         <span class="comment">// as degrees, degrees/second are the default this is needed only if the</span>
         <span class="comment">// unit system was changed before</span>
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="8fbc15a1e8ecc1c4ba3c443360a07e9d"></a><!-- doxytag: member="SDH::cSDH::GetFingerNumberOfAxes" ref="8fbc15a1e8ecc1c4ba3c443360a07e9d" args="(int iFinger)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cSDH::GetFingerNumberOfAxes           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iFinger</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the number of real axes of finger with index <em>iFinger</em>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iFinger</em>&nbsp;</td><td>- index of finger in range [0..NUMBER_OF_FINGERS-1]</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>Number of real axes of finger with index <em>iFinger</em> </li><li>If <em>iFinger</em> is invalid a (cSDHErrorInvalidParameter*) exception is thrown.</li></ul>
</dd></dl>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">         <span class="comment">// Assuming 'hand' is a cSDH object ...</span>

         cout &lt;&lt; <span class="stringliteral">"The finger 0 has "</span> &lt;&lt; hand.GetFingerNumberOfAxes( 0 ) &lt;&lt; <span class="stringliteral">" real axes\n"</span>;
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="c7e8f246a6c6c0502ceda09880831be0"></a><!-- doxytag: member="SDH::cSDH::GetFingerAxisIndex" ref="c7e8f246a6c6c0502ceda09880831be0" args="(int iFinger, int iFingerAxis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cSDH::GetFingerAxisIndex           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iFinger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iFingerAxis</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return axis index of <em>iFingerAxis</em> axis of finger with index iFinger<p>
For <em>iFinger=2</em>, iFingerAxis=0 this will return the index of the virtual base axis of the finger<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iFinger</em>&nbsp;</td><td>- index of finger in range [0..NUMBER_OF_FINGERS-1] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iFingerAxis</em>&nbsp;</td><td>- index of finger axis in range [0..NUMBER_OF_AXES_PER_FINGER-1]</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>Axis index of <em>iFingerAxis-th</em> axis of finger with index <em>iFinger</em> </li><li>If <em>iFinger</em> or <em>iFingerAxis</em> is invalid a (cSDHErrorInvalidParameter*) exception is thrown.</li></ul>
</dd></dl>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">         <span class="comment">// Assuming 'hand' is a cSDH object ...</span>

         cout &lt;&lt; <span class="stringliteral">"The 1st axis of finger 2 has real axis index "</span> &lt;&lt; hand.GetFingerNumberOfAxes( 2, 0 ) &lt;&lt; <span class="stringliteral">"\n"</span>;
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="6b3a201726288b58f7515995f22ddda3"></a><!-- doxytag: member="SDH::cSDH::GetLibraryRelease" ref="6b3a201726288b58f7515995f22ddda3" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char const * cSDH::GetLibraryRelease           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the release name of the library (not the firmware of the SDH) as string.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">         <span class="comment">// static member functon, so no cSDH object is needed for access:</span>

         cout &lt;&lt; <span class="stringliteral">"The SDHLibrary reports release name "</span> &lt;&lt; cSDH::GetReleaseLibrary() &lt;&lt; <span class="stringliteral">"\n"</span>;
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="4d3480853847207adbdba2e20a87ccf1"></a><!-- doxytag: member="SDH::cSDH::GetLibraryName" ref="4d3480853847207adbdba2e20a87ccf1" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char const * cSDH::GetLibraryName           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the name of the library as string.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">         <span class="comment">// static member functon, so no cSDH object is needed for access:</span>

         cout &lt;&lt; <span class="stringliteral">"The SDHLibrary reports name "</span> &lt;&lt; <a class="code" href="class_s_d_h_1_1c_s_d_h.html#4d3480853847207adbdba2e20a87ccf1">cSDH::GetLibraryName</a>() &lt;&lt; <span class="stringliteral">"\n"</span>;
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="d5ebbb82415f064945ec7476bbfe836c"></a><!-- doxytag: member="SDH::cSDH::GetFirmwareRelease" ref="d5ebbb82415f064945ec7476bbfe836c" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char const * cSDH::GetFirmwareRelease           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the release name of the firmware of the SDH (not the library) as string.<p>
This will throw a (cSDHErrorCommunication*) exception if the connection to the SDH is not yet opened.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">         <span class="comment">// Assuming 'hand' is a cSDH object ...</span>

         cout &lt;&lt; <span class="stringliteral">"The SDH firmware reports release "</span> &lt;&lt; hand.GetFirmwareRelease() &lt;&lt; <span class="stringliteral">"\n"</span>;
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="bb2c373d78c30ff8cd5dcb8b3c5fad69"></a><!-- doxytag: member="SDH::cSDH::GetInfo" ref="bb2c373d78c30ff8cd5dcb8b3c5fad69" args="(char const *what)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char const * cSDH::GetInfo           </td>
          <td>(</td>
          <td class="paramtype">char const *&nbsp;</td>
          <td class="paramname"> <em>what</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return info according to <em>what</em> # # The following values are valid for <em>what:</em> # - "date-library" : date of the SDHLibrary-python release # - "release-library" : release name of the sdh.py python module # - "release-firmware" : release name of the SDH firmware (requires # an opened communication to the SDH) # - "date-firmware" : date of the SDH firmware (requires # an opened communication to the SDH) # - "release-soc" : release name of the SDH SoC (requires # an opened communication to the SDH) # - "date-soc" : date of the SDH SoC (requires # an opened communication to the SDH) # - "id-sdh" : ID of SDH # - "sn-sdh" : Serial number of SDH # # <dl class="user" compact><dt><b>Examples:</b></dt><dd># <div class="fragment"><pre class="fragment"><span class="preprocessor">    #    # Assuming 'hand' is a sdh.cSDH object ...</span>
<span class="preprocessor"></span><span class="preprocessor">    #</span>
<span class="preprocessor"></span><span class="preprocessor">    #    print "The SDH firmware reports release %s" % ( hand.GetInfo( "release-firmware" ) )</span>
<span class="preprocessor"></span><span class="preprocessor">    #</span>
<span class="preprocessor">    #  </span>
</pre></div> # # <hr>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="448d044af20e6a1d2ffe674ebd0ea1e7"></a><!-- doxytag: member="SDH::cSDH::GetTemperature" ref="448d044af20e6a1d2ffe674ebd0ea1e7" args="(std::vector&lt; int &gt; const &amp;sensors)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; cSDH::GetTemperature           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>sensors</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return temperature(s) measured within the SDH.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sensors</em>&nbsp;</td><td>- A vector of indices of temperature sensors to access.<ul>
<li>index 0 is sensor near motor of axis 0 (root)</li><li>index 1 is sensor near motor of axis 1 (proximal finger 1)</li><li>index 2 is sensor near motor of axis 2 (distal finger 1)</li><li>index 3 is sensor near motor of axis 3 (proximal finger 2)</li><li>index 4 is sensor near motor of axis 4 (distal finger 2)</li><li>index 5 is sensor near motor of axis 5 (proximal finger 3)</li><li>index 6 is sensor near motor of axis 6 (distal finger 3)</li><li>index 7 is FPGA temperature (controller chip)</li><li>index 8 is PCB temperature (Printed Circuit Board)</li></ul>
</td></tr>
  </table>
</dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd><ul>
<li>The indices in <em>sensors</em> are checked if they are valid sensor indices.</li><li>If <b>any</b> sensor index is invalid then a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
</dd></dl>
To access a single temperature sensor use <a class="el" href="class_s_d_h_1_1c_s_d_h.html#ac95911b4547325bf2f0af1a0af9e0e9">GetTemperature(int)</a>, see there.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The temperatures of the selected sensors are returned as std::vector&lt;double&gt; in the configured temperature unit system <a class="el" href="class_s_d_h_1_1c_s_d_h.html#844b1311f5be6eb5474157d9c24e7a5e" title="unit convert for temperatures: default = SDH::cSDH::uc_temperature_celsius">uc_temperature</a>.</dd></dl>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming 'hand' is a cSDH object ...</span>

          <span class="comment">// Get measured values of all sensors</span>
          std::vector&lt;double&gt; temps = hand.GetTemperature( hand.all_temperature_sensors );
          <span class="comment">// Now temps is something like { 38.500,37.250,35.750,37.250,33.500,36.500,32.250,59.625,52.500 }</span>

          <span class="comment">// Get controller temperature only:</span>
          <span class="keywordtype">double</span> temp_controller = hand.GetTemperature( 0 );
          <span class="comment">// Now temp_controller is something like 40.5</span>

          <span class="comment">// If we - for some obscure islandish reason - would want</span>
          <span class="comment">// temperatures reported in degrees fahrenheit, the unit</span>
          <span class="comment">// converter can be changed:</span>
          hand.uc_temperature = &amp;<a class="code" href="class_s_d_h_1_1c_s_d_h.html#91a8319e68109aeec7f97008572f7177" title="Converter for temperatures: external unit = degrees fahrenheit.">cSDH::uc_temperature_fahrenheit</a>;

          <span class="comment">// Get all temperaturs again:</span>
          temps = hand.GetTemperature( hand.all_temperature_sensors );
          <span class="comment">// Now temps is something like {100.0, 96.8, 92.3, 97.7, 91.8, 96.8, 90.1,  137.5,  125.2}</span>
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="ac95911b4547325bf2f0af1a0af9e0e9"></a><!-- doxytag: member="SDH::cSDH::GetTemperature" ref="ac95911b4547325bf2f0af1a0af9e0e9" args="(int iSensor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cSDH::GetTemperature           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iSensor</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#448d044af20e6a1d2ffe674ebd0ea1e7">GetTemperature(std::vector&lt;int&gt;const&amp;)</a>, just for one sensor <em>iSensor</em> and returning a single temperature as double. 
</div>
</div><p>
<a class="anchor" name="9bc5161da5f49ebe7a0345c05865a84d"></a><!-- doxytag: member="SDH::cSDH::OpenRS232" ref="9bc5161da5f49ebe7a0345c05865a84d" args="(int _port=0, unsigned long _baudrate=115200, double _timeout=-1, char const *_device_format_string=&quot;/dev/ttyS%d&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cSDH::OpenRS232           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>_port</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>_baudrate</em> = <code>115200</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>_timeout</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&nbsp;</td>
          <td class="paramname"> <em>_device_format_string</em> = <code>&quot;/dev/ttyS%<a class="el" href="class_s_d_h_1_1c_s_d_h.html#87537330abbd2528f9dccaa105e427f6">d</a>&quot;</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Open connection to SDH via RS232.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_port</em>&nbsp;</td><td>: The number of the serial port to use. The default value port=0 refers to 'COM1' in Windows and to the corresponding '/dev/ttyS0' in Linux. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_baudrate,:</em>&nbsp;</td><td>the baudrate in bit/s, the default is 115200 which happens to be the default for the SDH too </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_timeout</em>&nbsp;</td><td>: The timeout to use:<ul>
<li>-1 : wait forever</li><li>T : wait for T seconds </li></ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_device_format_string</em>&nbsp;</td><td>: a format string (C string) for generating the device name, like "/dev/ttyS%d" (default) or "/dev/ttyUSB%d". Must contain a d where the port number should be inserted. This char array is duplicated on construction When compiled with VCC (MS-Visual C++) then this is not used. </td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">         <span class="comment">// Assuming 'hand' is a cSDH object ...</span>

         <span class="comment">// Open connection to SDH via default port:</span>
         hand.OpenRS232();

         <span class="comment">// Use a different port 2 == COM3 == /dev/ttyS2 for a second hand "hand2":</span>
         <a class="code" href="class_s_d_h_1_1c_s_d_h.html#e1999e6293f4e503d6d629adcee2e958" title="Constructor of cSDH class.">cSDH</a> hand2();
         hand2.OpenRS232( 2 );

         <span class="comment">// Linux only: Use a different USB to RS232 device on port 3 /dev/ttyUSB3 for a third hand "hand3":</span>
         <a class="code" href="class_s_d_h_1_1c_s_d_h.html#e1999e6293f4e503d6d629adcee2e958" title="Constructor of cSDH class.">cSDH</a> hand3();
         hand2.OpenRS232( 3, 115200, -1, <span class="stringliteral">"/dev/ttyUSB%d"</span> );
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="a850c6f73b8fd06a37851eda019a6ec2"></a><!-- doxytag: member="SDH::cSDH::OpenCAN_ESD" ref="a850c6f73b8fd06a37851eda019a6ec2" args="(int _net=0, unsigned long _baudrate=1000000, double _timeout=0.0, int32_t _id_read=43, int32_t _id_write=42)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cSDH::OpenCAN_ESD           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>_net</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>_baudrate</em> = <code>1000000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>_timeout</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>_id_read</em> = <code>43</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>_id_write</em> = <code>42</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Open connection to SDH via CAN using an ESD CAN card. If the library was compiled without ESD CAN support then this will just throw an exception. See setting for WITH_ESD_CAN in the top level makefile.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_net</em>&nbsp;</td><td>: The ESD CAN net number of the CAN port to use. (default: 0) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_baudrate</em>&nbsp;</td><td>: the CAN baudrate in bit/s. Only some bitrates are valid: (1000000 (default),800000,500000,250000,125000,100000,50000,20000,10000) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_timeout</em>&nbsp;</td><td>: The timeout to use:<ul>
<li>&lt;= 0 : wait forever (default)</li><li>T : wait for T seconds </li></ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_id_read</em>&nbsp;</td><td>- the CAN ID to use for reading (The SDH sends data on this ID, default=43=0x02b) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_id_write</em>&nbsp;</td><td>- the CAN ID to use for writing (The SDH receives data on this ID, default=42=0x02a)</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">         <span class="comment">// Assuming 'hand' is a cSDH object ...</span>

         <span class="comment">// use default parameters for net, baudrate, timeout and IDs</span>
         hand.OpenCAN_ESD( );

         <span class="comment">// use non default settings:</span>
         <span class="comment">// net=1, baudrate=500000, timeout=1.0, id_read=0x143, id_write=0x142</span>
         hand.OpenCAN_ESD( 1, 500000, 1.0, 0x143, 0x142 );
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="442d66ae38024e6ce112a9de56c0426e"></a><!-- doxytag: member="SDH::cSDH::OpenCAN_ESD" ref="442d66ae38024e6ce112a9de56c0426e" args="(NTCAN_HANDLE _ntcan_handle, double _timeout=0.0, int32_t _id_read=43, int32_t _id_write=42)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cSDH::OpenCAN_ESD           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_s_d_h.html#d644157c3633dee69e0523c30272bc43">NTCAN_HANDLE</a>&nbsp;</td>
          <td class="paramname"> <em>_ntcan_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>_timeout</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>_id_read</em> = <code>43</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>_id_write</em> = <code>42</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Open connection to SDH via CAN using an ESD CAN card using an existing handle. If the library was compiled without ESD CAN support then this will just throw an exception. See setting for WITH_ESD_CAN in the top level makefile.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_ntcan_handle</em>&nbsp;</td><td>: The ESD CAN handle to reuse to connect to the ESD CAN driver </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_timeout</em>&nbsp;</td><td>: The timeout to use:<ul>
<li>&lt;= 0 : wait forever (default)</li><li>T : wait for T seconds </li></ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_id_read</em>&nbsp;</td><td>- the CAN ID to use for reading (The SDH sends data on this ID, default=43=0x2a) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_id_write</em>&nbsp;</td><td>- the CAN ID to use for writing (The SDH receives data on this ID, default=42=0x2a)</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">         <span class="comment">// Assuming 'hand' is a cSDH object ...</span>
         <span class="comment">// and 'handle' is a valid ESD NTCAN_HANDLE</span>

         <span class="comment">// use default parameters for timeout and IDs</span>
         hand.OpenCAN_ESD( handle );

         <span class="comment">// or use non default settings:</span>
         <span class="comment">// timeout=1.0, id_read=0x143, id_write=0x142</span>
         hand.OpenCAN_ESD( handle, 1.0, 0x143, 0x142 );
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="1649fb2b3e2e3552f09cf517ebc81ce1"></a><!-- doxytag: member="SDH::cSDH::OpenCAN_PEAK" ref="1649fb2b3e2e3552f09cf517ebc81ce1" args="(unsigned long _baudrate=1000000, double _timeout=0.0, int32_t _id_read=43, int32_t _id_write=42, const char *device=&quot;/dev/pcanusb0&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cSDH::OpenCAN_PEAK           </td>
          <td>(</td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>_baudrate</em> = <code>1000000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>_timeout</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>_id_read</em> = <code>43</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>_id_write</em> = <code>42</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>device</em> = <code>&quot;/dev/pcanusb0&quot;</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Open connection to SDH via CAN using an PEAK CAN card. If the library was compiled without PEAK CAN support then this will just throw an exception. See setting for WITH_PEAK_CAN in the top level makefile.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_baudrate</em>&nbsp;</td><td>: the CAN baudrate in bit/s. Only some bitrates are valid: (1000000 (default),800000,500000,250000,125000,100000,50000,20000,10000) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_timeout</em>&nbsp;</td><td>: The timeout to use:<ul>
<li>&lt;= 0 : wait forever (default)</li><li>T : wait for T seconds </li></ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_id_read</em>&nbsp;</td><td>- the CAN ID to use for reading (The SDH sends data on this ID, default=43=0x02b) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_id_write</em>&nbsp;</td><td>- the CAN ID to use for writing (The SDH receives data on this ID, default=42=0x02a) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_device</em>&nbsp;</td><td>- the PEAK device name. Used for the Linux char dev driver only. default="/dev/pcanusb0"</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">         <span class="comment">// Assuming 'hand' is a cSDH object ...</span>

         <span class="comment">// use default parameters for baudrate, timeout, IDs and device</span>
         hand.OpenCAN_PEAK( );

         <span class="comment">// use non default settings:</span>
         <span class="comment">// baudrate=500000, timeout=1.0, id_read=0x143, id_write=0x142, , const char *device="/dev/pcanusb1"</span>
         hand.OpenCAN_PEAK( 500000, 1.0, 0x143, 0x142, <span class="stringliteral">"/dev/pcanusb1"</span> );
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="1327d49edf33b704af4840f8f3bb8022"></a><!-- doxytag: member="SDH::cSDH::OpenCAN_PEAK" ref="1327d49edf33b704af4840f8f3bb8022" args="(HANDLE _handle, double _timeout=0.0, int32_t _id_read=43, int32_t _id_write=42)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cSDH::OpenCAN_PEAK           </td>
          <td>(</td>
          <td class="paramtype">HANDLE&nbsp;</td>
          <td class="paramname"> <em>_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>_timeout</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>_id_read</em> = <code>43</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>_id_write</em> = <code>42</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Open connection to SDH via CAN using an PEAK CAN card using an existing handle. If the library was compiled without PEAK CAN support then this will just throw an exception. See setting for WITH_PEAK_CAN in the top level makefile.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_handle</em>&nbsp;</td><td>: The PEAK CAN handle to reuse to connect to the PEAK CAN driver </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_timeout</em>&nbsp;</td><td>: The timeout to use:<ul>
<li>&lt;= 0 : wait forever (default)</li><li>T : wait for T seconds </li></ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_id_read</em>&nbsp;</td><td>- the CAN ID to use for reading (The SDH sends data on this ID, default=43=0x2a) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_id_write</em>&nbsp;</td><td>- the CAN ID to use for writing (The SDH receives data on this ID, default=42=0x2a) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_device</em>&nbsp;</td><td>- the PEAK device name. Used for the Linux char dev driver only. default="/dev/pcanusb0"</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">         <span class="comment">// Assuming 'hand' is a cSDH object ...</span>
         <span class="comment">// and 'handle' is a valid PEAK NTCAN_HANDLE</span>

         <span class="comment">// use default parameters for timeout and IDs</span>
         hand.OpenCAN_PEAK( handle );

         <span class="comment">// or use non default settings:</span>
         <span class="comment">// timeout=1.0, id_read=0x143, id_write=0x142</span>
         hand.OpenCAN_PEAK( handle, 1.0, 0x143, 0x142 );
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="0e1850d4007313a924f255ab66973b7c"></a><!-- doxytag: member="SDH::cSDH::Close" ref="0e1850d4007313a924f255ab66973b7c" args="(bool leave_enabled=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cSDH::Close           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>leave_enabled</em> = <code>false</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Close connection to SDH.<p>
The default behaviour is to <b>not</b> leave the controllers of the SDH enabled (to prevent overheating). To keep the controllers enabled (e.g. to keep the finger axes actively in position) set <em>leave_enabled</em> to <code>true</code>. Only already enabled axes will be left enabled.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>leave_enabled</em>&nbsp;</td><td>- Flag: true to leave the controllers on, false (default) to disable the controllers (switch powerless)</td></tr>
  </table>
</dl>
This throws a (cSDHErrorCommunication*) exception if the connection was not opened before.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">         <span class="comment">// Assuming 'hand' is a cSDH object ...</span>

         <span class="comment">// Close connection to SDH, power off controllers:</span>
         hand.Close();

         <span class="comment">// To leave the already enabled controllers enabled:</span>
         hand.Close( <span class="keyword">true</span> );
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="6ee64093e4780da152320f8de537fe34"></a><!-- doxytag: member="SDH::cSDH::IsOpen" ref="6ee64093e4780da152320f8de537fe34" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cSDH::IsOpen           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw ()<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return true if connection to SDH firmware/hardware is open. 
<p>Implements <a class="el" href="class_s_d_h_1_1c_s_d_h_base.html#8bf9a947311cebe7d0eb37bfb0bb5761">SDH::cSDHBase</a>.</p>

</div>
</div><p>
<a class="anchor" name="7f71a82ab4074fb32c39b09aa56a6ab6"></a><!-- doxytag: member="SDH::cSDH::EmergencyStop" ref="7f71a82ab4074fb32c39b09aa56a6ab6" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cSDH::EmergencyStop           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Stop movement of all axes of the SDH and switch off the controllers<p>
This command will always be executed sequentially: it will return only after the SDH has confirmed the emergency stop.<p>
<dl compact><dt><b><a class="el" href="bug.html#_bug000003">Bug:</a></b></dt><dd>For now this will <b>NOT</b> work while a <a class="el" href="class_s_d_h_1_1c_s_d_h.html#1af5350393024630009896e5191a5f94">GripHand()</a> command is executing, even if that was initiated non-sequentially!</dd></dl>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">         <span class="comment">// Assuming 'hand' is a cSDH object ...</span>

         <span class="comment">// Perform an emergency stop:</span>
         hand.EmergencyStop();
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="22ecf8087e812233234c3f81c7b811d6"></a><!-- doxytag: member="SDH::cSDH::Stop" ref="22ecf8087e812233234c3f81c7b811d6" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cSDH::Stop           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Stop movement of all axes but keep controllers on<p>
This command will always be executed sequentially: it will return only after the SDH has confirmed the stop<p>
<dl compact><dt><b><a class="el" href="bug.html#_bug000004">Bug:</a></b></dt><dd>For now this will <b>NOT</b> work while a <a class="el" href="class_s_d_h_1_1c_s_d_h.html#1af5350393024630009896e5191a5f94">GripHand()</a> command is executing, even if that was initiated non-sequentially!</dd></dl>
<dl compact><dt><b><a class="el" href="bug.html#_bug000004">Bug:</a></b></dt><dd>With SDH firmware &lt; 0.0.2.7 this made the axis jerk in eCT_POSE controller type. This is resolved in SDH firmware 0.0.2.7 for the eCT_POSE controller type with velocity profile eVP_RAMP. For the eCT_POSE controller type with velocity profile eVP_SIN_SQUARE changing target points/ velocities while moving will still make the axes jerk. <br>
<b>=&gt; Partly resolved in SDH firmware 0.0.2.7</b></dd></dl>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">         <span class="comment">// Assuming 'hand' is a cSDH object ...</span>

         <span class="comment">// Perform a stop:</span>
         hand.Stop();
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="1a36b28e64f6b404205b924e9e55f781"></a><!-- doxytag: member="SDH::cSDH::SetController" ref="1a36b28e64f6b404205b924e9e55f781" args="(cSDHBase::eControllerType controller)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cSDH::SetController           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_s_d_h_1_1c_s_d_h_base.html#610f29a16806030c12e25bf83d89abbd">cSDHBase::eControllerType</a>&nbsp;</td>
          <td class="paramname"> <em>controller</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw ( <a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>* )</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the type of axis controller to be used in the SDH<p>
With SDH firmware &gt;= 0.0.2.7 this will automatically set valid default values for all target velocities, accelerations and positions in the SDH firmware, according to the <em>controller</em> type:<ul>
<li>eCT_POSE:<ul>
<li>target velocities will be set to default (40 deg/s)</li><li>target accelerations will be set to default (100 deg/(s*s))</li><li>target positions will be set to default (0.0 deg)</li></ul>
</li><li>eCT_VELOCITY:<ul>
<li>target velocities will be set to default (0 deg/s)</li></ul>
</li><li>eCT_VELOCITY_ACCELERATION:<ul>
<li>target velocities will be set to default (0 deg/s)</li><li>target accelerations will be set to default (100 deg/(s*s))</li></ul>
</li></ul>
<p>
This will also adjust the lower limits of the allowed velocities here in the SDHLibrary, since the eCT_POSE controller allows only positive velocities while the eCT_VELOCITY and eCT_VELOCITY_ACCELERATION controllers require also negative velocities.<p>
<dl class="attention" compact><dt><b>Attention:</b></dt><dd>The availability of a controller type depends on the SDH firmware of the attached SDH and is checked here.<ul>
<li>firmware &lt;= 0.0.2.5: only eCT_POSE</li><li>firmware &gt;= 0.0.2.6: eCT_POSE, eCT_VELOCITY, eCT_VELOCITY_ACCELERATION</li></ul>
</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>controller</em>&nbsp;</td><td>- identifier of controller to set. Valid values are defined in eControllerType</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">         <span class="comment">// Assuming 'hand' is a cSDH object ...</span>

         <span class="comment">// Set the pose controller in the SDH</span>
         <span class="comment">// (see e.g. demo-simple.cpp, demo-simple2.cpp, demo-simple3.cpp for further examples)</span>
         hand.SetController( hand.eCT_POSE );

         <span class="comment">// Set the simple velocity controller in the SDH:</span>
         hand.SetController( hand.eCT_VELOCITY );

         <span class="comment">// Set the velocity with acceleration ramp controller in the SDH:</span>
         <span class="comment">// (see e.g. demo-velocity-acceleration.cpp for further examples)</span>
         hand.SetController( hand.eCT_VELOCITY_ACCELERATION );
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="f7405f6e9fbd7c82beb0118bf212e173"></a><!-- doxytag: member="SDH::cSDH::GetController" ref="f7405f6e9fbd7c82beb0118bf212e173" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_d_h_1_1c_s_d_h_base.html#610f29a16806030c12e25bf83d89abbd">cSDHBase::eControllerType</a> cSDH::GetController           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the type of axis controller used in the SDH<p>
The currently set controller type will be queried and returned (One of eControllerType)<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">        <span class="comment">// Assuming 'hand' is a sdh.cSDH object ...</span>

        <span class="comment">// Get the controller type of the attached SDH:</span>
        ct = hand.GetController();

        <span class="comment">// Print result, numerically and symbolically</span>
        std::cout &lt;&lt; <span class="stringliteral">"Currently the axis controller type is set to "</span> &lt;&lt; ct;
        std::cout &lt;&lt; <span class="stringliteral">"("</span> &lt;&lt; <a class="code" href="class_s_d_h_1_1c_s_d_h_base.html#09f1b8791fdc34a28a4e55b66c478c31" title="Return a ptr to a (static) string describing controller type controller_Type.">GetStringFromControllerType</a>(ct) &lt;&lt; <span class="stringliteral">")\n"</span>;
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="37af32c5dc1153c53524537ba5b460f5"></a><!-- doxytag: member="SDH::cSDH::SetVelocityProfile" ref="37af32c5dc1153c53524537ba5b460f5" args="(eVelocityProfile velocity_profile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cSDH::SetVelocityProfile           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_s_d_h_1_1c_s_d_h_base.html#024f2645cbaa93a6cca8632a56408cc1">eVelocityProfile</a>&nbsp;</td>
          <td class="paramname"> <em>velocity_profile</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the type of velocity profile to be used in the SDH<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>velocity_profile</em>&nbsp;</td><td>- Name or number of velocity profile to set. Valid values are defined in eVelocityProfileType</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">        <span class="comment">// Assuming 'hand' is a cSDH object ...</span>

        <span class="comment">// Set the sin square velocity profile in the SDH:</span>
        hand.SetVelocityProfile( hand.eVP_SIN_SQUARE );

        <span class="comment">// Or else set the ramp velocity profile in the SDH:</span>
        hand.SetVelocityProfile( hand.eVP_RAMP )
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="54c9569ac8e4bbcc144b6d8679929a79"></a><!-- doxytag: member="SDH::cSDH::GetVelocityProfile" ref="54c9569ac8e4bbcc144b6d8679929a79" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_d_h_1_1c_s_d_h_base.html#024f2645cbaa93a6cca8632a56408cc1">cSDHBase::eVelocityProfile</a> cSDH::GetVelocityProfile           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the type of velocity profile used in the SDH<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the currently set velocity profile as integer, see eVelocityProfileType</dd></dl>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">        <span class="comment">// Assuming 'hand' is a cSDH object ...</span>

        <span class="comment">// Get the velocity profile from the SDH:</span>
        velocity_profile = hand.GetVelocityProfile();
        <span class="comment">// now velocity_profile is something like eVP_SIN_SQUARE or eVP_RAMP</span>
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="483d0e5db3acab3dbdf012fdafd49089"></a><!-- doxytag: member="SDH::cSDH::SetAxisMotorCurrent" ref="483d0e5db3acab3dbdf012fdafd49089" args="(std::vector&lt; int &gt; const &amp;axes, std::vector&lt; double &gt; const &amp;motor_currents, eMotorCurrentMode mode=eMCM_MOVE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cSDH::SetAxisMotorCurrent           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>axes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>motor_currents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#712b0b80382f1e1e5229ad7bec6cdc4d">eMotorCurrentMode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em> = <code>eMCM_MOVE</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the maximum allowed motor current(s) for axes.<p>
The maximum allowed motor currents are sent to the SDH. The motor currents can be stored:<ul>
<li>axis specific</li><li>mode specific (see <a class="el" href="class_s_d_h_1_1c_s_d_h.html#712b0b80382f1e1e5229ad7bec6cdc4d" title="the motor current can be set specifically for these modes:">eMotorCurrentMode</a>)</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axes</em>&nbsp;</td><td>- A vector of axis indices to access. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>motor_currents</em>&nbsp;</td><td>- A vector of motor currents to set. If any of the numbers in the vector is <code>NaN</code> (Not a Number) then the currently set axis motor current will be kept for the corresponding axis. The value(s) are expected in the configured motor current unit system <a class="el" href="class_s_d_h_1_1c_s_d_h.html#57bb98bd30adf2189a62f31388bc6bae" title="unit converter for motor curent: default = SDH::cSDH::uc_motor_current_ampere">uc_motor_current</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>- the mode to set the maximum motor current for. One of the <a class="el" href="class_s_d_h_1_1c_s_d_h.html#712b0b80382f1e1e5229ad7bec6cdc4d" title="the motor current can be set specifically for these modes:">eMotorCurrentMode</a> modes.</td></tr>
  </table>
</dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd><ul>
<li>The lengths of the <em>axes</em> and <em>motor_currents</em> vector must match.</li><li>The indices can be given in any order, but the order of their elements must match, i.e. <code>motor_currents</code>[i] will be applied to axis <code>axes</code>[i] (not axis <code>i</code>).</li><li>The indices are checked if they are valid axis indices.</li><li>The motor currents are checked if they are in the allowed range [0 .. <a class="el" href="class_s_d_h_1_1c_s_d_h.html#c2a56629fe34ac72d6cc1ad5cbde2ed0" title="Maximum allowed motor currents (in internal units (Ampere)), including the virtual...">f_max_motor_current_v</a>], i.e. it is checked that <code>motor_currents</code>[i], converted to internal units, is in <code></code>[0 .. <code>f_max_motor_currents_v</code>[axes[i]]].</li><li>If <b>any</b> index or value is invalid then <b>none</b> of the specified values is sent to the SDH, instead a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
</dd></dl>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#fc3046c2e957ee95eda1e61dde389adf">SetAxisMotorCurrent(int,double,eMotorCurrentMode)</a> for an overloaded variant to set a single axis motor current or to set the same motor current for all axes.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming "hand" is a cSDH object ...</span>

          <span class="comment">// Set maximum allowed motor current of all axes to the given values in mode "eMCM_MOVE"::</span>
          std::vector&lt;double&gt; all_motor_currents;
          all_motor_currents.push_back( 0.0 );
          all_motor_currents.push_back( 0.1 );
          all_motor_currents.push_back( 0.2 );
          all_motor_currents.push_back( 0.3 );
          all_motor_currents.push_back( 0.4 );
          all_motor_currents.push_back( 0.5 );
          all_motor_currents.push_back( 0.6 );

          hand.SetAxisMotorCurrent( hand.all_axes, all_motor_currents );


          <span class="comment">// Set maximum allowed motor current of all axes to 0.1 A in mode "eMCM_HOLD":</span>
          hand.SetAxisMotorCurrent( hand.All, 1.0, <a class="code" href="class_s_d_h_1_1c_s_d_h.html#712b0b80382f1e1e5229ad7bec6cdc4d690e9bb2611fe2a597bb2b9443856fe1" title="The motor currents used after &amp;quot;gripping&amp;quot; with a GripHand() command (i.e...">eMCM_HOLD</a> );

          <span class="comment">// Set maximum allowed motor current of axis 3 to 0.75 A in mode "eMCM_MOVE":</span>
          hand.SetAxisMotorCurrent( 3, 0.75, <a class="code" href="class_s_d_h_1_1c_s_d_h.html#712b0b80382f1e1e5229ad7bec6cdc4da0a075991ceba063aff574398f8ff05e" title="The motor currents used while &amp;quot;moving&amp;quot; with a MoveHand() or MoveFinger()...">eMCM_MOVE</a> );

          <span class="comment">// Set maximum allowed motor current of for axis 0, 4 and 2 to 0.0 A,</span>
          <span class="comment">// 0.4 A and 0.2 A respectively in mode "eMCM_GRIP"</span>
          std::vector&lt;int&gt; axes042;
          axes042.push_back( 0 );
          axes042.push_back( 4 );
          axes042.push_back( 2 );
          std::vector&lt;double&gt; motor_currents042;
          motor_currents042.push_back( 0.0 );
          motor_currents042.push_back( 0.4 );
          motor_currents042.push_back( 0.2 );

          hand.SetAxisMotorCurrent( axes042, states042, <a class="code" href="class_s_d_h_1_1c_s_d_h.html#712b0b80382f1e1e5229ad7bec6cdc4d63872c18691513275682b347c68732b5" title="The motor currents used while &amp;quot;gripping&amp;quot; with a GripHand() command.">eMCM_GRIP</a> );
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="fc3046c2e957ee95eda1e61dde389adf"></a><!-- doxytag: member="SDH::cSDH::SetAxisMotorCurrent" ref="fc3046c2e957ee95eda1e61dde389adf" args="(int iAxis, double motor_current, eMotorCurrentMode mode=eMCM_MOVE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cSDH::SetAxisMotorCurrent           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iAxis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>motor_current</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#712b0b80382f1e1e5229ad7bec6cdc4d">eMotorCurrentMode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em> = <code>eMCM_MOVE</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#483d0e5db3acab3dbdf012fdafd49089">SetAxisMotorCurrent(std::vector&lt;int&gt;const&amp;,std::vector&lt;double&gt;const&amp;,eMotorCurrentMode)</a>, just for a single axis <em>iAxis</em> and a single motor current <em>motor_current</em>, see there.<p>
If <em>iAxis</em> is <a class="el" href="class_s_d_h_1_1c_s_d_h_base.html#ab61ed07c53bf24bc87ff5103e74f45a8e09b2cc8bc776a705cd2665fc555881" title="A meta-value that means &quot;access all possible values&quot;.">All</a> then <em>motor_current</em> is set for all axes. 
</div>
</div><p>
<a class="anchor" name="0a45116eb8edbb9c5700431d67968d6e"></a><!-- doxytag: member="SDH::cSDH::GetAxisMotorCurrent" ref="0a45116eb8edbb9c5700431d67968d6e" args="(std::vector&lt; int &gt; const &amp;axes, eMotorCurrentMode mode=eMCM_MOVE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; cSDH::GetAxisMotorCurrent           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>axes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#712b0b80382f1e1e5229ad7bec6cdc4d">eMotorCurrentMode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em> = <code>eMCM_MOVE</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the maximum allowed motor current(s) of axis(axes).<p>
The maximum allowed motor currents are read from the SDH. The motor currents are stored:<ul>
<li>axis specific</li><li>mode specific (see eMotorCurrentMode)</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axes</em>&nbsp;</td><td>- A vector of axis indices to access. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>- the mode to set the maximum motor current for. One of the <a class="el" href="class_s_d_h_1_1c_s_d_h.html#712b0b80382f1e1e5229ad7bec6cdc4d" title="the motor current can be set specifically for these modes:">eMotorCurrentMode</a> modes.</td></tr>
  </table>
</dl>
<ul>
<li>The indices in <em>axes</em> are checked if they are valid axis indices.</li><li>If <b>any</b> axis index is invalid then a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>A vector of the motor currents of the selected axes.</li><li>The values are converted to the selected external unit system using the configured <a class="el" href="class_s_d_h_1_1c_s_d_h.html#57bb98bd30adf2189a62f31388bc6bae" title="unit converter for motor curent: default = SDH::cSDH::uc_motor_current_ampere">uc_motor_current</a> unit converter object.</li><li>The order of the elements of the <em>axes</em> vector and the returned values vector <em>rv</em> matches. I.e. <code>rv</code>[i] will be the value of axis <code>axes</code>[i] (not axis <code>i</code>).</li></ul>
</dd></dl>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#7a5d62417bdf142e6cf57b40277e500a">GetAxisMotorCurrent(int,eMotorCurrentMode)</a> for an overloaded variant to access a single axis.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming "hand" is a cSDH object ...</span>

          <span class="comment">// Get maximum allowed motor currents of all axes</span>
          std::vector&lt;double&gt; v = hand.GetAxisMotorCurrent( hand.all_axes );
          <span class="comment">// now v is something like {0.1, 0.2, 0.3, 0.4, 0.5, 0,6, 0.7}</span>

          <span class="comment">// Get maximum allowed motor current of axis 3 in mode "eMCM_MOVE"</span>
          <span class="keywordtype">double</span> mc3 = hand.GetAxisMotorCurrent( 3, <a class="code" href="class_s_d_h_1_1c_s_d_h.html#712b0b80382f1e1e5229ad7bec6cdc4da0a075991ceba063aff574398f8ff05e" title="The motor currents used while &amp;quot;moving&amp;quot; with a MoveHand() or MoveFinger()...">eMCM_MOVE</a> );
          <span class="comment">// mc3 is now something like 0.75</span>

          <span class="comment">// Get maximum allowed motor current of axis 3 and 5 in mode "eMCM_GRIP"</span>
          std::vector&lt;int&gt; axes35;
          axes35.push_back( 3 );
          axes35.push_back( 5 );

          v = hand.GetAxisMotorCurrent( axes35, <a class="code" href="class_s_d_h_1_1c_s_d_h.html#712b0b80382f1e1e5229ad7bec6cdc4d63872c18691513275682b347c68732b5" title="The motor currents used while &amp;quot;gripping&amp;quot; with a GripHand() command.">eMCM_GRIP</a> );
          <span class="comment">// now v is something like {0.5,0.5};</span>
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="7a5d62417bdf142e6cf57b40277e500a"></a><!-- doxytag: member="SDH::cSDH::GetAxisMotorCurrent" ref="7a5d62417bdf142e6cf57b40277e500a" args="(int iAxis, eMotorCurrentMode mode=eMCM_MOVE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cSDH::GetAxisMotorCurrent           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iAxis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#712b0b80382f1e1e5229ad7bec6cdc4d">eMotorCurrentMode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em> = <code>eMCM_MOVE</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#0a45116eb8edbb9c5700431d67968d6e">GetAxisMotorCurrent(std::vector&lt;int&gt;const&amp;,eMotorCurrentMode)</a>, just for a single axis, see there for details and examples. 
</div>
</div><p>
<a class="anchor" name="270bf0af4a0bb3f3e8cbe4e1931d7dfd"></a><!-- doxytag: member="SDH::cSDH::SetAxisEnable" ref="270bf0af4a0bb3f3e8cbe4e1931d7dfd" args="(std::vector&lt; int &gt; const &amp;axes, std::vector&lt; double &gt; const &amp;states)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cSDH::SetAxisEnable           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>axes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>states</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set enabled/disabled state of axis controller(s).<p>
The controllers of the selected axes are enabled/disabled in the SDH. Disabled axes are not powered and thus might not remain in their current pose due to gravity, inertia or other external influences. But to prevent overheating the axis controllers should be switched of when not needed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axes</em>&nbsp;</td><td>- A vector of axis indices to access. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>states</em>&nbsp;</td><td>- A vector of enabled states (0 = disabled, !=0 = enabled) to set. If any of the numbers in the vector is <code>NaN</code> (Not a Number) then the currently set enabled state will be kept for the corresponding axis.</td></tr>
  </table>
</dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd><ul>
<li>The lengths of the <em>axes</em> and <em>states</em> vector must match.</li><li>The indices can be given in any order, but the order of their elements must match, i.e. <code>state</code>[i] will be applied to axis <code>axes</code>[i] (not axis <code>i</code>).</li><li>The indices are checked if they are valid axis indices.</li><li>If <b>any</b> index is invalid then <b>none</b> of the specified values is sent to the SDH, instead a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
</dd></dl>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#988759f8400905534fa5e5bcc032dbf4">SetAxisEnable(int,double)</a>, <a class="el" href="class_s_d_h_1_1c_s_d_h.html#60975160fe4a5cc7d1f7f80d5ab05a1c">SetAxisEnable(int,bool)</a> for overloaded variants to set a single axis enabled/disabled or to set the same state for all axes. See further <a class="el" href="class_s_d_h_1_1c_s_d_h.html#40df6819257ce8634e8d0db4b678cfef">SetAxisEnable(std::vector&lt;int&gt;const&amp;,std::vector&lt;bool&gt;const&amp;)</a> for a variant that accepts a <code>bool</code> vector for the states to set.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming 'hand' is a cSDH object ...</span>

          <span class="comment">// Enable all axes:</span>
          hand.SetAxisEnable( hand.all_axes, hand.ones_v );

          <span class="comment">// Disable all axes:</span>
          hand.SetAxisEnable( <a class="code" href="class_s_d_h_1_1c_s_d_h_base.html#ab61ed07c53bf24bc87ff5103e74f45a8e09b2cc8bc776a705cd2665fc555881" title="A meta-value that means &amp;quot;access all possible values&amp;quot;.">All</a>, 0 );

          <span class="comment">// Enable axis 0 and 2 while disabling axis 4:</span>
          std::vector&lt;int&gt; axes042;
          axes042.push_back( 0 );
          axes042.push_back( 4 );
          axes042.push_back( 2 );

          std::vector&lt;double&gt; states042;
          states042.push_back( 1.0 );
          states042.push_back( 0.0 );
          states042.push_back( 1.0 );

          hand.SetAxisEnable( axes042, states042 );


          <span class="comment">// Disable axis 2</span>
          hand.SetAxisEnable( 2, <span class="keyword">false</span> );
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="988759f8400905534fa5e5bcc032dbf4"></a><!-- doxytag: member="SDH::cSDH::SetAxisEnable" ref="988759f8400905534fa5e5bcc032dbf4" args="(int iAxis=All, double state=1.0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cSDH::SetAxisEnable           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iAxis</em> = <code>All</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>state</em> = <code>1.0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#270bf0af4a0bb3f3e8cbe4e1931d7dfd">SetAxisEnable(std::vector&lt;int&gt;const&amp;,std::vector&lt;double&gt;const&amp;)</a>, just for a single axis <em>iAxis</em> and a single axis state <em>state</em>, see there.<p>
If <em>iAxis</em> is <a class="el" href="class_s_d_h_1_1c_s_d_h_base.html#ab61ed07c53bf24bc87ff5103e74f45a8e09b2cc8bc776a705cd2665fc555881" title="A meta-value that means &quot;access all possible values&quot;.">All</a> then <em>state</em> is applied to all axes. 
</div>
</div><p>
<a class="anchor" name="40df6819257ce8634e8d0db4b678cfef"></a><!-- doxytag: member="SDH::cSDH::SetAxisEnable" ref="40df6819257ce8634e8d0db4b678cfef" args="(std::vector&lt; int &gt; const &amp;axes, std::vector&lt; bool &gt; const &amp;states)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cSDH::SetAxisEnable           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>axes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>states</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#270bf0af4a0bb3f3e8cbe4e1931d7dfd">SetAxisEnable(std::vector&lt;int&gt;const&amp;,std::vector&lt;double&gt;const&amp;)</a>, just accepting a vector of <code>bool</code> values as states, see there. 
</div>
</div><p>
<a class="anchor" name="60975160fe4a5cc7d1f7f80d5ab05a1c"></a><!-- doxytag: member="SDH::cSDH::SetAxisEnable" ref="60975160fe4a5cc7d1f7f80d5ab05a1c" args="(int iAxis=All, bool state=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cSDH::SetAxisEnable           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iAxis</em> = <code>All</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>state</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#270bf0af4a0bb3f3e8cbe4e1931d7dfd">SetAxisEnable(std::vector&lt;int&gt;const&amp;,std::vector&lt;double&gt;const&amp;)</a>, just for a single axis <em>iAxis</em> and a single axis state <em>state</em>, see there.<p>
If <em>iAxis</em> is <a class="el" href="class_s_d_h_1_1c_s_d_h_base.html#ab61ed07c53bf24bc87ff5103e74f45a8e09b2cc8bc776a705cd2665fc555881" title="A meta-value that means &quot;access all possible values&quot;.">All</a> then <em>state</em> is applied to all axes. 
</div>
</div><p>
<a class="anchor" name="e9845847fa4ab972699d79b25e61de3c"></a><!-- doxytag: member="SDH::cSDH::GetAxisEnable" ref="e9845847fa4ab972699d79b25e61de3c" args="(std::vector&lt; int &gt; const &amp;axes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; cSDH::GetAxisEnable           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>axes</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get enabled/disabled state of axis controller(s).<p>
The enabled/disabled state of the controllers of the selected axes is read from the SDH.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axes</em>&nbsp;</td><td>- A vector of axis indices to access.</td></tr>
  </table>
</dl>
<ul>
<li>The indices in <em>axes</em> are checked if they are valid axis indices.</li><li>If <b>any</b> axis index is invalid then a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>A vector of enabled/disabled states as doubles (0=disabled, 1.0=enabled) of the selected axes.</li><li>The order of the elements of the <em>axes</em> vector and the returned values vector <em>rv</em> matches. I.e. <code>rv</code>[i] will be the value of axis <code>axes</code>[i] (not axis <code>i</code>).</li></ul>
</dd></dl>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#653fff0ee151151babf10f1c6e1f0aef">GetAxisEnable(int)</a> for an overloaded variant to access a single axis.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming 'hand' is a cSDH object ...</span>

          <span class="comment">// Get enabled state of all axes:</span>
          std::vector&lt;double&gt; v = hand.GetAxisEnable( hand.all_axes );
          <span class="comment">// now v is something like {0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0}</span>

          <span class="comment">// Get enabled state of axis 3 and 5</span>
          std::vector&lt;int&gt; axes35;
          axes35.push_back( 3 );
          axes35.push_back( 5 );

          v = hand.GetAxisEnable( axes35 );
          <span class="comment">// now v is something like {1.0, 0.0}</span>


          <span class="comment">// Get enabled state of axis 3</span>
          <span class="keywordtype">double</span> v3 = hand.GetAxisEnable( 3 );
          <span class="comment">// now v3 is something like 1.0</span>
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="653fff0ee151151babf10f1c6e1f0aef"></a><!-- doxytag: member="SDH::cSDH::GetAxisEnable" ref="653fff0ee151151babf10f1c6e1f0aef" args="(int iAxis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cSDH::GetAxisEnable           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iAxis</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#e9845847fa4ab972699d79b25e61de3c">GetAxisEnable(std::vector&lt;int&gt;const&amp;)</a>, just for a single axis <em>iAxis</em>, see there for details and examples. 
</div>
</div><p>
<a class="anchor" name="d6a6595deb75b468fe8e230c5f356136"></a><!-- doxytag: member="SDH::cSDH::GetAxisActualState" ref="d6a6595deb75b468fe8e230c5f356136" args="(std::vector&lt; int &gt; const &amp;axes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="class_s_d_h_1_1c_s_d_h.html#b5f553148de415980dd90cb92f30b54b">cSDH::eAxisState</a> &gt; cSDH::GetAxisActualState           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>axes</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the current actual state(s) of axis(axes).<p>
The actual axis states are read from the SDH.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axes</em>&nbsp;</td><td>- A vector of axis indices to access.</td></tr>
  </table>
</dl>
<ul>
<li>The indices in <em>axes</em> are checked if they are valid axis indices.</li><li>If <b>any</b> axis index is invalid then a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>A vector of the actual states of the selected axes.</li><li>The values are given as <a class="el" href="class_s_d_h_1_1c_s_d_h.html#b5f553148de415980dd90cb92f30b54b" title="The state of an axis (see TPOSCON_STATE in global.h of the SDH firmware).">eAxisState</a> enum values</li><li>The order of the elements of the <em>axes</em> vector and the returned values vector <em>rv</em> matches. I.e. <code>rv</code>[i] will be the value of axis <code>axes</code>[i] (not axis <code>i</code>).</li></ul>
</dd></dl>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#51d250e208d3d829e40bc1e4c3413640">GetAxisActualState(int)</a> for an overloaded variant to access a single axis.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming "hand" is a cSDH object ...</span>

          <span class="comment">// Get actual axis state of all axes</span>
          std::vector&lt;eAxisState&gt; v = hand.GetAxisActualState( hand.all_axes )
          <span class="comment">// now v is something like {eAS_IDLE, eAS_POSITIONING, eAS_IDLE, eAS_IDLE, eAS_IDLE, eAS_DISABLED, eAS_IDLE}</span>

          <span class="comment">// Get actual axis state of axis 3</span>
          <a class="code" href="class_s_d_h_1_1c_s_d_h.html#b5f553148de415980dd90cb92f30b54b" title="The state of an axis (see TPOSCON_STATE in global.h of the SDH firmware).">eAxisState</a> v3 = hand.GetAxisActualState( 3 );
          <span class="comment">// v3 is now something like eAS_IDLE</span>


          <span class="comment">// Get actual state of axis 2 and 5</span>
          std::vector&lt;int&gt; axes25;
          axes25.push_back( 2 );
          axes25.push_back( 5 );

          v = hand.GetAxisActualState( axes25 );
          <span class="comment">// now v is something like {eAS_IDLE, eAS_DISABLED}</span>
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="51d250e208d3d829e40bc1e4c3413640"></a><!-- doxytag: member="SDH::cSDH::GetAxisActualState" ref="51d250e208d3d829e40bc1e4c3413640" args="(int iAxis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#b5f553148de415980dd90cb92f30b54b">cSDH::eAxisState</a> cSDH::GetAxisActualState           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iAxis</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#d6a6595deb75b468fe8e230c5f356136">GetAxisActualState(std::vector&lt;int&gt;const&amp;)</a>, just for a single axis <em>iAxis</em>, see there for details and examples. 
</div>
</div><p>
<a class="anchor" name="ddce51bc94cec44f4fe652e168c7ad44"></a><!-- doxytag: member="SDH::cSDH::WaitAxis" ref="ddce51bc94cec44f4fe652e168c7ad44" args="(std::vector&lt; int &gt; const &amp;axes, double timeout=-1.0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cSDH::WaitAxis           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>axes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>-1.0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wait until the movement(s) of of axis(axes) has finished<p>
The state of the given axis(axes) is(are) queried until all axes are no longer moving.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axes</em>&nbsp;</td><td>- A vector of axis indices to access. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>- a timeout in seconds or -1.0 (default) to wait indefinetly.</td></tr>
  </table>
</dl>
<ul>
<li>The indices in <em>axes</em> are checked if they are valid axis indices.</li><li>If <b>any</b> axis index is invalid then a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.<ul>
<li>If <em>timeout</em> &lt; 0 then this function will wait arbitrarily long</li><li>If a <em>timeout</em> is given then this function will throw a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_communication.html" title="Derived exception class for exceptions related to communication between the SDHLibrary...">cSDHErrorCommunication</a> exception if the given axes are still moving after <em>timeout</em> many seconds</li></ul>
</li></ul>
<p>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#38fb5c717c3850c40a3dc557d83e3ced">WaitAxis(int,double)</a> for an overloaded variant to wait for a single axis or all axes.<p>
<dl compact><dt><b><a class="el" href="bug.html#_bug000006">Bug:</a></b></dt><dd>Due to a bug in SDH firmwares prior to 0.0.2.6 the <a class="el" href="class_s_d_h_1_1c_s_d_h.html#ddce51bc94cec44f4fe652e168c7ad44">WaitAxis()</a> command was somewhat unreliable there. When called immediately after a movement command like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#91ecc6595c68f2c6f00d31ffaea22a60">MoveHand()</a>, then the <a class="el" href="class_s_d_h_1_1c_s_d_h.html#ddce51bc94cec44f4fe652e168c7ad44">WaitAxis()</a> command returned immediately without waiting for the end of the movement. With SDH firmwares 0.0.2.6 and newer this is no longer problematic and <a class="el" href="class_s_d_h_1_1c_s_d_h.html#ddce51bc94cec44f4fe652e168c7ad44">WaitAxis()</a> works as expected. <br>
<b>=&gt; Resolved in SDH firmware 0.0.2.6</b></dd></dl>
<dl compact><dt><b><a class="el" href="bug.html#_bug000006">Bug:</a></b></dt><dd>With SDH firmware 0.0.2.6 <a class="el" href="class_s_d_h_1_1c_s_d_h.html#ddce51bc94cec44f4fe652e168c7ad44">WaitAxis()</a> did not work if one of the new velocity based controllers (eCT_VELOCITY, eCT_VELOCITY_ACCELERATION) was used. With SDH firmwares 0.0.2.7 and newer this now works. Here the <a class="el" href="class_s_d_h_1_1c_s_d_h.html#ddce51bc94cec44f4fe652e168c7ad44">WaitAxis()</a> waits until the selected axes come to velocity 0.0 <br>
<b>=&gt; Resolved in SDH firmware 0.0.2.7</b></dd></dl>
<dl class="user" compact><dt><b>Examples:</b></dt><dd>Example 1, WaitAxis and eCT_POSE controller, see also the demo program demo-simple3: <div class="fragment"><pre class="fragment">          <span class="comment">// Assuming "hand" is a cSDH object ...</span>

          hand.SetController( <a class="code" href="class_s_d_h_1_1c_s_d_h_base.html#610f29a16806030c12e25bf83d89abbd4ca0525d11ede40135676cf42ccb13fa" title="coordinated position controller (position per axis =&amp;gt; &amp;quot;pose controller&amp;quot;)...">eCT_POSE</a> );

          <span class="comment">// Set a new target pose for axis 1,2 and 3</span>
          std::vector&lt;int&gt; axes123;
          axes123.push_back( 1 );
          axes123.push_back( 2 );
          axes123.push_back( 3 );

          std::vector&lt;double&gt; angles123;
          angles123.push_back( -20.0 );
          angles123.push_back( -30.0 );
          angles123.push_back( -40.0 );


          hand.SetAxisTargetAngle( axes123, angles123 );

          <span class="comment">// Move axes there non sequentially:</span>
          hand.MoveAxis( axes123, <span class="keyword">false</span> );

          <span class="comment">// The last call returned immediately so we now have time to</span>
          <span class="comment">// do something else while the hand is moving:</span>

          <span class="comment">// ... insert any calculation here ...</span>

          <span class="comment">// Before doing something else with the hand make shure the</span>
          <span class="comment">// selected axes have finished the last movement:</span>
          hand.WaitAxis( axes123 );


          <span class="comment">// go back home (all angles to 0.0):</span>
          hand.SetAxisTargetAngle( hand.All, 0.0 );

          <span class="comment">// Move all axes there non sequentially:</span>
          hand.MoveAxis( hand.All, False );

          <span class="comment">// ... insert any other calculation here ...</span>

          <span class="comment">// Wait until all axes are there, with a timeout of 10s:</span>
          hand.WaitAxis( hand.All, 10.0 );

          <span class="comment">// now we are at the desired position.</span>
</pre></div></dd></dl>
Example 2, WaitAxis and eCT_VELOCITY_ACCELERATION controller, see also the demo program demo-velocity-acceleration <div class="fragment"><pre class="fragment">          <span class="comment">// Assuming "hand" is a cSDH object ...</span>

          hand.SetController( <a class="code" href="class_s_d_h_1_1c_s_d_h_base.html#610f29a16806030c12e25bf83d89abbd82ae7fbb40d0b4eb851ea71a6a80e7bb" title="velocity controller with acceleration ramp, velocities and accelerations of axes...">eCT_VELOCITY_ACCELERATION</a>);

          <span class="comment">// Set a new target velocity for axis 1,2 and 3</span>
          std::vector&lt;int&gt; axes123;
          axes123.push_back( 1 );
          axes123.push_back( 2 );
          axes123.push_back( 3 );

          std::vector&lt;double&gt; velocities123;
          velocities123.push_back( -20.0 );
          velocities123.push_back( -30.0 );
          velocities123.push_back( -40.0 );


          hand.SetAxisTargetVelocity( axes123, velocities123 ); <span class="comment">// this will make the axes move!</span>

          <span class="comment">// The last call returned immediately so we now have time to</span>
          <span class="comment">// do something else while the hand is moving:</span>

          <span class="comment">// ... insert any calculation here ...</span>

          <span class="comment">// to break and stop the movement just set the target velocities to 0.0</span>
          velocities123[0] = 0.0;
          velocities123[1] = 0.0;
          velocities123[2] = 0.0;

          hand.SetAxisTargetVelocity( axes123, velocities123 ); <span class="comment">// this will make the axes break with the default (de)acceleration</span>

          <span class="comment">// The previous command returned immediately, so</span>
          <span class="comment">// before doing something else with the hand make shure the</span>
          <span class="comment">// selected axes have stopped:</span>
          hand.WaitAxis( axes123 );

          <span class="comment">// now the axes have stopped</span>
</pre></div><p>
<hr>
 
</div>
</div><p>
<a class="anchor" name="38fb5c717c3850c40a3dc557d83e3ced"></a><!-- doxytag: member="SDH::cSDH::WaitAxis" ref="38fb5c717c3850c40a3dc557d83e3ced" args="(int iAxis, double timeout=-1.0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cSDH::WaitAxis           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iAxis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>-1.0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#ddce51bc94cec44f4fe652e168c7ad44">WaitAxis(std::vector&lt;int&gt;const&amp;,double)</a>, just for a single axis <em>iAxis</em>, see there for details and examples.<p>
If <em>iAxis</em> is <a class="el" href="class_s_d_h_1_1c_s_d_h_base.html#ab61ed07c53bf24bc87ff5103e74f45a8e09b2cc8bc776a705cd2665fc555881" title="A meta-value that means &quot;access all possible values&quot;.">All</a> then wait for all axes axes. 
</div>
</div><p>
<a class="anchor" name="f14021a2e8c95353d64f86b9208a0904"></a><!-- doxytag: member="SDH::cSDH::SetAxisTargetAngle" ref="f14021a2e8c95353d64f86b9208a0904" args="(std::vector&lt; int &gt; const &amp;axes, std::vector&lt; double &gt; const &amp;angles)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cSDH::SetAxisTargetAngle           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>axes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>angles</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the target angle(s) for axis(axes).<p>
The target angles are stored in the SDH, the movement is not executed until an additional move command is sent.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axes</em>&nbsp;</td><td>- A vector of axis indices to access. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>angles</em>&nbsp;</td><td>- A vector of axis target angles to set. If any of the numbers in the vector is <code>NaN</code> (Not a Number) then the currently set axis target angle will be kept for the corresponding axis. The value(s) are expected in the configured angle unit system <a class="el" href="class_s_d_h_1_1c_s_d_h.html#bcb9da3cf0236c0e09cdd7af1a78225e" title="unit convert for (axis) angles: default = SDH::cSDH::uc_angle_degrees">uc_angle</a>.</td></tr>
  </table>
</dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd><ul>
<li>Setting the target angle will <b>not</b> make the axis/axes move.</li><li>The lengths of the <em>axes</em> and <em>angles</em> vector must match.</li><li>The indices can be given in any order, but the order of their elements must match, i.e. <code>angles</code>[i] will be applied to axis <code>axes</code>[i] (not axis <code>i</code>).</li><li>The indices are checked if they are valid axis indices.</li><li>The angles are checked if they are in the allowed range [0 .. <a class="el" href="class_s_d_h_1_1c_s_d_h.html#bd406a461d7fd466b6ae8708b1011e0c" title="Maximum allowed axis angles (in internal units (degrees)), including the virtual...">f_max_angle_v</a>], i.e. it is checked that <code>angles</code>[i], converted to internal units, is in <code></code>[0 .. <code>f_max_angle_v</code>[axes[i]]].</li><li>If <b>any</b> index or value is invalid then <b>none</b> of the specified values is sent to the SDH, instead a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
</dd></dl>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#079b2a7c493eab45984ea64b773124a3">SetAxisTargetAngle(int,double)</a> for an overloaded variant to set a single axis target angle or to set the same target angle for all axes.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming "hand" is a cSDH object ...</span>

          <span class="comment">// Set target axis angle of all axes to the given values:</span>
          std::vector&lt;double&gt; all_angles;
          all_angles.push_back( 0.0 );
          all_angles.push_back( -11.0 );
          all_angles.push_back( -22.0 );
          all_angles.push_back( -33.0 );
          all_angles.push_back( -44.0 );
          all_angles.push_back( -55.0 );
          all_angles.push_back( -66.0 );

          hand.SetAxisTargetAngle( hand.all_axes, all_angles );


          <span class="comment">// Set target axis angle of axis 3 to -42:</span>
          hand.SetAxisTargetAngle( 3, -42.0 );

          <span class="comment">// Set target angle of for axis 0, 4 and 2 to 0.0, -44.4 and -2.22 respectively:</span>
          std::vector&lt;int&gt; axes042;
          axes042.push_back( 0 );
          axes042.push_back( 4 );
          axes042.push_back( 2 );
          std::vector&lt;double&gt; angles042;
          angles042.push_back( 0.0 );
          angles042.push_back( -44.4 );
          angles042.push_back( -2.22 );

          hand.SetAxisTargetAngle( axes042, angles042 );


          <span class="comment">// Set target axis angle of all axes to 0 (home-position)</span>
          hand.SetAxisTargetAngle( hand.All, 0.0 );
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="079b2a7c493eab45984ea64b773124a3"></a><!-- doxytag: member="SDH::cSDH::SetAxisTargetAngle" ref="079b2a7c493eab45984ea64b773124a3" args="(int iAxis, double angle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cSDH::SetAxisTargetAngle           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iAxis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>angle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#f14021a2e8c95353d64f86b9208a0904">SetAxisTargetAngle(std::vector&lt;int&gt;const&amp;,std::vector&lt;double&gt;const&amp;)</a>, just for a single axis <em>iAxis</em> and a single angle <em>angle</em>, see there for details and examples.<p>
If <em>iAxis</em> is <a class="el" href="class_s_d_h_1_1c_s_d_h_base.html#ab61ed07c53bf24bc87ff5103e74f45a8e09b2cc8bc776a705cd2665fc555881" title="A meta-value that means &quot;access all possible values&quot;.">All</a> then <em>motor_current</em> is set for all axes. 
</div>
</div><p>
<a class="anchor" name="f3f5d34fe7fdabb0d6822a79e856e5d1"></a><!-- doxytag: member="SDH::cSDH::GetAxisTargetAngle" ref="f3f5d34fe7fdabb0d6822a79e856e5d1" args="(std::vector&lt; int &gt; const &amp;axes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; cSDH::GetAxisTargetAngle           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>axes</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the target angle(s) of axis(axes).<p>
The currently set target angles are read from the SDH.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axes</em>&nbsp;</td><td>- A vector of axis indices to access.</td></tr>
  </table>
</dl>
<ul>
<li>The indices in <em>axes</em> are checked if they are valid axis indices.</li><li>If <b>any</b> axis index is invalid then a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>A vector of the target angles of the selected axes.</li><li>The values are converted to the selected external unit system using the configured <a class="el" href="class_s_d_h_1_1c_s_d_h.html#bcb9da3cf0236c0e09cdd7af1a78225e" title="unit convert for (axis) angles: default = SDH::cSDH::uc_angle_degrees">uc_angle</a> unit converter object.</li><li>The order of the elements of the <em>axes</em> vector and the returned values vector <em>rv</em> matches. I.e. <code>rv</code>[i] will be the value of axis <code>axes</code>[i] (not axis <code>i</code>).</li></ul>
</dd></dl>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#37e84aed060f18bd0581a491cf7c3123">GetAxisTargetAngle(int)</a> for an overloaded variant to access a single axis.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming "hand" is a cSDH object ...</span>

          <span class="comment">// Get target axis angle of all axes</span>
          std::vector&lt;double&gt; v = hand.GetAxisTargetAngle( hand.all_axes );
          <span class="comment">// now v is something like {0.0, 0.0, 42.0, 0.0, 47.11, 0,0, 0.0}</span>

          <span class="comment">// Get target axis angle of axis 2</span>
          <span class="keywordtype">double</span> v2 = hand.GetAxisTargetAngle( 2 );
          <span class="comment">// v2 is now something like 42.0</span>


          <span class="comment">// Get target axis angle of axis 2 and 4</span>
          std::vector&lt;int&gt; axes24;
          axes24.push_back( 2 );
          axes24.push_back( 4 );

          v = hand.GetAxisTargetAngle( axes24 );
          <span class="comment">// now v is something like {42.0, 47.11}</span>
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="37e84aed060f18bd0581a491cf7c3123"></a><!-- doxytag: member="SDH::cSDH::GetAxisTargetAngle" ref="37e84aed060f18bd0581a491cf7c3123" args="(int iAxis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cSDH::GetAxisTargetAngle           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iAxis</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#f3f5d34fe7fdabb0d6822a79e856e5d1">GetAxisTargetAngle(std::vector&lt;int&gt;const&amp;)</a>, just for a single axis <em>iAxis</em> and returning a single angle, see there for details and examples. 
</div>
</div><p>
<a class="anchor" name="9a429222a54007b1e966cd6d2001c10a"></a><!-- doxytag: member="SDH::cSDH::GetAxisActualAngle" ref="9a429222a54007b1e966cd6d2001c10a" args="(std::vector&lt; int &gt; const &amp;axes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; cSDH::GetAxisActualAngle           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>axes</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the current actual angle(s) of axis(axes).<p>
The actual angles are read from the SDH.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axes</em>&nbsp;</td><td>- A vector of axis indices to access.</td></tr>
  </table>
</dl>
<ul>
<li>The indices in <em>axes</em> are checked if they are valid axis indices.</li><li>If <b>any</b> axis index is invalid then a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>A vector of the actual angles of the selected axes.</li><li>The values are converted to the selected external unit system using the configured <a class="el" href="class_s_d_h_1_1c_s_d_h.html#bcb9da3cf0236c0e09cdd7af1a78225e" title="unit convert for (axis) angles: default = SDH::cSDH::uc_angle_degrees">uc_angle</a> unit converter object.</li><li>The order of the elements of the <em>axes</em> vector and the returned values vector <em>rv</em> matches. I.e. <code>rv</code>[i] will be the value of axis <code>axes</code>[i] (not axis <code>i</code>).</li></ul>
</dd></dl>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#318a0395f2483fba7fd232365b610c70">GetAxisActualAngle(int)</a> for an overloaded variant to access a single axis.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming "hand" is a cSDH object ...</span>

          <span class="comment">// Get actual axis angle of all axes</span>
          std::vector&lt;double&gt; v = hand.GetAxisActualAngle( hand.all_axes );
          <span class="comment">// now v is something like {0.0, 0.0, 42.0, 0.0, 47.11, 0,0, 0.0}</span>

          <span class="comment">// Get actual axis angle of axis 2</span>
          <span class="keywordtype">double</span> v2 = hand.GetAxisActualAngle( 2 );
          <span class="comment">// 2 is now something like 42.0</span>


          <span class="comment">// Get actual axis angle of axis 2 and 4</span>
          std::vector&lt;int&gt; axes24;
          axes24.push_back( 2 );
          axes24.push_back( 4 );

          v = hand.GetAxisActualAngle( axes24 );
          <span class="comment">// now v is something like {42.0, 47.11}</span>
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="318a0395f2483fba7fd232365b610c70"></a><!-- doxytag: member="SDH::cSDH::GetAxisActualAngle" ref="318a0395f2483fba7fd232365b610c70" args="(int iAxis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cSDH::GetAxisActualAngle           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iAxis</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#9a429222a54007b1e966cd6d2001c10a">GetAxisActualAngle(std::vector&lt;int&gt;const&amp;)</a>, just for a single axis <em>iAxis</em> and returning a single angle, see there for details and examples. 
</div>
</div><p>
<a class="anchor" name="9f27d454810035a480e2989ed471fcad"></a><!-- doxytag: member="SDH::cSDH::SetAxisTargetVelocity" ref="9f27d454810035a480e2989ed471fcad" args="(std::vector&lt; int &gt; const &amp;axes, std::vector&lt; double &gt; const &amp;velocities)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cSDH::SetAxisTargetVelocity           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>axes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>velocities</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the target velocity(s) for axis(axes).<p>
The target velocities are stored in the SDH. The time at which a new target velocities will take effect depends on the current axis controller type:<ul>
<li>in eCT_POSE controller type the new target velocities will not take effect until an additional move command is sent: <a class="el" href="class_s_d_h_1_1c_s_d_h.html#a52181be374dd44517e0b2fef09130c1">MoveAxis()</a>, <a class="el" href="class_s_d_h_1_1c_s_d_h.html#67baba337dd775a0c8798b7f82738d6d">MoveFinger()</a>, <a class="el" href="class_s_d_h_1_1c_s_d_h.html#91ecc6595c68f2c6f00d31ffaea22a60">MoveHand()</a></li><li>in eCT_VELOCITY and eCT_VELOCITY_ACCELERATION controller type the new target velocity will take effect immediately. This means that in eCT_VELOCITY_ACCELERATION controller type the accelerations must be set with <a class="el" href="class_s_d_h_1_1c_s_d_h.html#4849b377325f407b464ebcd324f4510b">SetAxisTargetAcceleration()</a> <b>before</b> calling <a class="el" href="class_s_d_h_1_1c_s_d_h.html#9f27d454810035a480e2989ed471fcad">SetAxisTargetVelocity()</a>.</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axes</em>&nbsp;</td><td>- A vector of axis indices to access. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>velocities</em>&nbsp;</td><td>- A vector of axis target angles to set. If any of the numbers in the vector is <code>NaN</code> (Not a Number) then the currently set axis target velocity will be kept for the corresponding axis. The value(s) are expected in the configured angular velocity unit system <a class="el" href="class_s_d_h_1_1c_s_d_h.html#81c208eb64b0954dfef4182575ff6bc9" title="unit convert for (axis) angular velocities: default = SDH::cSDH::uc_angular_velocity_degrees_per_sec...">uc_angular_velocity</a>.</td></tr>
  </table>
</dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd><ul>
<li>The lengths of the <em>axes</em> and <em>velocities</em> vector must match.</li><li>The indices can be given in any order, but the order of their elements must match, i.e. <code>velocities</code>[i] will be applied to axis <code>axes</code>[i] (not axis <code>i</code>).</li><li>The indices are checked if they are valid axis indices.</li><li>The velocities are checked if they are in the allowed range [0 .. <a class="el" href="class_s_d_h_1_1c_s_d_h.html#3ec3baeb713e23b6585be21d54f43b21" title="Maximum allowed axis velocity (in internal units (degrees/second)), including the...">f_max_velocity_v</a>], i.e. it is checked that <code>velocities</code>[i], converted to internal units, is in <code></code>[0 .. <code>f_max_velocity_v</code>[axes[i]]].</li><li>If <b>any</b> index or value is invalid then <b>none</b> of the specified values is sent to the SDH, instead a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
</dd></dl>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#2bde8d04f76fe8c56a076f2843616e40">SetAxisTargetVelocity(int,double)</a> for an overloaded variant to set a single axis target velocity or to set the same target velocity for all axes.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming "hand" is a cSDH object ...</span>

          <span class="comment">// Set target axis velocity of all axes to the given values:</span>
          std::vector&lt;double&gt; all_velocities;
          all_velocities.push_back( 0.0 );
          all_velocities.push_back( 11.0 );
          all_velocities.push_back( 22.0 );
          all_velocities.push_back( 33.0 );
          all_velocities.push_back( 44.0 );
          all_velocities.push_back( 55.0 );
          all_velocities.push_back( 66.0 );

          hand.SetAxisTargetVelocity( hand.all_axes, all_velocities );


          <span class="comment">// Set target axis velocity of axis 3 to 42/s:</span>
          hand.SetAxisTargetVelocity( 3, 42.0 );

          <span class="comment">// Set target velocity of for axis 0,4 and 2 to 0.0/s, 44.4/s and 2.22/s respectively:</span>
          std::vector&lt;int&gt; axes042;
          axes042.push_back( 0 );
          axes042.push_back( 4 );
          axes042.push_back( 2 );
          std::vector&lt;double&gt; velocities042;
          velocities042.push_back( 0.0 );
          velocities042.push_back( 44.4 );
          velocities042.push_back( 2.22 );

          hand.SetAxisTargetVelocity( axes042, velocities042 );


          <span class="comment">// Set target axis velocity of all axes to 47.11/s</span>
          hand.SetAxisTargetVelocity( hand.All, 47.11 );
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="2bde8d04f76fe8c56a076f2843616e40"></a><!-- doxytag: member="SDH::cSDH::SetAxisTargetVelocity" ref="2bde8d04f76fe8c56a076f2843616e40" args="(int iAxis, double velocity)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cSDH::SetAxisTargetVelocity           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iAxis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>velocity</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#9f27d454810035a480e2989ed471fcad">SetAxisTargetVelocity(std::vector&lt;int&gt;const&amp;,std::vector&lt;double&gt;const&amp;)</a>, just for a single axis <em>iAxis</em> and a single velocity <em>velocity</em>, see there for details and examples. 
</div>
</div><p>
<a class="anchor" name="7bab675982757994c774a9ed1baa30b3"></a><!-- doxytag: member="SDH::cSDH::GetAxisTargetVelocity" ref="7bab675982757994c774a9ed1baa30b3" args="(std::vector&lt; int &gt; const &amp;axes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; cSDH::GetAxisTargetVelocity           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>axes</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the target velocity(s) of axis(axes).<p>
The currently set target velocities are read from the SDH.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axes</em>&nbsp;</td><td>- A vector of axis indices to access.</td></tr>
  </table>
</dl>
<ul>
<li>The indices in <em>axes</em> are checked if they are valid axis indices.</li><li>If <b>any</b> axis index is invalid then a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>A vector of the target velocities of the selected axes.</li><li>The values are converted to the selected external unit system using the configured <a class="el" href="class_s_d_h_1_1c_s_d_h.html#81c208eb64b0954dfef4182575ff6bc9" title="unit convert for (axis) angular velocities: default = SDH::cSDH::uc_angular_velocity_degrees_per_sec...">uc_angular_velocity</a> unit converter object.</li><li>The order of the elements of the <em>axes</em> vector and the returned values vector <em>rv</em> matches. I.e. <code>rv</code>[i] will be the value of axis <code>axes</code>[i] (not axis <code>i</code>).</li></ul>
</dd></dl>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#7ceceb1884ef7e5b3d601bf8174e540b">GetAxisTargetVelocity(int)</a> for an overloaded variant to access a single axis.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming "hand" is a cSDH object ...</span>

          <span class="comment">// Get target axis velocity of all axes</span>
          std::vector&lt;double&gt; v = hand.GetAxisTargetVelocity( hand.all_axes );
          <span class="comment">// now v is something like {0.0, 0.0, 42.0, 0.0, 47.11, 0,0, 0.0}</span>

          <span class="comment">// Get target axis velocity of axis 2</span>
          <span class="keywordtype">double</span> v2 = hand.GetAxisTargetVelocity( 2 );
          <span class="comment">// v2 is now something like 42.0</span>


          <span class="comment">// Get target axis velocity of axis 2 and 4</span>
          std::vector&lt;int&gt; axes24;
          axes24.push_back( 2 );
          axes24.push_back( 4 );

          v = hand.GetAxisTargetVelocity( axes24 );
          <span class="comment">// now v is something like {42.0, 47.11}</span>
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="7ceceb1884ef7e5b3d601bf8174e540b"></a><!-- doxytag: member="SDH::cSDH::GetAxisTargetVelocity" ref="7ceceb1884ef7e5b3d601bf8174e540b" args="(int iAxis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cSDH::GetAxisTargetVelocity           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iAxis</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#7bab675982757994c774a9ed1baa30b3">GetAxisTargetVelocity(std::vector&lt;int&gt;const&amp;)</a>, just for a single axis <em>iAxis</em> and returning a single velocity, see there for details and examples. 
</div>
</div><p>
<a class="anchor" name="9824173a1618ef9486349a2b99196242"></a><!-- doxytag: member="SDH::cSDH::GetAxisLimitVelocity" ref="9824173a1618ef9486349a2b99196242" args="(std::vector&lt; int &gt; const &amp;axes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; cSDH::GetAxisLimitVelocity           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>axes</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the velocity limit(s) of axis(axes).<p>
The velocity limit(s) are read from the SDH.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axes</em>&nbsp;</td><td>- A vector of axis indices to access.</td></tr>
  </table>
</dl>
<ul>
<li>The indices in <em>axes</em> are checked if they are valid axis indices.</li><li>If <b>any</b> axis index is invalid then a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>A vector of the velocity limits of the selected axes.</li><li>The values are converted to the selected external unit system using the configured <a class="el" href="class_s_d_h_1_1c_s_d_h.html#81c208eb64b0954dfef4182575ff6bc9" title="unit convert for (axis) angular velocities: default = SDH::cSDH::uc_angular_velocity_degrees_per_sec...">uc_angular_velocity</a> unit converter object.</li><li>The order of the elements of the <em>axes</em> vector and the returned values vector <em>rv</em> matches. I.e. <code>rv</code>[i] will be the value of axis <code>axes</code>[i] (not axis <code>i</code>).</li></ul>
</dd></dl>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#0ca4c1473934ba6ed468d68be66f5fe9">GetAxisLimitVelocity(int)</a> for an overloaded variant to access a single axis.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming "hand" is a cSDH object ...</span>

          <span class="comment">// Get axis velocity limits of all axes</span>
          std::vector&lt;double&gt; v = hand.GetAxisLimitVelocity( hand.all_axes );
          <span class="comment">// now v is something like {81.0, 140.0, 120.0, 140.0, 120.0, 140.0, 120.0}</span>

          <span class="comment">// Get axis velocity limit of axis 2</span>
          <span class="keywordtype">double</span> v2 = hand.GetAxisLimitVelocity( 2 );
          <span class="comment">// v2 is now something like 120.0</span>


          <span class="comment">// Get axis velocity limits of axis 2 and 4</span>
          std::vector&lt;int&gt; axes24;
          axes24.push_back( 2 );
          axes24.push_back( 4 );

          v = hand.GetAxisLimitVelocity( axes24 );
          <span class="comment">// now v is something like {120.0,120.0}</span>
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="0ca4c1473934ba6ed468d68be66f5fe9"></a><!-- doxytag: member="SDH::cSDH::GetAxisLimitVelocity" ref="0ca4c1473934ba6ed468d68be66f5fe9" args="(int iAxis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cSDH::GetAxisLimitVelocity           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iAxis</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#9824173a1618ef9486349a2b99196242">GetAxisLimitVelocity(std::vector&lt;int&gt;const&amp;)</a>, just for a single axis <em>iAxis</em> and returning a single velocity limit, see there for details and examples. 
</div>
</div><p>
<a class="anchor" name="d70ae2e08313f32a6c2f80061f4ff1a3"></a><!-- doxytag: member="SDH::cSDH::GetAxisLimitAcceleration" ref="d70ae2e08313f32a6c2f80061f4ff1a3" args="(std::vector&lt; int &gt; const &amp;axes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; cSDH::GetAxisLimitAcceleration           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>axes</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the acceleration limit(s) of axis(axes).<p>
The acceleration limit(s) are read from the SDH.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axes</em>&nbsp;</td><td>- A vector of axis indices to access.</td></tr>
  </table>
</dl>
<ul>
<li>The indices in <em>axes</em> are checked if they are valid axis indices.</li><li>If <b>any</b> axis index is invalid then a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>A vector of the acceleration limits of the selected axes.</li><li>The values are converted to the selected external unit system using the configured <a class="el" href="class_s_d_h_1_1c_s_d_h.html#8dc039c618c3383d5fefd85d41866f9e" title="unit convert for (axis) angular accelerations: default = SDH::cSDH::uc_angular_acceleration_degrees_...">uc_angular_acceleration</a> unit converter object.</li><li>The order of the elements of the <em>axes</em> vector and the returned values vector <em>rv</em> matches. I.e. <code>rv</code>[i] will be the value of axis <code>axes</code>[i] (not axis <code>i</code>).</li></ul>
</dd></dl>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#45d26862cee701b9f45bfe7c6f1e9c4c">GetAxisLimitAcceleration(int)</a> for an overloaded variant to access a single axis.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming "hand" is a cSDH object ...</span>

          <span class="comment">// Get axis acceleration limits of all axes</span>
          std::vector&lt;double&gt; v = hand.GetAxisLimitAcceleration( hand.all_axes );
          <span class="comment">// now v is something like {81.0, 140.0, 120.0, 140.0, 120.0, 140.0, 120.0}</span>

          <span class="comment">// Get axis acceleration limit of axis 2</span>
          <span class="keywordtype">double</span> v2 = hand.GetAxisLimitAcceleration( 2 );
          <span class="comment">// v2 is now something like 120.0</span>


          <span class="comment">// Get axis acceleration limits of axis 2 and 4</span>
          std::vector&lt;int&gt; axes24;
          axes24.push_back( 2 );
          axes24.push_back( 4 );

          v = hand.GetAxisLimitAcceleration( axes24 );
          <span class="comment">// now v is something like {120.0,120.0}</span>
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="45d26862cee701b9f45bfe7c6f1e9c4c"></a><!-- doxytag: member="SDH::cSDH::GetAxisLimitAcceleration" ref="45d26862cee701b9f45bfe7c6f1e9c4c" args="(int iAxis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cSDH::GetAxisLimitAcceleration           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iAxis</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#d70ae2e08313f32a6c2f80061f4ff1a3">GetAxisLimitAcceleration(std::vector&lt;int&gt;const&amp;)</a>, just for a single axis <em>iAxis</em> and returning a single acceleration limit, see there for details and examples. 
</div>
</div><p>
<a class="anchor" name="3e88d83d6cc7e03362bfad2da9d5630e"></a><!-- doxytag: member="SDH::cSDH::GetAxisActualVelocity" ref="3e88d83d6cc7e03362bfad2da9d5630e" args="(std::vector&lt; int &gt;const &amp;axes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; cSDH::GetAxisActualVelocity           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt;const &amp;&nbsp;</td>
          <td class="paramname"> <em>axes</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the actual velocity(s) of axis(axes).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axes</em>&nbsp;</td><td>- A vector of axis indices to access.</td></tr>
  </table>
</dl>
<ul>
<li>The indices in <em>axes</em> are checked if they are valid axis indices.</li><li>If <b>any</b> axis index is invalid then a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>A vector of the actual velocities of the selected axes.</li><li>The values are converted to the selected external unit system using the configured <a class="el" href="class_s_d_h_1_1c_s_d_h.html#81c208eb64b0954dfef4182575ff6bc9" title="unit convert for (axis) angular velocities: default = SDH::cSDH::uc_angular_velocity_degrees_per_sec...">uc_angular_velocity</a> unit converter object.</li><li>The order of the elements of the <em>axes</em> vector and the returned values vector <em>rv</em> matches. I.e. <code>rv</code>[i] will be the value of axis <code>axes</code>[i] (not axis <code>i</code>).</li></ul>
</dd></dl>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#dbf81a0ec719384676d3e4817a308edc">GetAxisActualVelocity(int)</a> for an overloaded variant to access a single axis.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming "hand" is a cSDH object ...</span>

          <span class="comment">// Get actual axis velocity of all axes</span>
          std::vector&lt;double&gt; v = hand.GetAxisActualVelocity( hand.all_axes );
          <span class="comment">// now v is something like {0.1, 0.2, 0.3, 13.2, 0.5, 0.0, 0.7}</span>

          <span class="comment">// Get actual axis velocity of axis 2 and 4</span>
          std::vector&lt;int&gt; axes24;
          axes24.push_back( 2 );
          axes24.push_back( 4 );
          v = hand.GetAxisActualVelocity( axes24 );
          <span class="comment">// now v is something like {13.2, 0.0}</span>

          <span class="comment">// Get actual axis velocity of axis 2</span>
          <span class="keywordtype">double</span> v3 = hand.GetAxisActualVelocity( 2 );
          <span class="comment">// v3 is now something like 13.2</span>
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="dbf81a0ec719384676d3e4817a308edc"></a><!-- doxytag: member="SDH::cSDH::GetAxisActualVelocity" ref="dbf81a0ec719384676d3e4817a308edc" args="(int iAxis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cSDH::GetAxisActualVelocity           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iAxis</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#3e88d83d6cc7e03362bfad2da9d5630e">GetAxisActualVelocity(std::vector&lt;int&gt;const&amp;)</a>, just for a single axis <em>iAxis</em> and returning a single velocity, see there for details and examples. 
</div>
</div><p>
<a class="anchor" name="3e741ff4ff6bcb387f32e9ff9928e45b"></a><!-- doxytag: member="SDH::cSDH::GetAxisReferenceVelocity" ref="3e741ff4ff6bcb387f32e9ff9928e45b" args="(std::vector&lt; int &gt;const &amp;axes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; cSDH::GetAxisReferenceVelocity           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt;const &amp;&nbsp;</td>
          <td class="paramname"> <em>axes</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the current reference velocity(s) of axis(axes). (This velocity is used internally by the SDH in eCT_VELOCITY_ACCELERATION mode).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axes</em>&nbsp;</td><td>- A vector of axis indices to access.</td></tr>
  </table>
</dl>
<ul>
<li>The indices in <em>axes</em> are checked if they are valid axis indices.</li><li>If <b>any</b> axis index is invalid then a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>A vector of the reference velocities of the selected axes.</li><li>The values are converted to the selected external unit system using the configured <a class="el" href="class_s_d_h_1_1c_s_d_h.html#81c208eb64b0954dfef4182575ff6bc9" title="unit convert for (axis) angular velocities: default = SDH::cSDH::uc_angular_velocity_degrees_per_sec...">uc_angular_velocity</a> unit converter object.</li><li>The order of the elements of the <em>axes</em> vector and the returned values vector <em>rv</em> matches. I.e. <code>rv</code>[i] will be the value of axis <code>axes</code>[i] (not axis <code>i</code>).</li></ul>
</dd></dl>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#084b4ef840f147ac7cd4dfa5532cffc3">GetAxisReferenceVelocity(int)</a> for an overloaded variant to access a single axis.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming "hand" is a cSDH object ...</span>

          <span class="comment">// Switch to "velocity control with acceleration ramp" controller mode first.</span>
          <span class="comment">// (When in another controller mode like the default eCT_POSE,</span>
          <span class="comment">//  then the reference velocities will not be valid):</span>
          hand.SetController( <a class="code" href="class_s_d_h_1_1c_s_d_h_base.html#610f29a16806030c12e25bf83d89abbd82ae7fbb40d0b4eb851ea71a6a80e7bb" title="velocity controller with acceleration ramp, velocities and accelerations of axes...">eCT_VELOCITY_ACCELERATION</a> );

          <span class="comment">// Get reference axis velocity of all axes</span>
          std::vector&lt;double&gt; v = hand.GetAxisReferenceVelocity( hand.all_axes );
          <span class="comment">// now v is something like {0.1, 0.2, 0.3, 13.2, 0.5, 0.0, 0.7}</span>

          <span class="comment">// Get reference axis velocity of axis 2 and 4</span>
          std::vector&lt;int&gt; axes24;
          axes24.push_back( 2 );
          axes24.push_back( 4 );
          v = hand.GetAxisReferenceVelocity( axes24 );
          <span class="comment">// now v is something like {13.2, 0.0}</span>

          <span class="comment">// Get reference axis velocity of axis 2</span>
          <span class="keywordtype">double</span> v3 = hand.GetAxisReferenceVelocity( 2 );
          <span class="comment">// v3 is now something like 13.2</span>
</pre></div></dd></dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd><ul>
<li>the underlying rvel command of the SDH firmware is not available in firmwares prior to 0.0.2.6. For such hands calling rvel will fail miserably.</li><li>The availability of an appropriate SDH firmware is <b>not</b> checked here due to performance losses when this function is used often.</li></ul>
</dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="084b4ef840f147ac7cd4dfa5532cffc3"></a><!-- doxytag: member="SDH::cSDH::GetAxisReferenceVelocity" ref="084b4ef840f147ac7cd4dfa5532cffc3" args="(int iAxis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cSDH::GetAxisReferenceVelocity           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iAxis</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#3e741ff4ff6bcb387f32e9ff9928e45b">GetAxisReferenceVelocity(std::vector&lt;int&gt;const&amp;)</a>, just for a single axis <em>iAxis</em> and returning a single velocity, see there for details and examples. 
</div>
</div><p>
<a class="anchor" name="4849b377325f407b464ebcd324f4510b"></a><!-- doxytag: member="SDH::cSDH::SetAxisTargetAcceleration" ref="4849b377325f407b464ebcd324f4510b" args="(std::vector&lt; int &gt;const &amp;axes, std::vector&lt; double &gt;const &amp;accelerations)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cSDH::SetAxisTargetAcceleration           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt;const &amp;&nbsp;</td>
          <td class="paramname"> <em>axes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;const &amp;&nbsp;</td>
          <td class="paramname"> <em>accelerations</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the target acceleration(s) for axis(axes).<p>
The target accelerations are stored in the SDH and are used only for:<ul>
<li>the eCT_POSE controller type with eVP_RAMP velocity profile</li><li>the eCT_VELOCITY_ACCELERATION controller type</li></ul>
<p>
Setting the target acceleration will not affect an ongoing movement, nor will it start a new movement. To take effect an additional command must be sent:<ul>
<li>in eCT_POSE controller type a move command: <a class="el" href="class_s_d_h_1_1c_s_d_h.html#a52181be374dd44517e0b2fef09130c1">MoveAxis()</a> <a class="el" href="class_s_d_h_1_1c_s_d_h.html#67baba337dd775a0c8798b7f82738d6d">MoveFinger()</a> <a class="el" href="class_s_d_h_1_1c_s_d_h.html#91ecc6595c68f2c6f00d31ffaea22a60">MoveHand()</a></li><li>in eCT_VELOCITY_ACCELERATION controller type the velocity must be set: <a class="el" href="class_s_d_h_1_1c_s_d_h.html#9f27d454810035a480e2989ed471fcad">SetAxisTargetVelocity()</a></li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axes</em>&nbsp;</td><td>- A vector of axis indices to access. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>accelerations</em>&nbsp;</td><td>- A vector of axis target accelerations to set. If any of the numbers in the vector is <code>NaN</code> (Not a Number) then the currently set axis target angle will be kept for the corresponding axis. The value(s) are expected in the configured angular acceleration unit system <a class="el" href="class_s_d_h_1_1c_s_d_h.html#8dc039c618c3383d5fefd85d41866f9e" title="unit convert for (axis) angular accelerations: default = SDH::cSDH::uc_angular_acceleration_degrees_...">uc_angular_acceleration</a>.</td></tr>
  </table>
</dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd><ul>
<li>The lengths of the <em>axes</em> and <em>accelerations</em> vector must match.</li><li>The indices can be given in any order, but the order of their elements must match, i.e. <code>accelerations</code>[i] will be applied to axis <code>axes</code>[i] (not axis <code>i</code>).</li><li>The indices are checked if they are valid axis indices.</li><li>The accelerations are checked if they are in the allowed range [0 .. <a class="el" href="class_s_d_h_1_1c_s_d_h.html#3ec3baeb713e23b6585be21d54f43b21" title="Maximum allowed axis velocity (in internal units (degrees/second)), including the...">f_max_velocity_v</a>], i.e. it is checked that <code>accelerations</code>[i], converted to internal units, is in <code></code>[0 .. <code>f_max_velocity_v</code>[axes[i]]].</li><li>If <b>any</b> index or value is invalid then <b>none</b> of the specified values is sent to the SDH, instead a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
</dd></dl>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#d1a4568a8808ea3ea824cc15faffc127">SetAxisTargetAcceleration(int,double)</a> for an overloaded variant to set a single axis target acceleration or to set the same target acceleration for all axes.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming "hand" is a cSDH object ...</span>

          <span class="comment">// Set target axis acceleration of all axes to the given values:</span>
          std::vector&lt;double&gt; all_accelerations;
          all_accelerations.push_back( 100.0 );
          all_accelerations.push_back( 101.0 );
          all_accelerations.push_back( 102.0 );
          all_accelerations.push_back( 103.0 );
          all_accelerations.push_back( 104.0 );
          all_accelerations.push_back( 105.0 );
          all_accelerations.push_back( 106.0 );

          hand.SetAxisTargetAcceleration( hand.all_axes, all_accelerations );


          <span class="comment">// Set target axis acceleration of axis 3 to 420/s:</span>
          hand.SetAxisTargetAcceleration( 3, 420.0 );

          <span class="comment">// Set target acceleration of for axis 0,4 and 2 to 0.0/s, 444.0/s and 222/s respectively:</span>
          std::vector&lt;int&gt; axes042;
          axes042.push_back( 0 );
          axes042.push_back( 4 );
          axes042.push_back( 2 );
          std::vector&lt;double&gt; accelerations042;
          accelerations042.push_back( 100.0 );
          accelerations042.push_back( 104.0 );
          accelerations042.push_back( 102.0 );

          hand.SetAxisTargetAcceleration( axes042, accelerations042 );


          <span class="comment">// Set target axis acceleration of all axes to 142.1/s</span>
          hand.SetAxisTargetAcceleration( hand.All, 142.1 );
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="d1a4568a8808ea3ea824cc15faffc127"></a><!-- doxytag: member="SDH::cSDH::SetAxisTargetAcceleration" ref="d1a4568a8808ea3ea824cc15faffc127" args="(int iAxis, double acceleration)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cSDH::SetAxisTargetAcceleration           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iAxis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>acceleration</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#4849b377325f407b464ebcd324f4510b">SetAxisTargetAcceleration(std::vector&lt;int&gt;const&amp;,std::vector&lt;double&gt;const&amp;)</a>, just for a single axis <em>iAxis</em> and a single acceleration <em>acceleration</em>, see there for details and examples. 
</div>
</div><p>
<a class="anchor" name="8148b4f44c2631ce0f7b1e2dfc450831"></a><!-- doxytag: member="SDH::cSDH::GetAxisTargetAcceleration" ref="8148b4f44c2631ce0f7b1e2dfc450831" args="(std::vector&lt; int &gt;const &amp;axes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; cSDH::GetAxisTargetAcceleration           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt;const &amp;&nbsp;</td>
          <td class="paramname"> <em>axes</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the target acceleration(s) of axis(axes).<p>
The currently set target accelerations are read from the SDH.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axes</em>&nbsp;</td><td>- A vector of axis indices to access.</td></tr>
  </table>
</dl>
<ul>
<li>The indices in <em>axes</em> are checked if they are valid axis indices.</li><li>If <b>any</b> axis index is invalid then a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>A vector of the target accelerations of the selected axes.</li><li>The values are converted to the selected external unit system using the configured <a class="el" href="class_s_d_h_1_1c_s_d_h.html#8dc039c618c3383d5fefd85d41866f9e" title="unit convert for (axis) angular accelerations: default = SDH::cSDH::uc_angular_acceleration_degrees_...">uc_angular_acceleration</a> unit converter object.</li><li>The order of the elements of the <em>axes</em> vector and the returned values vector <em>rv</em> matches. I.e. <code>rv</code>[i] will be the value of axis <code>axes</code>[i] (not axis <code>i</code>).</li></ul>
</dd></dl>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#07c6b856a2dd244036686aaeb40965cd">GetAxisTargetAcceleration(int)</a> for an overloaded variant to access a single axis.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming "hand" is a cSDH object ...</span>

          <span class="comment">// Get target axis acceleration of all axes</span>
          std::vector&lt;double&gt; v = hand.GetAxisTargetAcceleration( hand.all_axes );
          <span class="comment">// now v is something like {100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0}</span>

          <span class="comment">// Get target axis acceleration of axis 2</span>
          <span class="keywordtype">double</span> v2 = hand.GetAxisTargetAcceleration( 2 );
          <span class="comment">// v2 is now something like 100.0</span>


          <span class="comment">// Get target axis acceleration of axis 2 and 4</span>
          std::vector&lt;int&gt; axes24;
          axes24.push_back( 2 );
          axes24.push_back( 4 );

          v = hand.GetAxisTargetAcceleration( axes24 );
          <span class="comment">// now v is something like {100.0, 100.0}</span>
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="07c6b856a2dd244036686aaeb40965cd"></a><!-- doxytag: member="SDH::cSDH::GetAxisTargetAcceleration" ref="07c6b856a2dd244036686aaeb40965cd" args="(int iAxis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cSDH::GetAxisTargetAcceleration           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iAxis</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#8148b4f44c2631ce0f7b1e2dfc450831">GetAxisTargetAcceleration(std::vector&lt;int&gt;const&amp;)</a>, just for a single axis <em>iAxis</em> and returning a single acceleration, see there for details and examples. 
</div>
</div><p>
<a class="anchor" name="c2b8ad56584f8ac5a5d0ff010ef8fc54"></a><!-- doxytag: member="SDH::cSDH::GetAxisMinAngle" ref="c2b8ad56584f8ac5a5d0ff010ef8fc54" args="(std::vector&lt; int &gt; const &amp;axes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; cSDH::GetAxisMinAngle           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>axes</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the minimum angle(s) of axis(axes).<p>
The minimum angles are currently not read from the SDH, but are stored in the library.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axes</em>&nbsp;</td><td>- A vector of axis indices to access.</td></tr>
  </table>
</dl>
<ul>
<li>The indices in <em>axes</em> are checked if they are valid axis indices.</li><li>If <b>any</b> axis index is invalid then a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>A vector of the min angles of the selected axes.</li><li>The values are converted to the selected external unit system using the configured <a class="el" href="class_s_d_h_1_1c_s_d_h.html#bcb9da3cf0236c0e09cdd7af1a78225e" title="unit convert for (axis) angles: default = SDH::cSDH::uc_angle_degrees">uc_angle</a> unit converter object.</li><li>The order of the elements of the <em>axes</em> vector and the returned values vector <em>rv</em> matches. I.e. <code>rv</code>[i] will be the value of axis <code>axes</code>[i] (not axis <code>i</code>).</li></ul>
</dd></dl>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#301351d4a00cc942c6b3cafd5b6f0d2d">GetAxisMinAngle(int)</a> for an overloaded variant to access a single axis.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming "hand" is a cSDH object ...</span>

          <span class="comment">// Get minimum axis angles of all axes</span>
          std::vector&lt;double&gt; v = hand.GetAxisMinAngle( hand.all_axes );
          <span class="comment">// now v is something like {0.0, -90.0, -90.0, -90.0, -90.0, -90.0, -90.0}</span>

          <span class="comment">// Get minimum axis angle of axis 3</span>
          <span class="keywordtype">double</span> v3 = hand.GetAxisMinAngle( 3 );
          <span class="comment">// v3 is now something like -90.0</span>

          <span class="comment">// Get minimum axis angle of axis 2 and 4</span>
          std::vector&lt;int&gt; axes24;
          axes24.push_back( 2 );
          axes24.push_back( 4 );

          v = hand.GetAxisMinAngle( axes24 );
          <span class="comment">// now v is something like {-90.0, -90.0}</span>


          <span class="comment">// Or if you change the angle unit system:</span>
          hand.UseRadians();

          v = hand.GetAxisMinAngle( hand.all_axes );
          <span class="comment">// now v is something like {0.0, -1.5707963267948966, -1.5707963267948966, -1.5707963267948966, -1.5707963267948966, -1.5707963267948966, -1.5707963267948966}</span>
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="301351d4a00cc942c6b3cafd5b6f0d2d"></a><!-- doxytag: member="SDH::cSDH::GetAxisMinAngle" ref="301351d4a00cc942c6b3cafd5b6f0d2d" args="(int iAxis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cSDH::GetAxisMinAngle           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iAxis</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#c2b8ad56584f8ac5a5d0ff010ef8fc54">GetAxisMinAngle(std::vector&lt;int&gt;const&amp;)</a>, just for a single axis <em>iAxis</em> and returning a single minimum angle, see there for details and examples. 
</div>
</div><p>
<a class="anchor" name="d12978c317ec5a3ea785453e8907e46f"></a><!-- doxytag: member="SDH::cSDH::GetAxisMaxAngle" ref="d12978c317ec5a3ea785453e8907e46f" args="(std::vector&lt; int &gt; const &amp;axes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; cSDH::GetAxisMaxAngle           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>axes</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the maximum angle(s) of axis(axes).<p>
The maximum angles are currently not read from the SDH, but are stored in the library.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axes</em>&nbsp;</td><td>- A vector of axis indices to access.</td></tr>
  </table>
</dl>
<ul>
<li>The indices in <em>axes</em> are checked if they are valid axis indices.</li><li>If <b>any</b> axis index is invalid then a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>A vector of the max angles of the selected axes.</li><li>The values are converted to the selected external unit system using the configured <a class="el" href="class_s_d_h_1_1c_s_d_h.html#bcb9da3cf0236c0e09cdd7af1a78225e" title="unit convert for (axis) angles: default = SDH::cSDH::uc_angle_degrees">uc_angle</a> unit converter object.</li><li>The order of the elements of the <em>axes</em> vector and the returned values vector <em>rv</em> matches. I.e. <code>rv</code>[i] will be the value of axis <code>axes</code>[i] (not axis <code>i</code>).</li></ul>
</dd></dl>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#c77ca1ad96d5f7e63cb513b176f9e94c">GetAxisMaxAngle(int)</a> for an overloaded variant to access a single axis.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming "hand" is a cSDH object ...</span>

          <span class="comment">// Get maximum axis angles of all axes</span>
          std::vector&lt;double&gt; v = hand.GetAxisMaxAngle( hand.all_axes );
          <span class="comment">// now v is something like {90.0, 90.0, 90.0, 90.0, 90.0, 90.0, 90.0}</span>

          <span class="comment">// Get maximum axis angle of axis 3</span>
          <span class="keywordtype">double</span> v3 = hand.GetAxisMaxAngle( 3 );
          <span class="comment">// v3 is now something like 90.0</span>

          <span class="comment">// Get maximum axis angle of axis 2 and 4</span>
          std::vector&lt;int&gt; axes24;
          axes24.push_back( 2 );
          axes24.push_back( 4 );

          v = hand.GetAxisMaxAngle( axes24 );
          <span class="comment">// now v is something like {90.0, 90.0}</span>


          <span class="comment">// Or if you change the angle unit system:</span>
          hand.UseRadians();

          v = hand.GetAxisMaxAngle( hand.all_axes );
          <span class="comment">// now v is something like { 1.5707963267948966, 1.5707963267948966, 1.5707963267948966, 1.5707963267948966, 1.5707963267948966, 1.5707963267948966, 1.5707963267948966}</span>
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="c77ca1ad96d5f7e63cb513b176f9e94c"></a><!-- doxytag: member="SDH::cSDH::GetAxisMaxAngle" ref="c77ca1ad96d5f7e63cb513b176f9e94c" args="(int iAxis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cSDH::GetAxisMaxAngle           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iAxis</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#d12978c317ec5a3ea785453e8907e46f">GetAxisMaxAngle(std::vector&lt;int&gt;const&amp;)</a>, just for a single axis <em>iAxis</em> and returning a single maximum angle, see there for details and examples. 
</div>
</div><p>
<a class="anchor" name="3494e3b5bc533764be487cf057850f79"></a><!-- doxytag: member="SDH::cSDH::GetAxisMaxVelocity" ref="3494e3b5bc533764be487cf057850f79" args="(std::vector&lt; int &gt; const &amp;axes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; cSDH::GetAxisMaxVelocity           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>axes</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the maximum velocity(s) of axis(axes). These are the (theoretical) maximum velocities as determined by the maximum motor velocity and gear box ratio. The values do not take things like friction or inertia into account. So it is likely that these maximum velocities cannot be reached by the real hardware in reality.<p>
The maximum velocities are currently read once from the SDH when the communication to the SDH is opened. Later queries of this maximum velocities will use the values stored in the library.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axes</em>&nbsp;</td><td>- A vector of axis indices to access.</td></tr>
  </table>
</dl>
<ul>
<li>The indices in <em>axes</em> are checked if they are valid axis indices.</li><li>If <b>any</b> axis index is invalid then a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>A vector of the max angular velocities of the selected axes.</li><li>The values are converted to the selected external unit system using the configured <a class="el" href="class_s_d_h_1_1c_s_d_h.html#81c208eb64b0954dfef4182575ff6bc9" title="unit convert for (axis) angular velocities: default = SDH::cSDH::uc_angular_velocity_degrees_per_sec...">uc_angular_velocity</a> unit converter object.</li><li>The order of the elements of the <em>axes</em> vector and the returned values vector <em>rv</em> matches. I.e. <code>rv</code>[i] will be the value of axis <code>axes</code>[i] (not axis <code>i</code>).</li></ul>
</dd></dl>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#db06920236cba9b86f529452a5cffc47">GetAxisMaxVelocity(int)</a> for an overloaded variant to access a single axis.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming "hand" is a cSDH object ...</span>

          <span class="comment">// Get maximum axis angular velocities of all axes</span>
          std::vector&lt;double&gt; v = hand.GetAxisMaxVelocity( hand.all_axes );
          <span class="comment">// now v is something like {83.857,200.000,157.895,200.000,157.895,200.000,157.895}</span>

          <span class="comment">// Get maximum axis angular velocity of axis 3</span>
          <span class="keywordtype">double</span> v3 = hand.GetAxisMaxVelocity( 3 );
          <span class="comment">// v3 is now something like 200.0</span>

          <span class="comment">// Get maximum axis angular velocity of axis 2 and 4</span>
          std::vector&lt;int&gt; axes24;
          axes24.push_back( 2 );
          axes24.push_back( 4 );

          v = hand.GetAxisMaxVelocity( axes24 );
          <span class="comment">// now v is something like {157.895, 157.895}</span>


          <span class="comment">// Or if you change the angular velocity unit system:</span>
          hand.UseRadians();

          v = hand.GetAxisMaxVelocity( hand.all_axes );
          <span class="comment">// now v is something like {1.46358075084, 3.49065850399, 2.75578762244, 3.49065850399, 2.75578762244, 3.49065850399, 2.75578762244}</span>
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="db06920236cba9b86f529452a5cffc47"></a><!-- doxytag: member="SDH::cSDH::GetAxisMaxVelocity" ref="db06920236cba9b86f529452a5cffc47" args="(int iAxis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cSDH::GetAxisMaxVelocity           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iAxis</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#3494e3b5bc533764be487cf057850f79">GetAxisMaxVelocity(std::vector&lt;int&gt;const&amp;)</a>, just for a single axis <em>iAxis</em> and returning a single minimum angle, see there for details and examples. 
</div>
</div><p>
<a class="anchor" name="f62c9a768ef8ab7f721b6b390de40935"></a><!-- doxytag: member="SDH::cSDH::GetAxisMaxAcceleration" ref="f62c9a768ef8ab7f721b6b390de40935" args="(std::vector&lt; int &gt; const &amp;axes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; cSDH::GetAxisMaxAcceleration           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>axes</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the maximum acceleration(s) of axis(axes).<p>
The maximum accelerations are currently not read from the SDH, but are stored in the library.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axes</em>&nbsp;</td><td>- A vector of axis indices to access.</td></tr>
  </table>
</dl>
<ul>
<li>The indices in <em>axes</em> are checked if they are valid axis indices.</li><li>If <b>any</b> axis index is invalid then a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>A vector of the max angular accelerations of the selected axes.</li><li>The values are converted to the selected external unit system using the configured <a class="el" href="class_s_d_h_1_1c_s_d_h.html#8dc039c618c3383d5fefd85d41866f9e" title="unit convert for (axis) angular accelerations: default = SDH::cSDH::uc_angular_acceleration_degrees_...">uc_angular_acceleration</a> unit converter object.</li><li>The order of the elements of the <em>axes</em> vector and the returned values vector <em>rv</em> matches. I.e. <code>rv</code>[i] will be the value of axis <code>axes</code>[i] (not axis <code>i</code>).</li></ul>
</dd></dl>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#c2176ca2a159dfa038b249ccc41ae808">GetAxisMaxAcceleration(int)</a> for an overloaded variant to access a single axis.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming "hand" is a cSDH object ...</span>

          <span class="comment">// Get maximum axis angular accelerations of all axes</span>
          std::vector&lt;double&gt; v = hand.GetAxisMaxAcceleration( hand.all_axes );
          <span class="comment">// now v is something like {1000.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0}</span>

          <span class="comment">// Get maximum axis angular acceleration of axis 3</span>
          <span class="keywordtype">double</span> v3 = hand.GetAxisMaxAcceleration( 3 );
          <span class="comment">// v3 is now something like 1000.0</span>

          <span class="comment">// Get maximum axis angular acceleration of axis 2 and 4</span>
          std::vector&lt;int&gt; axes24;
          axes24.push_back( 2 );
          axes24.push_back( 4 );

          v = hand.GetAxisMaxAcceleration( axes24 );
          <span class="comment">// now v is something like {1000.0, 1000.0}</span>


          <span class="comment">// Or if you change the angular acceleration unit system:</span>
          hand.UseRadians();

          v = hand.GetAxisMaxAcceleration( hand.all_axes );
          <span class="comment">// now v is something like {17.453292519943293, 17.453292519943293, 17.453292519943293, 17.453292519943293, 17.453292519943293, 17.453292519943293, 17.453292519943293}</span>
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="c2176ca2a159dfa038b249ccc41ae808"></a><!-- doxytag: member="SDH::cSDH::GetAxisMaxAcceleration" ref="c2176ca2a159dfa038b249ccc41ae808" args="(int iAxis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cSDH::GetAxisMaxAcceleration           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iAxis</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#f62c9a768ef8ab7f721b6b390de40935">GetAxisMaxAcceleration(std::vector&lt;int&gt;const&amp;)</a>, just for a single axis <em>iAxis</em> and returning a single minimum angle, see there for details and examples. 
</div>
</div><p>
<a class="anchor" name="a52181be374dd44517e0b2fef09130c1"></a><!-- doxytag: member="SDH::cSDH::MoveAxis" ref="a52181be374dd44517e0b2fef09130c1" args="(std::vector&lt; int &gt;const &amp;axes, bool sequ=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cSDH::MoveAxis           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt;const &amp;&nbsp;</td>
          <td class="paramname"> <em>axes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>sequ</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Move selected axis/axes to the previously set target pose with the previously set velocity profile, (maximum) target velocities and target accelerations<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axes</em>&nbsp;</td><td>- A vector of axis indices to access. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sequ</em>&nbsp;</td><td>- flag: if true (default) then the function executes sequentially and returns not until after the SDH has finished the movement. If false then the function returns immediately after the movement command has been sent to the SDH (the currently set target axis angles for other axes will then be <b>overwritten</b> with their current actual axis angles).</td></tr>
  </table>
</dl>
<ul>
<li>The indices in <em>axes</em> are checked if they are valid axis indices.</li><li>If any index is invalid then no movement is performed, instead a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The expected/elapsed execution time for the movement in the configured time unit system <a class="el" href="class_s_d_h_1_1c_s_d_h.html#7479296b9f0c7300dc50452c7c929bc2" title="unit convert for times: default = uc_time_seconds">uc_time</a></dd></dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd><ul>
<li>The axes will be enabled automatically.</li><li>Currently the actual movement velocity of an axis is determined by the SDH firmware to make the movements of all involved axes start and end synchronously at the same time. Therefore the axis that needs the longest time for its movement at its given maximum velocity determines the velocities of all the other axes.</li><li>Other axes than those selected by <em>axes</em> will <b>NOT</b> move, even if target axis angles for the axes have been set. (Remember: as axis 0 is used by finger 0 and 2 these two fingers cannot be moved completely idependent of each other.)</li><li>If <em>sequ</em> is true then the currently set target axis angles for other fingers will be restored upon return of the function.</li><li>If <em>sequ</em> is false then the currently set target axis angles for other fingers will be <b>overwritten</b> with their current actual axis angles</li></ul>
</dd></dl>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#112b655f39c71eacb4b407fce1cc3f2a">MoveAxis(int,bool)</a> for an overloaded variant to move a single axis.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming 'hand' is a cSDH object ...</span>

          <span class="comment">// create an index vector for adressing axes 0, 4 and 2 (in that order)</span>
          std::vector&lt;int&gt; axes042;
          axes042.push_back( 0 );
          axes042.push_back( 4 );
          axes042.push_back( 2 );

          <span class="comment">// Set a new target pose for axes 0, 4 and 2:</span>
          std::vector&lt;double&gt; angles042;
          angles042.push_back( 0.0 );
          angles042.push_back( -44.4 );
          angles042.push_back( -22.2 );

          hand.SetFingerTargetAngle( axes042, angles042 );


          <span class="comment">// First move Axis 0 only to its new target position:</span>
          hand.MoveAxis( 0 );

          <span class="comment">// The axis 0 has now reached its target position 0.0.  The</span>
          <span class="comment">// target poses for axes 4 and 2 are still set since the</span>
          <span class="comment">// last MoveAxes() call was sequentially (und thus it could</span>
          <span class="comment">// restore the previously set target axis angles of not</span>
          <span class="comment">// selected axes after the movement finished)</span>


          <span class="comment">// So move axes 4 and 2 now, this time non-sequentially:</span>
          std::vector&lt;int&gt; axes42;
          axes42.push_back( 4 );
          axes42.push_back( 2 );

          <span class="keywordtype">double</span> t = hand.MoveAxes( axis42, <span class="keyword">false</span> );

          <span class="comment">// The two axes 4 and 2 are now moving to their target position.</span>
          <span class="comment">// We have to wait until the non-sequential call has finished:</span>
          <a class="code" href="namespace_s_d_h.html#57c7b26a892e19cbc34a44b8056f81aa">SleepSec</a>( t );

          <span class="comment">// The axes 4 and 2 have now moved to -44.4 and -22.2.</span>

          <span class="comment">// The target angles for other axes have by now been</span>
          <span class="comment">// overwritten since the last MoveAxis() call was</span>
          <span class="comment">// non-sequentially (und thus it could \b NOT restore the</span>
          <span class="comment">// previously set target axis angles of not selected axes</span>
          <span class="comment">// after the movement finished)</span>


          <span class="comment">// Set new target angles for all axes ("home pose");</span>
          hand.SetAxisTargetAngle( hand.All, 0.0 );

          <span class="comment">// Now move all axes back to home pose:</span>
          hand.MoveAxes( hand.All );
</pre></div></dd></dl>
<dl compact><dt><b><a class="el" href="bug.html#_bug000008">Bug:</a></b></dt><dd>With SDH firmware &lt; 0.0.2.7 calling <a class="el" href="class_s_d_h_1_1c_s_d_h.html#a52181be374dd44517e0b2fef09130c1">MoveAxis()</a> while some axes are moving in eCT_POSE controller type will make the joints jerk. This is resolved in SDH firmware 0.0.2.7 for the eCT_POSE controller type with velocity profile eVP_RAMP. For the eCT_POSE controller type with velocity profile eVP_SIN_SQUARE changing target points/ velocities while moving will still make the axes jerk. <br>
<b>=&gt; Partly resolved in SDH firmware 0.0.2.7</b></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="112b655f39c71eacb4b407fce1cc3f2a"></a><!-- doxytag: member="SDH::cSDH::MoveAxis" ref="112b655f39c71eacb4b407fce1cc3f2a" args="(int iAxis, bool sequ=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cSDH::MoveAxis           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iAxis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>sequ</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#a52181be374dd44517e0b2fef09130c1">MoveAxis(std::vector&lt;int&gt;const&amp;,bool)</a>, just for a single axis <em>iAxis</em> (or all axes if <a class="el" href="class_s_d_h_1_1c_s_d_h_base.html#ab61ed07c53bf24bc87ff5103e74f45a8e09b2cc8bc776a705cd2665fc555881" title="A meta-value that means &quot;access all possible values&quot;.">All</a> is given). 
</div>
</div><p>
<a class="anchor" name="4246f404decae71bfea1ff4b27e4cbb6"></a><!-- doxytag: member="SDH::cSDH::SetFingerEnable" ref="4246f404decae71bfea1ff4b27e4cbb6" args="(std::vector&lt; int &gt; const &amp;fingers, std::vector&lt; double &gt; const &amp;states)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cSDH::SetFingerEnable           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>fingers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>states</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set enabled/disabled state of axis controllers of finger(s).<p>
The controllers of the axes of the selected fingers are enabled/disabled in the SDH. Disabled axes are not powered and thus might not remain in their current pose due to gravity, inertia or other external influences. But to prevent overheating the axis controllers should be switched of when not needed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fingers</em>&nbsp;</td><td>- A vector of finger indices to access. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>states</em>&nbsp;</td><td>- A vector of enabled states (0 = disabled, !=0 = enabled) to set. If any of the numbers in the vector is <code>NaN</code> (Not a Number) then the currently set enabled state will be kept for the corresponding axis.</td></tr>
  </table>
</dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd><ul>
<li>The lengths of the <em>fingers</em> and <em>states</em> vector must match.</li><li>The indices can be given in any order, but the order of their elements must match, i.e. <code>state</code>[i] will be applied to finger <code>fingers</code>[i] (not finger <code>i</code>).</li><li>The indices are checked if they are valid finger indices.</li><li>If <b>any</b> index is invalid then <b>none</b> of the specified values is sent to the SDH, instead a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li><li>As axis 0 is used for finger 0 and 2, axis 0 is disabled only if both finger 0 and 1 are disabled.</li></ul>
</dd></dl>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#d7d76fcf094c1c37a1ecfe5911a9c186">SetFingerEnable(int,double)</a>, <a class="el" href="class_s_d_h_1_1c_s_d_h.html#cfb60044e845bc4dd736b8731eb88035">SetFingerEnable(int,bool)</a> for overloaded variants to set a single finger enabled/disabled or to set the same state for all fingers. See further <a class="el" href="class_s_d_h_1_1c_s_d_h.html#8e2db3c372a62078954c4eb21396af73">SetFingerEnable(std::vector&lt;int&gt;const&amp;,std::vector&lt;bool&gt;const&amp;)</a> for a variant that accepts a <code>bool</code> vector for the states to set.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming "hand" is a cSDH object ...</span>

          <span class="comment">// Enable finger 1 and 2 while disabling finger 0 :</span>
          std::vector&lt;double&gt; states012;
          states012.push_back( 0.0 );
          states012.push_back( 1.0 );
          states012.push_back( 1.0 );

          hand.SetFingerEnable( hand.all_axes, states012 );
          <span class="comment">// (this will keep axis 0 (used by the disabled finger 0) enabled,</span>
          <span class="comment">// since axis 0 is needed by the enabled finger 2 too);</span>

          <span class="comment">// Enable all fingers:</span>
          hand.SetFingerEnable( hand.All,<span class="keyword">true</span> );

          <span class="comment">// Disable all fingers:</span>
          hand.SetFingerEnable( hand.All, 0.0 );

          <span class="comment">// Disable finger 2:</span>
          hand.SetFingerEnable( 2, <span class="keyword">false</span> );
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="d7d76fcf094c1c37a1ecfe5911a9c186"></a><!-- doxytag: member="SDH::cSDH::SetFingerEnable" ref="d7d76fcf094c1c37a1ecfe5911a9c186" args="(int iFinger, double state=1.0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cSDH::SetFingerEnable           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iFinger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>state</em> = <code>1.0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#4246f404decae71bfea1ff4b27e4cbb6">SetFingerEnable(std::vector&lt;int&gt;const&amp;,std::vector&lt;double&gt;const&amp;)</a>, just for a single finger <em>iAxis</em> and a single angle <em>angle</em>, see there for details and examples. 
</div>
</div><p>
<a class="anchor" name="8e2db3c372a62078954c4eb21396af73"></a><!-- doxytag: member="SDH::cSDH::SetFingerEnable" ref="8e2db3c372a62078954c4eb21396af73" args="(std::vector&lt; int &gt; const &amp;fingers, std::vector&lt; bool &gt; const &amp;states)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cSDH::SetFingerEnable           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>fingers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>states</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#4246f404decae71bfea1ff4b27e4cbb6">SetFingerEnable(std::vector&lt;int&gt;const&amp;,std::vector&lt;double&gt;const&amp;)</a>, just with states as vector of <code>bool</code> values, see there for details and examples. 
</div>
</div><p>
<a class="anchor" name="cfb60044e845bc4dd736b8731eb88035"></a><!-- doxytag: member="SDH::cSDH::SetFingerEnable" ref="cfb60044e845bc4dd736b8731eb88035" args="(int iFinger, bool state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cSDH::SetFingerEnable           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iFinger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>state</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#4246f404decae71bfea1ff4b27e4cbb6">SetFingerEnable(std::vector&lt;int&gt;const&amp;,std::vector&lt;double&gt;const&amp;)</a>, just for a single finger <em>iAxis</em> and a single angle <em>angle</em>, see there for details and examples. 
</div>
</div><p>
<a class="anchor" name="1037c7d5b94845cfc65cb82defca07fe"></a><!-- doxytag: member="SDH::cSDH::GetFingerEnable" ref="1037c7d5b94845cfc65cb82defca07fe" args="(std::vector&lt; int &gt; const &amp;fingers)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; cSDH::GetFingerEnable           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>fingers</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get enabled/disabled state of axis controllers of finger(s).<p>
The enabled/disabled state of the controllers of the selected fingers is read from the SDH. A finger is reported disabled if any of its axes is disabled and reported enabled if all its axes are enabled.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fingers</em>&nbsp;</td><td>- A vector of finger indices to access.</td></tr>
  </table>
</dl>
<ul>
<li>The indices in <em>fingers</em> are checked if they are valid finger indices.</li><li>If <b>any</b> finger index is invalid then a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>A vector of enabled/disabled states as doubles (0=disabled, 1.0=enabled) of the selected axes.</li><li>The order of the elements of the <em>axes</em> vector and the returned values vector <em>rv</em> matches. I.e. <code>rv</code>[i] will be the value of axis <code>axes</code>[i] (not axis <code>i</code>).</li></ul>
</dd></dl>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#653fff0ee151151babf10f1c6e1f0aef">GetAxisEnable(int)</a> for an overloaded variant to access a single axis.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming "hand" is a cSDH object ...</span>

          <span class="comment">// Get enabled state of all fingers:</span>
          std::vector&lt;double&gt; v = hand.GetFingerEnable( hand.all_fingers );
          <span class="comment">// now v is something like {0.0, 1.0, 0.0}</span>

          <span class="comment">// Get enabled state of finger 0 and 2</span>
          std::vector&lt;int&gt; fingers02;
          fingers02.push_back( 0 );
          fingers02.push_back( 2 );

          v = hand.GetFingerEnable( fingers02 );
          <span class="comment">// now v is something like {0.0, 0.0}</span>

          <span class="comment">// Get enabled state of finger 1</span>
          <span class="keywordtype">double</span> v1 = hand.GetFingerEnable( 1 );
          <span class="comment">// now v1 is something like 1.0</span>
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="381455ae42c3d39b4fadf40da7352cb6"></a><!-- doxytag: member="SDH::cSDH::GetFingerEnable" ref="381455ae42c3d39b4fadf40da7352cb6" args="(int iFinger)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cSDH::GetFingerEnable           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iFinger</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#1037c7d5b94845cfc65cb82defca07fe">GetFingerEnable(std::vector&lt;int&gt;const&amp;)</a>, just for a single finger <em>iFinger</em> and returning a single double value 
</div>
</div><p>
<a class="anchor" name="ba34c83c19e7c5338e6fc09bbf1cebcf"></a><!-- doxytag: member="SDH::cSDH::SetFingerTargetAngle" ref="ba34c83c19e7c5338e6fc09bbf1cebcf" args="(int iFinger, std::vector&lt; double &gt; const &amp;angles)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cSDH::SetFingerTargetAngle           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iFinger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>angles</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the target angle(s) for a single finger.<p>
The target axis angles <em>angle</em> of finger <em>iFinger</em> are stored in the SDH. The movement is not executed until an additional move command is sent.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iFinger</em>&nbsp;</td><td>- index of finger to access. This must be a single index. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>angles</em>&nbsp;</td><td>- the angle(s) to set or <code>None</code> to set the current actual axis angles of the finger as target angle. This can be a single number or a <a class="el" href="class_s_d_h_1_1c_s_d_h.html#sdhlibrary_cpp_sdh_h_csdh_vector">vector</a> of numbers. The value(s) are expected in the configured angle unit system <a class="el" href="class_s_d_h_1_1c_s_d_h.html#bcb9da3cf0236c0e09cdd7af1a78225e" title="unit convert for (axis) angles: default = SDH::cSDH::uc_angle_degrees">uc_angle</a>.</td></tr>
  </table>
</dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd><ul>
<li>Setting the target angles will <b>not</b> make the finger move.</li><li>The <em>iFinger</em> index is checked if it is a valid finger index.</li><li>The angles are checked if they are in the allowed range [0 .. <a class="el" href="class_s_d_h_1_1c_s_d_h.html#bd406a461d7fd466b6ae8708b1011e0c" title="Maximum allowed axis angles (in internal units (degrees)), including the virtual...">f_max_angle_v</a>], i.e. it is checked that <code>angles</code>[i], converted to internal units, is in <code></code>[0 .. <code>f_max_angle_v</code>[finger_axis_index[iFinger][i]]].</li><li>If <b>any</b> index or value is invalid then <b>none</b> of the specified values is sent to the SDH, instead a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
</dd></dl>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#c078e2f72e4b6006fe95d8711aceb2ef">SetFingerTargetAngle(int,double,double,double)</a> for an overloaded variant to set finger axis target angles from single <code>double</code> values.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming "hand" is a cSDH object ...</span>

          <span class="comment">// Set target axis angles of finger 0 to { 10.0, -08.15, 47.11 }</span>
          std::vector&lt;double&gt; angles;
          angles.push_back( 10.0 );
          angles.push_back( -08.15 );
          angles.push_back(  47.11 );

          hand.SetFingerTargetAngle( 0, angles );


          <span class="comment">// Set target axis angles of finger 1 to { 0.0, 24.7, 17.4 }</span>
          angles[0] = 0.0;   <span class="comment">// "virtual" base axis of finger 1</span>
          angles[1] = 24.7;
          angles[2] = 17.4;
          hand.SetFingerTargetAngle( 1, { 0.0, 24.7, 17.4 } );


          <span class="comment">// Set target axis angles of all axes of finger 0 to 12.34</span>
          hand.SetFingerTargetAngle( 0, 12.34, 12.34, 12.34 );


          <span class="comment">// REMARK: the last command changed the previously set target axis</span>
          <span class="comment">// angle for axis 0, since axis 0 is used as base axis for both</span>
          <span class="comment">// finger 0 and 2!</span>
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="c078e2f72e4b6006fe95d8711aceb2ef"></a><!-- doxytag: member="SDH::cSDH::SetFingerTargetAngle" ref="c078e2f72e4b6006fe95d8711aceb2ef" args="(int iFinger, double a0, double a1, double a2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cSDH::SetFingerTargetAngle           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iFinger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>a0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#ba34c83c19e7c5338e6fc09bbf1cebcf">SetFingerTargetAngle(int,std::vector&lt;double&gt;const&amp;)</a>, just with individual finger axis angles <em>a0</em>, <em>a1</em> and <em>a2</em>. 
</div>
</div><p>
<a class="anchor" name="18c5a988ce669f2d46def2a1f0f779b4"></a><!-- doxytag: member="SDH::cSDH::GetFingerTargetAngle" ref="18c5a988ce669f2d46def2a1f0f779b4" args="(int iFinger)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; cSDH::GetFingerTargetAngle           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iFinger</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the target axis angles of a single finger.<p>
The target axis angles of finger <em>iFinger</em> are read from the SDH.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iFinger</em>&nbsp;</td><td>- index of finger to access. This must be a single index</td></tr>
  </table>
</dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd><ul>
<li>The <em>iFinger</em> index is checked if it is a valid finger index.</li><li>If <em>iFinger</em> is invalid then a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>A list of the selected fingers target axis angles</li><li>The values are returned in the configured angle unit system <a class="el" href="class_s_d_h_1_1c_s_d_h.html#bcb9da3cf0236c0e09cdd7af1a78225e" title="unit convert for (axis) angles: default = SDH::cSDH::uc_angle_degrees">uc_angle</a>.</li></ul>
</dd></dl>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#2a96a70cf10eea86fefcb47a55e26b0e">GetFingerTargetAngle(int,double&amp;,double&amp;,double&amp;)</a> for an overloaded variant to get finger axis target angles into single <code>double</code> values.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming "hand" is a cSDH object ...</span>

          <span class="comment">// Get target axis angles of finger 0</span>
          std::vector&lt;double&gt; v = hand.GetFingerTargetAngle( 0 );
          <span class="comment">// now v is something like {42.0, -10.0, 47.11}</span>

          <span class="comment">// Get target axis angles of finger 1</span>
          <span class="keywordtype">double</span> a0, a1, a2;
          hand.GetFingerTargetAngle( 1, a0, a1, a2 );
          <span class="comment">// now a0, a1, a2 are something like 0.0, 24.7 and -5.5 respectively.</span>
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="2a96a70cf10eea86fefcb47a55e26b0e"></a><!-- doxytag: member="SDH::cSDH::GetFingerTargetAngle" ref="2a96a70cf10eea86fefcb47a55e26b0e" args="(int iFinger, double &amp;a0, double &amp;a1, double &amp;a2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cSDH::GetFingerTargetAngle           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iFinger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>a0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#18c5a988ce669f2d46def2a1f0f779b4">GetFingerTargetAngle(int)</a>, just returning the target axis angles in the <em>a0</em>, <em>a1</em> and <em>a2</em> parameters which are given by reference. 
</div>
</div><p>
<a class="anchor" name="15777eae7e03b863055834e2cfe87f7d"></a><!-- doxytag: member="SDH::cSDH::GetFingerActualAngle" ref="15777eae7e03b863055834e2cfe87f7d" args="(int iFinger)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; cSDH::GetFingerActualAngle           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iFinger</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the current actual axis angles of a single finger.<p>
The current actual axis angles of finger <em>iFinger</em> are read from the SDH.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iFinger</em>&nbsp;</td><td>- index of finger to access. This must be a single index.</td></tr>
  </table>
</dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd><ul>
<li>The <em>iFinger</em> index is checked if it is a valid finger index.</li><li>If <em>iFinger</em> is invalid then a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>A list of the current actual axis angles of the selected finger</li><li>The values are returned in the configured angle unit system <a class="el" href="class_s_d_h_1_1c_s_d_h.html#bcb9da3cf0236c0e09cdd7af1a78225e" title="unit convert for (axis) angles: default = SDH::cSDH::uc_angle_degrees">uc_angle</a>.</li></ul>
</dd></dl>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#c2e42748f9c6979959e8e6f1e155a7ec">GetFingerActualAngle(int,double&amp;,double&amp;,double&amp;)</a> for an overloaded variant to get finger axis actual angles into single <code>double</code> values.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming "hand" is a cSDH object ...</span>

          <span class="comment">// Get actual axis angles of finger 0</span>
          std::vector&lt;double&gt; v = hand.GetFingerActualAngle( 0 );
          <span class="comment">// v is now something like {42.0, -10.0, 47.11}</span>

          <span class="comment">// Get actual axis angles of finger 1</span>
          <span class="keywordtype">double</span> a0, a1, a2;
          hand.GetFingerTargetAngle( 1, a0, a1, a2 );
          <span class="comment">// now a0, a1, a2 are something like 0.0, 24.7 and -5.5 respectively.</span>
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="c2e42748f9c6979959e8e6f1e155a7ec"></a><!-- doxytag: member="SDH::cSDH::GetFingerActualAngle" ref="c2e42748f9c6979959e8e6f1e155a7ec" args="(int iFinger, double &amp;a0, double &amp;a1, double &amp;a2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cSDH::GetFingerActualAngle           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iFinger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>a0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#15777eae7e03b863055834e2cfe87f7d">GetFingerActualAngle(int)</a>, just returning the actual axis angles in the <em>a0</em>, <em>a1</em> and <em>a2</em> parameters which are given by reference. 
</div>
</div><p>
<a class="anchor" name="b6a45970a183452da7c7307d88e4fddd"></a><!-- doxytag: member="SDH::cSDH::GetFingerMinAngle" ref="b6a45970a183452da7c7307d88e4fddd" args="(int iFinger)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; cSDH::GetFingerMinAngle           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iFinger</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the minimum axis angles of a single finger.<p>
The minimum axis angles of finger <em>iFingers</em> axes, stored in the library, are returned.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iFinger</em>&nbsp;</td><td>- index of finger to access. This must be a single index</td></tr>
  </table>
</dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd><ul>
<li>The <em>iFinger</em> index is checked if it is a valid finger index.</li><li>If <em>iFinger</em> is invalid then a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>A list of the selected fingers minimum axis angles</li><li>The values are returned in the configured angle unit system <a class="el" href="class_s_d_h_1_1c_s_d_h.html#bcb9da3cf0236c0e09cdd7af1a78225e" title="unit convert for (axis) angles: default = SDH::cSDH::uc_angle_degrees">uc_angle</a>.</li></ul>
</dd></dl>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#d7070a86df73d6cf51c3e25ca465f337">GetFingerMinAngle(int,double&amp;,double&amp;,double&amp;)</a> for an overloaded variant to get finger axis min angles into single <code>double</code> values.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming "hand" is a cSDH object ...</span>

          <span class="comment">// Get minimum axis angles of finger 0</span>
          std::vector&lt;double&gt; v = hand.GetFingerMinAngle( 0 );
          <span class="comment">// now v is something like {0.0, -90.0, -90.0}</span>


          <span class="comment">// Get target axis angles of finger 1</span>
          <span class="keywordtype">double</span> a0, a1, a2;
          hand.GetFingerMinAngle( 1, a0, a1, a2 );
          <span class="comment">// now a0, a1, a2 are something like 0.0, -90.0, -90.0 respectively.</span>


          <span class="comment">// Or if you change the angle unit system:</span>
          hand.UseRadians();
          v = hand.GetFingerMinAngle( 0 );
          <span class="comment">// now v is something like {0.0, -1.5707963267948966, -1.5707963267948966}</span>
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="d7070a86df73d6cf51c3e25ca465f337"></a><!-- doxytag: member="SDH::cSDH::GetFingerMinAngle" ref="d7070a86df73d6cf51c3e25ca465f337" args="(int iFinger, double &amp;a0, double &amp;a1, double &amp;a2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cSDH::GetFingerMinAngle           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iFinger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>a0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#b6a45970a183452da7c7307d88e4fddd">GetFingerMinAngle(int)</a>, just returning the finger axis min angles in the <em>a0</em>, <em>a1</em> and <em>a2</em> parameters which are given by reference. 
</div>
</div><p>
<a class="anchor" name="2eb23046335fb06eb5d82b05dffa60a3"></a><!-- doxytag: member="SDH::cSDH::GetFingerMaxAngle" ref="2eb23046335fb06eb5d82b05dffa60a3" args="(int iFinger)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; cSDH::GetFingerMaxAngle           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iFinger</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the maximum axis angles of a single finger.<p>
The maximum axis angles of finger <em>iFingers</em> axes, stored in the library, are returned.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iFinger</em>&nbsp;</td><td>- index of finger to access. This must be a single index</td></tr>
  </table>
</dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd><ul>
<li>The <em>iFinger</em> index is checked if it is a valid finger index.</li><li>If <em>iFinger</em> is invalid then a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>A list of the selected fingers maximum axis angles</li><li>The values are returned in the configured angle unit system <a class="el" href="class_s_d_h_1_1c_s_d_h.html#bcb9da3cf0236c0e09cdd7af1a78225e" title="unit convert for (axis) angles: default = SDH::cSDH::uc_angle_degrees">uc_angle</a>.</li></ul>
</dd></dl>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#eb5e5c49e9c9547931f6d1cf12ad400c">GetFingerMaxAngle(int,double&amp;,double&amp;,double&amp;)</a> for an overloaded variant to get finger axis max angles into single <code>double</code> values.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming "hand" is a cSDH object ...</span>

          <span class="comment">// Get maximum axis angles of finger 0</span>
          std::vector&lt;double&gt; v = hand.GetFingerMaxAngle( 0 );
          <span class="comment">// now v is something like {90.0, 90.0, 90.0}</span>


          <span class="comment">// Get target axis angles of finger 1</span>
          <span class="keywordtype">double</span> a0, a1, a2;
          hand.GetFingerMaxAngle( 1, a0, a1, a2 );
          <span class="comment">// now a0, a1, a2 are something like 90.0, 90.0, 90.0 respectively.</span>


          <span class="comment">// Or if you change the angle unit system:</span>
          hand.UseRadians();
          v = hand.GetFingerMaxAngle( 0 );
          <span class="comment">// now v is something like {1.5707963267948966, 1.5707963267948966, 1.5707963267948966}</span>
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="eb5e5c49e9c9547931f6d1cf12ad400c"></a><!-- doxytag: member="SDH::cSDH::GetFingerMaxAngle" ref="eb5e5c49e9c9547931f6d1cf12ad400c" args="(int iFinger, double &amp;a0, double &amp;a1, double &amp;a2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cSDH::GetFingerMaxAngle           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iFinger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>a0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#2eb23046335fb06eb5d82b05dffa60a3">GetFingerMaxAngle(int)</a>, just returning the finger axis max angles in the <em>a0</em>, <em>a1</em> and <em>a2</em> parameters which are given by reference. 
</div>
</div><p>
<a class="anchor" name="37bebabf01e96b9e28aab5b015915514"></a><!-- doxytag: member="SDH::cSDH::GetFingerXYZ" ref="37bebabf01e96b9e28aab5b015915514" args="(int iFinger, std::vector&lt; double &gt; const &amp;angles)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; cSDH::GetFingerXYZ           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iFinger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>angles</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the cartesian xyz finger tip position of a single finger from the given axis angles (forward kinematics).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iFinger</em>&nbsp;</td><td>- index of finger to access. This must be a single index </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>angles</em>&nbsp;</td><td>- a vector of NUMBER_OF_AXES_PER_FINGER angles. The values are expected in the configured angle unit system <a class="el" href="class_s_d_h_1_1c_s_d_h.html#bcb9da3cf0236c0e09cdd7af1a78225e" title="unit convert for (axis) angles: default = SDH::cSDH::uc_angle_degrees">uc_angle</a>.</td></tr>
  </table>
</dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd><ul>
<li>The <em>iFinger</em> index is checked if it is a valid finger index.</li><li>The angles are checked if they are in the allowed range [0 .. <a class="el" href="class_s_d_h_1_1c_s_d_h.html#bd406a461d7fd466b6ae8708b1011e0c" title="Maximum allowed axis angles (in internal units (degrees)), including the virtual...">f_max_angle_v</a>], i.e. it is checked that <code>angles</code>[i], converted to internal units, is in <code></code>[0 .. <code>f_max_angle_v</code>[finger_axis_index[iFinger][i]]].</li><li>If any index or value is invalid then a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>A vector of the x,y,z values of the finger tip position</li><li>The values are returned in the configured position unit system <a class="el" href="class_s_d_h_1_1c_s_d_h.html#b16893e67eb1273cd95adcd6c0d5e631" title="unit converter for position: default = SDH::cSDH::uc_position_millimeter">uc_position</a>.</li></ul>
</dd></dl>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#1077543dc0254aa62b296def80ad3130">GetFingerXYZ(int,double,double,double)</a> for an overloaded variant to get finger tip position from single <code>double</code> values.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming "hand" is a cSDH object ...</span>

          <span class="comment">// Get actual finger angles of finger 0:</span>
          std::vector&lt;double&gt; angles = hand.GetFingerActualAngle( 0 );

          <span class="comment">// Get actual finger tip position of finger 0:</span>
          std::vector&lt;double&gt; position = hand.GetFingerXYZ( 0, angles );
          <span class="comment">// now position is something like {18.821618775581801, 32.600000000000001, 174.0}</span>
          <span class="comment">// (assuming that finger 0 is at axis angles {0,0,0})</span>

          <span class="comment">// Get finger tip position of finger 2 at axis angles {90,-90,-90}:</span>
          position = hand.GetFingerXYZ( 2, 90, -90, -90 );
          <span class="comment">// now position is something like {18.821618775581804, 119.60000000000002, -53.0}</span>

          <span class="comment">// Or if you change the angle unit system:</span>
          hand.UseRadians();
          position = hand.GetFingerXYZ( 0, 1.5707963267948966, -1.5707963267948966, -1.5707963267948966 );
          <span class="comment">// now position is still something like {18.821618775581804, 119.60000000000002, -53.0}</span>

          <span class="comment">// Or if you change the position unit system too:</span>
          hand.uc_position = &amp;<a class="code" href="class_s_d_h_1_1c_s_d_h.html#9c39c381b642d85d059c98b593af7178" title="Converter for position: external unit = meter.">cSDH::uc_position_meter</a>
          position = hand.GetFingerXYZ( 0, 1.5707963267948966, -1.5707963267948966, -1.5707963267948966 );
          <span class="comment">// now position is still something like {0.018821618775581, 0.119.60000000000002, -0.052999999999}</span>
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="1077543dc0254aa62b296def80ad3130"></a><!-- doxytag: member="SDH::cSDH::GetFingerXYZ" ref="1077543dc0254aa62b296def80ad3130" args="(int iFinger, double a0, double a1, double a2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; cSDH::GetFingerXYZ           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iFinger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>a0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#ba34c83c19e7c5338e6fc09bbf1cebcf">SetFingerTargetAngle(int,std::vector&lt;double&gt;const&amp;)</a>, just with individual finger axis angles <em>a0</em>, <em>a1</em> and <em>a2</em>. 
</div>
</div><p>
<a class="anchor" name="67baba337dd775a0c8798b7f82738d6d"></a><!-- doxytag: member="SDH::cSDH::MoveFinger" ref="67baba337dd775a0c8798b7f82738d6d" args="(std::vector&lt; int &gt;const &amp;fingers, bool sequ=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cSDH::MoveFinger           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt;const &amp;&nbsp;</td>
          <td class="paramname"> <em>fingers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>sequ</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Move selected finger(s) to the previously set target pose with the previously set velocity profile, (maximum) target velocities and target accelerations.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fingers</em>&nbsp;</td><td>- A vector of finger indices to access. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sequ</em>&nbsp;</td><td>- flag: if true (default) then the function executes sequentially and returns not until after the SDH has finished the movement. If false then the function returns immediately after the movement command has been sent to the SDH (the currently set target axis angles for other fingers will then be <b>overwritten</b> with their current actual axis angles).</td></tr>
  </table>
</dl>
<ul>
<li>The indices in <em>fingers</em> are checked if they are valid finger indices.</li><li>If any index is invalid then no movement is performed, instead a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The expected/elapsed execution time for the movement in the configured time unit system <a class="el" href="class_s_d_h_1_1c_s_d_h.html#7479296b9f0c7300dc50452c7c929bc2" title="unit convert for times: default = uc_time_seconds">uc_time</a></dd></dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd><ul>
<li>The axes will be enabled automatically.</li><li>Currently the actual movement velocity of an axis is determined by the SDH firmware to make the movements of all involved axes start and end synchronously at the same time. Therefore the axis that needs the longest time for its movement at its given maximum velocity determines the velocities of all the other axes.</li><li>Other fingers than <em>iFinger</em> will <b>NOT</b> move, even if target axis angles for their axes have been set. (Exception: as axis 0 is used by finger 0 and 2 these two fingers cannot be moved completely idependent of each other.)</li><li>If <em>sequ</em> is true then the currently set target axis angles for other fingers will be restored upon return of the function.</li><li>If <em>sequ</em> is false then the currently set target axis angles for other fingers will be <b>overwritten</b> with their current actual axis angles</li></ul>
</dd></dl>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#ca98ac669705fe8491fb860a97c4ea21">MoveFinger(int,bool)</a> for an overloaded variant to move a single finger.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming 'hand' is a cSDH object ...</span>

          <span class="comment">// Set a new target pose for finger 0:</span>
          hand.SetFingerTargetAngle( 0, 0.0, 0.0, 0.0 );

          <span class="comment">// Set a new target pose for finger 1</span>
          hand.SetFingerTargetAngle( 1, 0.0, -10.0, -10.0 );

          <span class="comment">// Set a new target pose for finger 2</span>
          hand.SetFingerTargetAngle( 2, 20.0, -20.0, -20.0 );

          <span class="comment">// Move finger 0 only (and finger 2 partly as axis 0 also belongs to finger 2);</span>
          hand.MoveFinger( 0, <span class="keyword">true</span> );
          <span class="comment">// The finger 0 has been moved to {20,0,0}</span>
          <span class="comment">// (axis 0 is 'wrong' since the target angle for axis 0 has been overwritten</span>
          <span class="comment">//  while setting the target angles for finger 2);</span>

          <span class="comment">// The target poses for finger 1 and 2 are still set since the</span>
          <span class="comment">// last MoveFinger() call was sequentially.</span>
          <span class="comment">// So move finger 1 now:</span>
          <span class="keywordtype">double</span> t = hand.MoveFinger( 1, <span class="keyword">false</span> );

          <span class="comment">// wait until the non-sequential call has finished:</span>
          <a class="code" href="namespace_s_d_h.html#57c7b26a892e19cbc34a44b8056f81aa">SleepSec</a>( t );

          <span class="comment">// The finger 1 has been moved to {0,-10,-10}.</span>

          <span class="comment">// The target angles for finger 2 have been overwritten since the</span>
          <span class="comment">// last MoveFinger() call was non-sequentially.</span>

          <span class="comment">// Therefore this next call will just keep the fingers in their</span>
          <span class="comment">// current positions:</span>
          hand.MoveFinger( hand.All, <span class="keyword">true</span> );


          <span class="comment">// Set new target angles for all axes ("home pose");</span>
          hand.SetAxisTargetAngle( hand.All, 0.0 );

          <span class="comment">// Now move all axes back to home pose:</span>
          hand.MoveHand();
</pre></div></dd></dl>
<dl compact><dt><b><a class="el" href="bug.html#_bug000009">Bug:</a></b></dt><dd>With SDH firmware &lt; 0.0.2.7 calling <a class="el" href="class_s_d_h_1_1c_s_d_h.html#67baba337dd775a0c8798b7f82738d6d">MoveFinger()</a> while some axes are moving in eCT_POSE controller type will make the joints jerk. This is resolved in SDH firmware 0.0.2.7 for the eCT_POSE controller type with velocity profile eVP_RAMP. For the eCT_POSE controller type with velocity profile eVP_SIN_SQUARE changing target points/ velocities while moving will still make the axes jerk. <br>
<b>=&gt; Partly resolved in SDH firmware 0.0.2.7</b> </dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="ca98ac669705fe8491fb860a97c4ea21"></a><!-- doxytag: member="SDH::cSDH::MoveFinger" ref="ca98ac669705fe8491fb860a97c4ea21" args="(int iFinger, bool sequ=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cSDH::MoveFinger           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iFinger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>sequ</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#67baba337dd775a0c8798b7f82738d6d">MoveFinger(std::vector&lt;int&gt;const&amp;,bool)</a>, just for a single finger <em>iFinger</em> (or all fingers if <a class="el" href="class_s_d_h_1_1c_s_d_h_base.html#ab61ed07c53bf24bc87ff5103e74f45a8e09b2cc8bc776a705cd2665fc555881" title="A meta-value that means &quot;access all possible values&quot;.">All</a> is given). 
</div>
</div><p>
<a class="anchor" name="91ecc6595c68f2c6f00d31ffaea22a60"></a><!-- doxytag: member="SDH::cSDH::MoveHand" ref="91ecc6595c68f2c6f00d31ffaea22a60" args="(bool sequ=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cSDH::MoveHand           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>sequ</em> = <code>true</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Move all fingers to the previously set target pose with the previously set (maximum) velocities.<p>
This is just a shortcut to <a class="el" href="class_s_d_h_1_1c_s_d_h.html#ca98ac669705fe8491fb860a97c4ea21">MoveFinger(int,bool)</a> with <em>iFinger</em> set to <code>hand.All</code> and <em>sequ</em> as indicated, so see there for details and examples.<p>
<dl compact><dt><b><a class="el" href="bug.html#_bug000010">Bug:</a></b></dt><dd>With SDH firmware &lt; 0.0.2.7 calling <a class="el" href="class_s_d_h_1_1c_s_d_h.html#91ecc6595c68f2c6f00d31ffaea22a60">MoveHand()</a> while some axes are moving in eCT_POSE controller type will make the joints jerk. This is resolved in SDH firmware 0.0.2.7 for the eCT_POSE controller type with velocity profile eVP_RAMP. For the eCT_POSE controller type with velocity profile eVP_SIN_SQUARE changing target points/ velocities while moving will still make the axes jerk. <br>
<b>=&gt; Parltly resolved in SDH firmware 0.0.2.7</b> </dd></dl>

</div>
</div><p>
<a class="anchor" name="579ccdb07f5d218c4b4309e45ae80325"></a><!-- doxytag: member="SDH::cSDH::GetGripMaxVelocity" ref="579ccdb07f5d218c4b4309e45ae80325" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cSDH::GetGripMaxVelocity           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the maximum velocity of grip skills<p>
The maximum velocity is currently not read from the SDH, but is stored in the library.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>a single double value is returned representing the velocity in the <a class="el" href="class_s_d_h_1_1c_s_d_h.html#81c208eb64b0954dfef4182575ff6bc9" title="unit convert for (axis) angular velocities: default = SDH::cSDH::uc_angular_velocity_degrees_per_sec...">uc_angular_velocity</a> unit system</li></ul>
</dd></dl>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">         <span class="comment">// Assuming "hand" is a cSDH object ...</span>

         <span class="comment">// Get maximum grip skill velocity</span>
         <span class="keywordtype">double</span> v = hand.GetGripMaxVelocity();
         <span class="comment">// v is now something like 100.0</span>

         <span class="comment">// Or if you change the velocity unit system:</span>
         hand.UseRadians();
         v = hand.GetGripMaxVelocity();
         <span class="comment">// now v is something like 1.7453292519943295</span>
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="1af5350393024630009896e5191a5f94"></a><!-- doxytag: member="SDH::cSDH::GripHand" ref="1af5350393024630009896e5191a5f94" args="(eGraspId grip, double close, double velocity, bool sequ=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cSDH::GripHand           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_s_d_h_1_1c_s_d_h_base.html#77b4811e6b0d574a30fe4ccf7d5e7672">eGraspId</a>&nbsp;</td>
          <td class="paramname"> <em>grip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>close</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>velocity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>sequ</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Perform one of the internal <a class="el" href="class_s_d_h_1_1c_s_d_h_base.html#77b4811e6b0d574a30fe4ccf7d5e7672" title="The enum values of the known grasps.">eGraspId</a> "grips" or "grasps"<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>THIS DOES NOT WORK WITH SDH FIRMWARE PRIOR TO 0.0.2.6 This was a feature in the ancient times of the SDH1 and now does work again for SDH firmware 0.0.2.6 and newer. We intend to further improve this feature (e.g. store user defined grips within the SDH) in the future, but a particular deadline a has not been determined yet.</dd></dl>
<dl compact><dt><b><a class="el" href="bug.html#_bug000011">Bug:</a></b></dt><dd>With SDH firmware &lt; 0.0.2.6 <a class="el" href="class_s_d_h_1_1c_s_d_h.html#1af5350393024630009896e5191a5f94">GripHand()</a> does not work and might yield undefined behaviour there <br>
<b>=&gt; Resolved in SDH firmware 0.0.2.6</b></dd></dl>
<dl compact><dt><b><a class="el" href="bug.html#_bug000011">Bug:</a></b></dt><dd>Currently the performing of a skill or grip with <a class="el" href="class_s_d_h_1_1c_s_d_h.html#1af5350393024630009896e5191a5f94">GripHand()</a> can <b>NOT</b> be interrupted!!! Even if the command is sent with <em>sequ=false</em> it <b>cannot</b> be stoped or emergency stopped.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>grip</em>&nbsp;</td><td>- The index of the grip to perform [0..eGID_DIMENSION-1] (s.a. eGraspId) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>close</em>&nbsp;</td><td>- close-ratio: [0.0 .. 1.0] where 0.0 is 'fully opened' and 1.0 is 'fully closed' </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>velocity</em>&nbsp;</td><td>- maximum allowed angular axis velocity in the chosen external unit system <a class="el" href="class_s_d_h_1_1c_s_d_h.html#81c208eb64b0954dfef4182575ff6bc9" title="unit convert for (axis) angular velocities: default = SDH::cSDH::uc_angular_velocity_degrees_per_sec...">uc_angular_velocity</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sequ</em>&nbsp;</td><td>- flag: if true (default) then the function executes sequentially and returns not until after the SDH has finished the movement. If false then the function returns immediately after the movement command has been sent to the SDH.</td></tr>
  </table>
</dl>
<ul>
<li>The <em>close</em> and <em>velocity</em> values are checked if they are in their allowed range.</li><li>If <b>any</b> value is invalid then <b>no</b> grip is perfomed, instead a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The expected/elapsed execution time for the movement in the configured time unit system <a class="el" href="class_s_d_h_1_1c_s_d_h.html#7479296b9f0c7300dc50452c7c929bc2" title="unit convert for times: default = uc_time_seconds">uc_time</a>.</dd></dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd><ul>
<li>Currently the actual movement velocity of an axis is determined by the SDH firmware to make the movements of all involved axes start and end synchronously at the same time. Therefore the axis that needs the longest time for its movement at its given maximum velocity determines the velocities of all the other axes.</li><li>The currently set target axis angles are not changed by this command</li><li>The movement uses the eMotorCurrentMode motor current modes "eMCM_GRIP" while gripping and then changes the motor current mode to "eMCM_HOLD". After the movement previously set motor currents set for mode "eMCM_MOVE" are <b>overwritten!</b> </li></ul>
</dd></dl>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming 'hand' is a cSDH object ...</span>

          <span class="comment">// Perform a fully opened centrical grip at 50/s:</span>
          hand.GripHand( hand.eGID_CENTRICAL, 0.0, 50.0, <span class="keyword">true</span> );

          <span class="comment">// Now close it 50% with 30/s:</span>
          hand.GripHand( hand.eGID_CENTRICAL, 0.5, 30.0, <span class="keyword">true</span> );

          <span class="comment">// Then close it completely with 20/s:</span>
          hand.GripHand( hand.eGID_CENTRICAL, 1.0, 20.0, <span class="keyword">true</span> );
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="5edad78d5abca94b036a582c053556b0"></a><!-- doxytag: member="SDH::cSDH::SetDebugOutput" ref="5edad78d5abca94b036a582c053556b0" args="(std::ostream *debuglog)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SDH::cSDH::SetDebugOutput           </td>
          <td>(</td>
          <td class="paramtype">std::ostream *&nbsp;</td>
          <td class="paramname"> <em>debuglog</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
change the stream to use for debug messages 
<p>

<p>Reimplemented from <a class="el" href="class_s_d_h_1_1c_s_d_h_base.html#3507208d616c6218423e2df0f7d75ce3">SDH::cSDHBase</a>.</p>

</div>
</div><p>
<a class="anchor" name="fb366fc46fff7b6840028bc053f88e5f"></a><!-- doxytag: member="SDH::cSDH::SetAxisValueVector" ref="fb366fc46fff7b6840028bc053f88e5f" args="(std::vector&lt; int &gt; const &amp;axes, std::vector&lt; double &gt; const &amp;values, pSetFunction ll_set, pGetFunction ll_get, cUnitConverter const *uc, std::vector&lt; double &gt; const &amp;min_values, std::vector&lt; double &gt; const &amp;max_values, char const *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SDH::cSDH::SetAxisValueVector           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>axes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_s_d_h.html#2125769495fc86ea25e2fc2181887723">pSetFunction</a>&nbsp;</td>
          <td class="paramname"> <em>ll_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_s_d_h.html#cbae245111c9c3618d335156ba2e04f7">pGetFunction</a>&nbsp;</td>
          <td class="paramname"> <em>ll_get</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a> const *&nbsp;</td>
          <td class="paramname"> <em>uc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>min_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>max_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Generic set function: set some given axes to given values<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axes</em>&nbsp;</td><td>- a vector of axis indices </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>values</em>&nbsp;</td><td>- a vector of values </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ll_set</em>&nbsp;</td><td>- a pointer to the low level set function to use </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ll_get</em>&nbsp;</td><td>- a pointer to the low level get function to use (for those axes where the given value is NaN) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uc</em>&nbsp;</td><td>- a pointer to the unit converter object to use before sending values to <em>ll_set</em> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>min_values</em>&nbsp;</td><td>- a vector with the minimum allowed values </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max_values</em>&nbsp;</td><td>- a vector with the maximum allowed values </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>- a string with the name of the values (for constructing error message)</td></tr>
  </table>
</dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd><ul>
<li>The length of the <em>axis</em> and <em>values</em> vector must match.</li><li>The indices can be given in any order, but the order of the elements of <em>axes</em> and <em>values</em> must match too. I.e. <code>values</code>[i] will be applied to axis <code>axes</code>[i] (not axis <code>i</code>)</li><li>The indices are checked if they are valid axis indices.</li><li>The values are checked if they are in the allowed range [<em>min_values</em> .. <em>f_max_values</em>], i.e. it is checked that <code>value</code>[i], converted to the internal unit system by <em>uc-&gt;ToInternal()</em>, is in [<em>min_values</em>[axes[i]] .. <em>max_values</em>[axes[i]]].</li><li>If <b>any</b> index or value is invalid then <b>none</b> of the specified values is sent to the SDH, instead a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown. </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="226208ca2312aeab801124ea4004802f"></a><!-- doxytag: member="SDH::cSDH::GetAxisValueVector" ref="226208ca2312aeab801124ea4004802f" args="(std::vector&lt; int &gt; const &amp;axes, pGetFunction ll_get, cUnitConverter const *uc, char const *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; SDH::cSDH::GetAxisValueVector           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>axes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_s_d_h.html#cbae245111c9c3618d335156ba2e04f7">pGetFunction</a>&nbsp;</td>
          <td class="paramname"> <em>ll_get</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a> const *&nbsp;</td>
          <td class="paramname"> <em>uc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Generic get function: get some given axes values<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axes</em>&nbsp;</td><td>- a vector of axis indices </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ll_get</em>&nbsp;</td><td>- a pointer to the low level get function to use </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uc</em>&nbsp;</td><td>- a pointer to the unit converter object to apply before returning values </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>- a string with the name of the values (for constructing error message)</td></tr>
  </table>
</dl>
<ul>
<li>The indices in <em>axes</em> are checked if they are valid axis indices.</li><li>If <b>any</b> axis index is invalid then a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>A vector of the addressed values for the selected axes.</li><li>The values are converted to external unit system using the <em>uc</em> unit converter object.</li><li>The order of the elements of the <em>axes</em> vector and the returned values vector <em>rv</em> matches. I.e. <code>rv</code>[i] will be the value of axis <code>axes</code>[i] (not axis <code>i</code>). </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="47871a0d85a4eadeca0b64c592e98811"></a><!-- doxytag: member="SDH::cSDH::ToIndexVector" ref="47871a0d85a4eadeca0b64c592e98811" args="(int index, std::vector&lt; int &gt; &amp;all_replacement, int maxindex, char const *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; SDH::cSDH::ToIndexVector           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>all_replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>maxindex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Internal helper function: return a vector of checked indices according to index.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>- The index to vectorize or <a class="el" href="class_s_d_h_1_1c_s_d_h_base.html#ab61ed07c53bf24bc87ff5103e74f45a8e09b2cc8bc776a705cd2665fc555881" title="A meta-value that means &quot;access all possible values&quot;.">All</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>all_replacement</em>&nbsp;</td><td>- a vector to return if <em>index</em> is <a class="el" href="class_s_d_h_1_1c_s_d_h_base.html#ab61ed07c53bf24bc87ff5103e74f45a8e09b2cc8bc776a705cd2665fc555881" title="A meta-value that means &quot;access all possible values&quot;.">All</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxindex</em>&nbsp;</td><td>- the <em>index</em> is checked if in [0.. maxindex[ (i.e. not including <em>maxindex</em>) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>- A name for the things index, used to report out of bounds errors</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>If <em>index</em> is <a class="el" href="class_s_d_h_1_1c_s_d_h_base.html#ab61ed07c53bf24bc87ff5103e74f45a8e09b2cc8bc776a705cd2665fc555881" title="A meta-value that means &quot;access all possible values&quot;.">All</a> then <em>all_replacement</em> is returned.</li><li>If <em>index</em> is a single number &gt;= 0 then it is checked if in [0.. maxindex[ and a vector of length 1 is returned containing only <em>index</em>.</li><li>In case <em>index</em> exceeds <em>maxindex</em> a (cSDHErrorInvalidParameter*) exception is thrown. </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="d32ec1d5fed635ab5a656ead26928731"></a><!-- doxytag: member="SDH::cSDH::GetMotorCurrentModeFunction" ref="d32ec1d5fed635ab5a656ead26928731" args="(eMotorCurrentMode mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_s_d_h.html#2125769495fc86ea25e2fc2181887723">pSetFunction</a> SDH::cSDH::GetMotorCurrentModeFunction           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#712b0b80382f1e1e5229ad7bec6cdc4d">eMotorCurrentMode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Internal helper function: return the get/set function of the comm_interface object that is responsible for setting/getting motor currents in <em>mode</em>. 
</div>
</div><p>
<a class="anchor" name="11b4b8ae7bc600bb502d7e42f9743456"></a><!-- doxytag: member="SDH::cSDH::_GetFingerXYZ" ref="11b4b8ae7bc600bb502d7e42f9743456" args="(int fi, std::vector&lt; double &gt; r_angles)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; SDH::cSDH::_GetFingerXYZ           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>fi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;&nbsp;</td>
          <td class="paramname"> <em>r_angles</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
return cartesian [x,y,z] position in mm of fingertip for finger fi at angles r_angles (rad) 
</div>
</div><p>
<a class="anchor" name="3df97ff34a8bb697a9d883928c492cc0"></a><!-- doxytag: member="SDH::cSDH::IsVirtualAxis" ref="3df97ff34a8bb697a9d883928c492cc0" args="(int iAxis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SDH::cSDH::IsVirtualAxis           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iAxis</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return <code>true</code> if index <em>iAxis</em> refers to a virtual axis. 
<p>

</div>
</div><p>
<a class="anchor" name="45fb825338c104ee620178babaaa4509"></a><!-- doxytag: member="SDH::cSDH::UseRadians" ref="45fb825338c104ee620178babaaa4509" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SDH::cSDH::UseRadians           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Shortcut to set the unit system to radians.<p>
After calling this axis angles are set/reported in radians and angular velocities are set/reported in radians/second<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">         <span class="comment">// Assuming 'hand' is a cSDH object ...</span>

         <span class="comment">// make hand object use radians and radians/second for angles and angular velocities</span>
         hand.UseRadians();
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="590995e561ac2d1a5bb0c840e0c31287"></a><!-- doxytag: member="SDH::cSDH::UseDegrees" ref="590995e561ac2d1a5bb0c840e0c31287" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SDH::cSDH::UseDegrees           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Shortcut to set the unit system to degrees.<p>
After calling this (axis) angles are set/reported in degrees and angular velocities are set/reported in degrees/second<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">         <span class="comment">// Assuming 'hand' is a cSDH object ...</span>

         <span class="comment">// make hand object use degrees and degrees/second for angles and angular velocities</span>
         hand.UseDegrees();
         <span class="comment">// as degrees, degrees/second are the default this is needed only if the</span>
         <span class="comment">// unit system was changed before</span>
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="78994c553339d90ecd29e55e52d671f7"></a><!-- doxytag: member="SDH::cSDH::GetFingerNumberOfAxes" ref="78994c553339d90ecd29e55e52d671f7" args="(int iFinger)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SDH::cSDH::GetFingerNumberOfAxes           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iFinger</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the number of real axes of finger with index <em>iFinger</em>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iFinger</em>&nbsp;</td><td>- index of finger in range [0..NUMBER_OF_FINGERS-1]</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>Number of real axes of finger with index <em>iFinger</em> </li><li>If <em>iFinger</em> is invalid a (cSDHErrorInvalidParameter*) exception is thrown.</li></ul>
</dd></dl>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">         <span class="comment">// Assuming 'hand' is a cSDH object ...</span>

         cout &lt;&lt; <span class="stringliteral">"The finger 0 has "</span> &lt;&lt; hand.GetFingerNumberOfAxes( 0 ) &lt;&lt; <span class="stringliteral">" real axes\n"</span>;
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="d409bd282545da7cc0384501f7c05130"></a><!-- doxytag: member="SDH::cSDH::GetFingerAxisIndex" ref="d409bd282545da7cc0384501f7c05130" args="(int iFinger, int iFingerAxis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SDH::cSDH::GetFingerAxisIndex           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iFinger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iFingerAxis</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return axis index of <em>iFingerAxis</em> axis of finger with index iFinger<p>
For <em>iFinger=2</em>, iFingerAxis=0 this will return the index of the virtual base axis of the finger<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iFinger</em>&nbsp;</td><td>- index of finger in range [0..NUMBER_OF_FINGERS-1] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iFingerAxis</em>&nbsp;</td><td>- index of finger axis in range [0..NUMBER_OF_AXES_PER_FINGER-1]</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>Axis index of <em>iFingerAxis-th</em> axis of finger with index <em>iFinger</em> </li><li>If <em>iFinger</em> or <em>iFingerAxis</em> is invalid a (cSDHErrorInvalidParameter*) exception is thrown.</li></ul>
</dd></dl>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">         <span class="comment">// Assuming 'hand' is a cSDH object ...</span>

         cout &lt;&lt; <span class="stringliteral">"The 1st axis of finger 2 has real axis index "</span> &lt;&lt; hand.GetFingerNumberOfAxes( 2, 0 ) &lt;&lt; <span class="stringliteral">"\n"</span>;
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="98cd1199edb7c6436be1d4c9d2bb892d"></a><!-- doxytag: member="SDH::cSDH::GetLibraryRelease" ref="98cd1199edb7c6436be1d4c9d2bb892d" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static char const* SDH::cSDH::GetLibraryRelease           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the release name of the library (not the firmware of the SDH) as string.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">         <span class="comment">// static member functon, so no cSDH object is needed for access:</span>

         cout &lt;&lt; <span class="stringliteral">"The SDHLibrary reports release name "</span> &lt;&lt; cSDH::GetReleaseLibrary() &lt;&lt; <span class="stringliteral">"\n"</span>;
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="420d4888ad31c07b44ae47617a0a33eb"></a><!-- doxytag: member="SDH::cSDH::GetLibraryName" ref="420d4888ad31c07b44ae47617a0a33eb" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static char const* SDH::cSDH::GetLibraryName           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the name of the library as string.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">         <span class="comment">// static member functon, so no cSDH object is needed for access:</span>

         cout &lt;&lt; <span class="stringliteral">"The SDHLibrary reports name "</span> &lt;&lt; <a class="code" href="class_s_d_h_1_1c_s_d_h.html#4d3480853847207adbdba2e20a87ccf1">cSDH::GetLibraryName</a>() &lt;&lt; <span class="stringliteral">"\n"</span>;
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="7556511eb9cf81c4bcb68430e70418ce"></a><!-- doxytag: member="SDH::cSDH::GetFirmwareRelease" ref="7556511eb9cf81c4bcb68430e70418ce" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char const* SDH::cSDH::GetFirmwareRelease           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the release name of the firmware of the SDH (not the library) as string.<p>
This will throw a (cSDHErrorCommunication*) exception if the connection to the SDH is not yet opened.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">         <span class="comment">// Assuming 'hand' is a cSDH object ...</span>

         cout &lt;&lt; <span class="stringliteral">"The SDH firmware reports release "</span> &lt;&lt; hand.GetFirmwareRelease() &lt;&lt; <span class="stringliteral">"\n"</span>;
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="fb9751f28fde3347cccb4dbe9ecfe2e2"></a><!-- doxytag: member="SDH::cSDH::GetInfo" ref="fb9751f28fde3347cccb4dbe9ecfe2e2" args="(char const *what)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char const* SDH::cSDH::GetInfo           </td>
          <td>(</td>
          <td class="paramtype">char const *&nbsp;</td>
          <td class="paramname"> <em>what</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return info according to <em>what</em> # # The following values are valid for <em>what:</em> # - "date-library" : date of the SDHLibrary-python release # - "release-library" : release name of the sdh.py python module # - "release-firmware" : release name of the SDH firmware (requires # an opened communication to the SDH) # - "date-firmware" : date of the SDH firmware (requires # an opened communication to the SDH) # - "release-soc" : release name of the SDH SoC (requires # an opened communication to the SDH) # - "date-soc" : date of the SDH SoC (requires # an opened communication to the SDH) # - "id-sdh" : ID of SDH # - "sn-sdh" : Serial number of SDH # # <dl class="user" compact><dt><b>Examples:</b></dt><dd># <div class="fragment"><pre class="fragment"><span class="preprocessor">    #    # Assuming 'hand' is a sdh.cSDH object ...</span>
<span class="preprocessor"></span><span class="preprocessor">    #</span>
<span class="preprocessor"></span><span class="preprocessor">    #    print "The SDH firmware reports release %s" % ( hand.GetInfo( "release-firmware" ) )</span>
<span class="preprocessor"></span><span class="preprocessor">    #</span>
<span class="preprocessor">    #  </span>
</pre></div> # # <hr>
 </dd></dl>

</div>
</div><p>
<a class="anchor" name="15581ff5a50219a49e3085114f289431"></a><!-- doxytag: member="SDH::cSDH::GetTemperature" ref="15581ff5a50219a49e3085114f289431" args="(std::vector&lt; int &gt; const &amp;sensors)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; SDH::cSDH::GetTemperature           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>sensors</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return temperature(s) measured within the SDH.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sensors</em>&nbsp;</td><td>- A vector of indices of temperature sensors to access.<ul>
<li>index 0 is sensor near motor of axis 0 (root)</li><li>index 1 is sensor near motor of axis 1 (proximal finger 1)</li><li>index 2 is sensor near motor of axis 2 (distal finger 1)</li><li>index 3 is sensor near motor of axis 3 (proximal finger 2)</li><li>index 4 is sensor near motor of axis 4 (distal finger 2)</li><li>index 5 is sensor near motor of axis 5 (proximal finger 3)</li><li>index 6 is sensor near motor of axis 6 (distal finger 3)</li><li>index 7 is FPGA temperature (controller chip)</li><li>index 8 is PCB temperature (Printed Circuit Board)</li></ul>
</td></tr>
  </table>
</dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd><ul>
<li>The indices in <em>sensors</em> are checked if they are valid sensor indices.</li><li>If <b>any</b> sensor index is invalid then a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
</dd></dl>
To access a single temperature sensor use <a class="el" href="class_s_d_h_1_1c_s_d_h.html#ac95911b4547325bf2f0af1a0af9e0e9">GetTemperature(int)</a>, see there.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The temperatures of the selected sensors are returned as std::vector&lt;double&gt; in the configured temperature unit system <a class="el" href="class_s_d_h_1_1c_s_d_h.html#844b1311f5be6eb5474157d9c24e7a5e" title="unit convert for temperatures: default = SDH::cSDH::uc_temperature_celsius">uc_temperature</a>.</dd></dl>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming 'hand' is a cSDH object ...</span>

          <span class="comment">// Get measured values of all sensors</span>
          std::vector&lt;double&gt; temps = hand.GetTemperature( hand.all_temperature_sensors );
          <span class="comment">// Now temps is something like { 38.500,37.250,35.750,37.250,33.500,36.500,32.250,59.625,52.500 }</span>

          <span class="comment">// Get controller temperature only:</span>
          <span class="keywordtype">double</span> temp_controller = hand.GetTemperature( 0 );
          <span class="comment">// Now temp_controller is something like 40.5</span>

          <span class="comment">// If we - for some obscure islandish reason - would want</span>
          <span class="comment">// temperatures reported in degrees fahrenheit, the unit</span>
          <span class="comment">// converter can be changed:</span>
          hand.uc_temperature = &amp;<a class="code" href="class_s_d_h_1_1c_s_d_h.html#91a8319e68109aeec7f97008572f7177" title="Converter for temperatures: external unit = degrees fahrenheit.">cSDH::uc_temperature_fahrenheit</a>;

          <span class="comment">// Get all temperaturs again:</span>
          temps = hand.GetTemperature( hand.all_temperature_sensors );
          <span class="comment">// Now temps is something like {100.0, 96.8, 92.3, 97.7, 91.8, 96.8, 90.1,  137.5,  125.2}</span>
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="a11b48c0b8104f74870378a6675b6791"></a><!-- doxytag: member="SDH::cSDH::GetTemperature" ref="a11b48c0b8104f74870378a6675b6791" args="(int iSensor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SDH::cSDH::GetTemperature           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iSensor</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#448d044af20e6a1d2ffe674ebd0ea1e7">GetTemperature(std::vector&lt;int&gt;const&amp;)</a>, just for one sensor <em>iSensor</em> and returning a single temperature as double. 
</div>
</div><p>
<a class="anchor" name="2cd8b7c3dcc184de22117c8b17088c10"></a><!-- doxytag: member="SDH::cSDH::OpenRS232" ref="2cd8b7c3dcc184de22117c8b17088c10" args="(int _port=0, unsigned long _baudrate=115200, double _timeout=-1, char const *_device_format_string=&quot;/dev/ttyS%d&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SDH::cSDH::OpenRS232           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>_port</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>_baudrate</em> = <code>115200</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>_timeout</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&nbsp;</td>
          <td class="paramname"> <em>_device_format_string</em> = <code>&quot;/dev/ttyS%<a class="el" href="class_s_d_h_1_1c_s_d_h.html#87537330abbd2528f9dccaa105e427f6">d</a>&quot;</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Open connection to SDH via RS232.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_port</em>&nbsp;</td><td>: The number of the serial port to use. The default value port=0 refers to 'COM1' in Windows and to the corresponding '/dev/ttyS0' in Linux. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_baudrate,:</em>&nbsp;</td><td>the baudrate in bit/s, the default is 115200 which happens to be the default for the SDH too </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_timeout</em>&nbsp;</td><td>: The timeout to use:<ul>
<li>-1 : wait forever</li><li>T : wait for T seconds </li></ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_device_format_string</em>&nbsp;</td><td>: a format string (C string) for generating the device name, like "/dev/ttyS%d" (default) or "/dev/ttyUSB%d". Must contain a d where the port number should be inserted. This char array is duplicated on construction When compiled with VCC (MS-Visual C++) then this is not used. </td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">         <span class="comment">// Assuming 'hand' is a cSDH object ...</span>

         <span class="comment">// Open connection to SDH via default port:</span>
         hand.OpenRS232();

         <span class="comment">// Use a different port 2 == COM3 == /dev/ttyS2 for a second hand "hand2":</span>
         <a class="code" href="class_s_d_h_1_1c_s_d_h.html#e1999e6293f4e503d6d629adcee2e958" title="Constructor of cSDH class.">cSDH</a> hand2();
         hand2.OpenRS232( 2 );

         <span class="comment">// Linux only: Use a different USB to RS232 device on port 3 /dev/ttyUSB3 for a third hand "hand3":</span>
         <a class="code" href="class_s_d_h_1_1c_s_d_h.html#e1999e6293f4e503d6d629adcee2e958" title="Constructor of cSDH class.">cSDH</a> hand3();
         hand2.OpenRS232( 3, 115200, -1, <span class="stringliteral">"/dev/ttyUSB%d"</span> );
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="d747bd92682e9983b5a880722cbd1cb0"></a><!-- doxytag: member="SDH::cSDH::OpenCAN_ESD" ref="d747bd92682e9983b5a880722cbd1cb0" args="(int _net=0, unsigned long _baudrate=1000000, double _timeout=0.0, Int32 _id_read=43, Int32 _id_write=42)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SDH::cSDH::OpenCAN_ESD           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>_net</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>_baudrate</em> = <code>1000000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>_timeout</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_s_d_h.html#0592c3b027265b9c6d6625e5f7cc189f">Int32</a>&nbsp;</td>
          <td class="paramname"> <em>_id_read</em> = <code>43</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_s_d_h.html#0592c3b027265b9c6d6625e5f7cc189f">Int32</a>&nbsp;</td>
          <td class="paramname"> <em>_id_write</em> = <code>42</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Open connection to SDH via CAN using an ESD CAN card. If the library was compiled without ESD CAN support then this will just throw an exception. See setting for WITH_ESD_CAN in the top level makefile.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_net</em>&nbsp;</td><td>: The ESD CAN net number of the CAN port to use. (default: 0) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_baudrate</em>&nbsp;</td><td>: the CAN baudrate in bit/s. Only some bitrates are valid: (1000000 (default),800000,500000,250000,125000,100000,50000,20000,10000) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_timeout</em>&nbsp;</td><td>: The timeout to use:<ul>
<li>&lt;= 0 : wait forever (default)</li><li>T : wait for T seconds </li></ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_id_read</em>&nbsp;</td><td>- the CAN ID to use for reading (The SDH sends data on this ID, default=43=0x02b) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_id_write</em>&nbsp;</td><td>- the CAN ID to use for writing (The SDH receives data on this ID, default=42=0x02a)</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">         <span class="comment">// Assuming 'hand' is a cSDH object ...</span>

         <span class="comment">// use default parameters for net, baudrate, timeout and IDs</span>
         hand.OpenCAN_ESD( );

         <span class="comment">// use non default settings:</span>
         <span class="comment">// net=1, baudrate=500000, timeout=1.0, id_read=0x143, id_write=0x142</span>
         hand.OpenCAN_ESD( 1, 500000, 1.0, 0x143, 0x142 );
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="ff5d621140324dc94bba1d78e2eb9732"></a><!-- doxytag: member="SDH::cSDH::OpenCAN_ESD" ref="ff5d621140324dc94bba1d78e2eb9732" args="(NTCAN_HANDLE _ntcan_handle, double _timeout=0.0, Int32 _id_read=43, Int32 _id_write=42)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SDH::cSDH::OpenCAN_ESD           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_s_d_h.html#d644157c3633dee69e0523c30272bc43">NTCAN_HANDLE</a>&nbsp;</td>
          <td class="paramname"> <em>_ntcan_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>_timeout</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_s_d_h.html#0592c3b027265b9c6d6625e5f7cc189f">Int32</a>&nbsp;</td>
          <td class="paramname"> <em>_id_read</em> = <code>43</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_s_d_h.html#0592c3b027265b9c6d6625e5f7cc189f">Int32</a>&nbsp;</td>
          <td class="paramname"> <em>_id_write</em> = <code>42</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Open connection to SDH via CAN using an ESD CAN card using an existing handle. If the library was compiled without ESD CAN support then this will just throw an exception. See setting for WITH_ESD_CAN in the top level makefile.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_ntcan_handle</em>&nbsp;</td><td>: The ESD CAN handle to reuse to connect to the ESD CAN driver </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_timeout</em>&nbsp;</td><td>: The timeout to use:<ul>
<li>&lt;= 0 : wait forever (default)</li><li>T : wait for T seconds </li></ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_id_read</em>&nbsp;</td><td>- the CAN ID to use for reading (The SDH sends data on this ID, default=43=0x2a) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_id_write</em>&nbsp;</td><td>- the CAN ID to use for writing (The SDH receives data on this ID, default=42=0x2a)</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">         <span class="comment">// Assuming 'hand' is a cSDH object ...</span>
         <span class="comment">// and 'handle' is a valid ESD NTCAN_HANDLE</span>

         <span class="comment">// use default parameters for timeout and IDs</span>
         hand.OpenCAN_ESD( handle );

         <span class="comment">// or use non default settings:</span>
         <span class="comment">// timeout=1.0, id_read=0x143, id_write=0x142</span>
         hand.OpenCAN_ESD( handle, 1.0, 0x143, 0x142 );
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="f039da74d116fffd0373a5777c4d3e84"></a><!-- doxytag: member="SDH::cSDH::OpenCAN_PEAK" ref="f039da74d116fffd0373a5777c4d3e84" args="(unsigned long _baudrate=1000000, double _timeout=0.0, Int32 _id_read=43, Int32 _id_write=42, const char *device=&quot;/dev/pcanusb0&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SDH::cSDH::OpenCAN_PEAK           </td>
          <td>(</td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>_baudrate</em> = <code>1000000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>_timeout</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_s_d_h.html#0592c3b027265b9c6d6625e5f7cc189f">Int32</a>&nbsp;</td>
          <td class="paramname"> <em>_id_read</em> = <code>43</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_s_d_h.html#0592c3b027265b9c6d6625e5f7cc189f">Int32</a>&nbsp;</td>
          <td class="paramname"> <em>_id_write</em> = <code>42</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>device</em> = <code>&quot;/dev/pcanusb0&quot;</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Open connection to SDH via CAN using an PEAK CAN card. If the library was compiled without PEAK CAN support then this will just throw an exception. See setting for WITH_PEAK_CAN in the top level makefile.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_baudrate</em>&nbsp;</td><td>: the CAN baudrate in bit/s. Only some bitrates are valid: (1000000 (default),800000,500000,250000,125000,100000,50000,20000,10000) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_timeout</em>&nbsp;</td><td>: The timeout to use:<ul>
<li>&lt;= 0 : wait forever (default)</li><li>T : wait for T seconds </li></ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_id_read</em>&nbsp;</td><td>- the CAN ID to use for reading (The SDH sends data on this ID, default=43=0x02b) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_id_write</em>&nbsp;</td><td>- the CAN ID to use for writing (The SDH receives data on this ID, default=42=0x02a) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_device</em>&nbsp;</td><td>- the PEAK device name. Used for the Linux char dev driver only. default="/dev/pcanusb0"</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">         <span class="comment">// Assuming 'hand' is a cSDH object ...</span>

         <span class="comment">// use default parameters for baudrate, timeout, IDs and device</span>
         hand.OpenCAN_PEAK( );

         <span class="comment">// use non default settings:</span>
         <span class="comment">// baudrate=500000, timeout=1.0, id_read=0x143, id_write=0x142, , const char *device="/dev/pcanusb1"</span>
         hand.OpenCAN_PEAK( 500000, 1.0, 0x143, 0x142, <span class="stringliteral">"/dev/pcanusb1"</span> );
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="516c1bb43d9de5c9af592898e4ae825c"></a><!-- doxytag: member="SDH::cSDH::OpenCAN_PEAK" ref="516c1bb43d9de5c9af592898e4ae825c" args="(PCAN_HANDLE _handle, double _timeout=0.0, Int32 _id_read=43, Int32 _id_write=42)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cSDH::OpenCAN_PEAK           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_s_d_h.html#17953114f0d151147e596e49e698dcf7">PCAN_HANDLE</a>&nbsp;</td>
          <td class="paramname"> <em>_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>_timeout</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_s_d_h.html#0592c3b027265b9c6d6625e5f7cc189f">Int32</a>&nbsp;</td>
          <td class="paramname"> <em>_id_read</em> = <code>43</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_s_d_h.html#0592c3b027265b9c6d6625e5f7cc189f">Int32</a>&nbsp;</td>
          <td class="paramname"> <em>_id_write</em> = <code>42</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Open connection to SDH via CAN using an PEAK CAN card using an existing handle. If the library was compiled without PEAK CAN support then this will just throw an exception. See setting for WITH_PEAK_CAN in the top level makefile.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_handle</em>&nbsp;</td><td>: The PEAK CAN handle to reuse to connect to the PEAK CAN driver </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_timeout</em>&nbsp;</td><td>: The timeout to use:<ul>
<li>&lt;= 0 : wait forever (default)</li><li>T : wait for T seconds </li></ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_id_read</em>&nbsp;</td><td>- the CAN ID to use for reading (The SDH sends data on this ID, default=43=0x2a) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_id_write</em>&nbsp;</td><td>- the CAN ID to use for writing (The SDH receives data on this ID, default=42=0x2a) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_device</em>&nbsp;</td><td>- the PEAK device name. Used for the Linux char dev driver only. default="/dev/pcanusb0"</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">         <span class="comment">// Assuming 'hand' is a cSDH object ...</span>
         <span class="comment">// and 'handle' is a valid PEAK NTCAN_HANDLE</span>

         <span class="comment">// use default parameters for timeout and IDs</span>
         hand.OpenCAN_PEAK( handle );

         <span class="comment">// or use non default settings:</span>
         <span class="comment">// timeout=1.0, id_read=0x143, id_write=0x142</span>
         hand.OpenCAN_PEAK( handle, 1.0, 0x143, 0x142 );
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="a2c184b28b70513d26f9b711c7d10ef4"></a><!-- doxytag: member="SDH::cSDH::Close" ref="a2c184b28b70513d26f9b711c7d10ef4" args="(bool leave_enabled=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SDH::cSDH::Close           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>leave_enabled</em> = <code>false</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Close connection to SDH.<p>
The default behaviour is to <b>not</b> leave the controllers of the SDH enabled (to prevent overheating). To keep the controllers enabled (e.g. to keep the finger axes actively in position) set <em>leave_enabled</em> to <code>true</code>. Only already enabled axes will be left enabled.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>leave_enabled</em>&nbsp;</td><td>- Flag: true to leave the controllers on, false (default) to disable the controllers (switch powerless)</td></tr>
  </table>
</dl>
This throws a (cSDHErrorCommunication*) exception if the connection was not opened before.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">         <span class="comment">// Assuming 'hand' is a cSDH object ...</span>

         <span class="comment">// Close connection to SDH, power off controllers:</span>
         hand.Close();

         <span class="comment">// To leave the already enabled controllers enabled:</span>
         hand.Close( <span class="keyword">true</span> );
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="49e010285f563e7a4ae319018bd7c09f"></a><!-- doxytag: member="SDH::cSDH::IsOpen" ref="49e010285f563e7a4ae319018bd7c09f" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool SDH::cSDH::IsOpen           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw ()<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return true if connection to SDH firmware/hardware is open. 
<p>Implements <a class="el" href="class_s_d_h_1_1c_s_d_h_base.html#8bf9a947311cebe7d0eb37bfb0bb5761">SDH::cSDHBase</a>.</p>

</div>
</div><p>
<a class="anchor" name="06652e793265a38cf9cd68534d70338f"></a><!-- doxytag: member="SDH::cSDH::EmergencyStop" ref="06652e793265a38cf9cd68534d70338f" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SDH::cSDH::EmergencyStop           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Stop movement of all axes of the SDH and switch off the controllers<p>
This command will always be executed sequentially: it will return only after the SDH has confirmed the emergency stop.<p>
<dl compact><dt><b><a class="el" href="bug.html#_bug000016">Bug:</a></b></dt><dd>For now this will <b>NOT</b> work while a <a class="el" href="class_s_d_h_1_1c_s_d_h.html#1af5350393024630009896e5191a5f94">GripHand()</a> command is executing, even if that was initiated non-sequentially!</dd></dl>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">         <span class="comment">// Assuming 'hand' is a cSDH object ...</span>

         <span class="comment">// Perform an emergency stop:</span>
         hand.EmergencyStop();
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="b358488ff0109fd5ea3d494511bbc332"></a><!-- doxytag: member="SDH::cSDH::Stop" ref="b358488ff0109fd5ea3d494511bbc332" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SDH::cSDH::Stop           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Stop movement of all axes but keep controllers on<p>
This command will always be executed sequentially: it will return only after the SDH has confirmed the stop<p>
<dl compact><dt><b><a class="el" href="bug.html#_bug000017">Bug:</a></b></dt><dd>For now this will <b>NOT</b> work while a <a class="el" href="class_s_d_h_1_1c_s_d_h.html#1af5350393024630009896e5191a5f94">GripHand()</a> command is executing, even if that was initiated non-sequentially!</dd></dl>
<dl compact><dt><b><a class="el" href="bug.html#_bug000017">Bug:</a></b></dt><dd>With SDH firmware &lt; 0.0.2.7 this made the axis jerk in eCT_POSE controller type. This is resolved in SDH firmware 0.0.2.7 for the eCT_POSE controller type with velocity profile eVP_RAMP. For the eCT_POSE controller type with velocity profile eVP_SIN_SQUARE changing target points/ velocities while moving will still make the axes jerk. <br>
<b>=&gt; Partly resolved in SDH firmware 0.0.2.7</b></dd></dl>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">         <span class="comment">// Assuming 'hand' is a cSDH object ...</span>

         <span class="comment">// Perform a stop:</span>
         hand.Stop();
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="2d385f777077fe43c812120642145289"></a><!-- doxytag: member="SDH::cSDH::SetController" ref="2d385f777077fe43c812120642145289" args="(cSDHBase::eControllerType controller)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SDH::cSDH::SetController           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_s_d_h_1_1c_s_d_h_base.html#610f29a16806030c12e25bf83d89abbd">cSDHBase::eControllerType</a>&nbsp;</td>
          <td class="paramname"> <em>controller</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw ( <a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>* )</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the type of axis controller to be used in the SDH<p>
With SDH firmware &gt;= 0.0.2.7 this will automatically set valid default values for all target velocities, accelerations and positions in the SDH firmware, according to the <em>controller</em> type:<ul>
<li>eCT_POSE:<ul>
<li>target velocities will be set to default (40 deg/s)</li><li>target accelerations will be set to default (100 deg/(s*s))</li><li>target positions will be set to default (0.0 deg)</li></ul>
</li><li>eCT_VELOCITY:<ul>
<li>target velocities will be set to default (0 deg/s)</li></ul>
</li><li>eCT_VELOCITY_ACCELERATION:<ul>
<li>target velocities will be set to default (0 deg/s)</li><li>target accelerations will be set to default (100 deg/(s*s))</li></ul>
</li></ul>
<p>
This will also adjust the lower limits of the allowed velocities here in the SDHLibrary, since the eCT_POSE controller allows only positive velocities while the eCT_VELOCITY and eCT_VELOCITY_ACCELERATION controllers require also negative velocities.<p>
<dl class="attention" compact><dt><b>Attention:</b></dt><dd>The availability of a controller type depends on the SDH firmware of the attached SDH and is checked here.<ul>
<li>firmware &lt;= 0.0.2.5: only eCT_POSE</li><li>firmware &gt;= 0.0.2.6: eCT_POSE, eCT_VELOCITY, eCT_VELOCITY_ACCELERATION</li></ul>
</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>controller</em>&nbsp;</td><td>- identifier of controller to set. Valid values are defined in eControllerType</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">         <span class="comment">// Assuming 'hand' is a cSDH object ...</span>

         <span class="comment">// Set the pose controller in the SDH</span>
         <span class="comment">// (see e.g. demo-simple.cpp, demo-simple2.cpp, demo-simple3.cpp for further examples)</span>
         hand.SetController( hand.eCT_POSE );

         <span class="comment">// Set the simple velocity controller in the SDH:</span>
         hand.SetController( hand.eCT_VELOCITY );

         <span class="comment">// Set the velocity with acceleration ramp controller in the SDH:</span>
         <span class="comment">// (see e.g. demo-velocity-acceleration.cpp for further examples)</span>
         hand.SetController( hand.eCT_VELOCITY_ACCELERATION );
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="295dacc909e8e377ce4894caafbd3efd"></a><!-- doxytag: member="SDH::cSDH::GetController" ref="295dacc909e8e377ce4894caafbd3efd" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_d_h_1_1c_s_d_h_base.html#610f29a16806030c12e25bf83d89abbd">eControllerType</a> SDH::cSDH::GetController           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the type of axis controller used in the SDH<p>
The currently set controller type will be queried and returned (One of eControllerType)<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">        <span class="comment">// Assuming 'hand' is a sdh.cSDH object ...</span>

        <span class="comment">// Get the controller type of the attached SDH:</span>
        ct = hand.GetController();

        <span class="comment">// Print result, numerically and symbolically</span>
        std::cout &lt;&lt; <span class="stringliteral">"Currently the axis controller type is set to "</span> &lt;&lt; ct;
        std::cout &lt;&lt; <span class="stringliteral">"("</span> &lt;&lt; <a class="code" href="class_s_d_h_1_1c_s_d_h_base.html#09f1b8791fdc34a28a4e55b66c478c31" title="Return a ptr to a (static) string describing controller type controller_Type.">GetStringFromControllerType</a>(ct) &lt;&lt; <span class="stringliteral">")\n"</span>;
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="2956f857a687f88a647969ec82d08756"></a><!-- doxytag: member="SDH::cSDH::SetVelocityProfile" ref="2956f857a687f88a647969ec82d08756" args="(eVelocityProfile velocity_profile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SDH::cSDH::SetVelocityProfile           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_s_d_h_1_1c_s_d_h_base.html#024f2645cbaa93a6cca8632a56408cc1">eVelocityProfile</a>&nbsp;</td>
          <td class="paramname"> <em>velocity_profile</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the type of velocity profile to be used in the SDH<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>velocity_profile</em>&nbsp;</td><td>- Name or number of velocity profile to set. Valid values are defined in eVelocityProfileType</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">        <span class="comment">// Assuming 'hand' is a cSDH object ...</span>

        <span class="comment">// Set the sin square velocity profile in the SDH:</span>
        hand.SetVelocityProfile( hand.eVP_SIN_SQUARE );

        <span class="comment">// Or else set the ramp velocity profile in the SDH:</span>
        hand.SetVelocityProfile( hand.eVP_RAMP )
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="ad8d32000ee2472270a449082d7d9ada"></a><!-- doxytag: member="SDH::cSDH::GetVelocityProfile" ref="ad8d32000ee2472270a449082d7d9ada" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_d_h_1_1c_s_d_h_base.html#024f2645cbaa93a6cca8632a56408cc1">eVelocityProfile</a> SDH::cSDH::GetVelocityProfile           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the type of velocity profile used in the SDH<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the currently set velocity profile as integer, see eVelocityProfileType</dd></dl>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">        <span class="comment">// Assuming 'hand' is a cSDH object ...</span>

        <span class="comment">// Get the velocity profile from the SDH:</span>
        velocity_profile = hand.GetVelocityProfile();
        <span class="comment">// now velocity_profile is something like eVP_SIN_SQUARE or eVP_RAMP</span>
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="9aeda8b024547100a1d1ccb349ff2414"></a><!-- doxytag: member="SDH::cSDH::SetAxisMotorCurrent" ref="9aeda8b024547100a1d1ccb349ff2414" args="(std::vector&lt; int &gt; const &amp;axes, std::vector&lt; double &gt; const &amp;motor_currents, eMotorCurrentMode mode=eMCM_MOVE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SDH::cSDH::SetAxisMotorCurrent           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>axes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>motor_currents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#712b0b80382f1e1e5229ad7bec6cdc4d">eMotorCurrentMode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em> = <code>eMCM_MOVE</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the maximum allowed motor current(s) for axes.<p>
The maximum allowed motor currents are sent to the SDH. The motor currents can be stored:<ul>
<li>axis specific</li><li>mode specific (see <a class="el" href="class_s_d_h_1_1c_s_d_h.html#712b0b80382f1e1e5229ad7bec6cdc4d" title="the motor current can be set specifically for these modes:">eMotorCurrentMode</a>)</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axes</em>&nbsp;</td><td>- A vector of axis indices to access. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>motor_currents</em>&nbsp;</td><td>- A vector of motor currents to set. If any of the numbers in the vector is <code>NaN</code> (Not a Number) then the currently set axis motor current will be kept for the corresponding axis. The value(s) are expected in the configured motor current unit system <a class="el" href="class_s_d_h_1_1c_s_d_h.html#57bb98bd30adf2189a62f31388bc6bae" title="unit converter for motor curent: default = SDH::cSDH::uc_motor_current_ampere">uc_motor_current</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>- the mode to set the maximum motor current for. One of the <a class="el" href="class_s_d_h_1_1c_s_d_h.html#712b0b80382f1e1e5229ad7bec6cdc4d" title="the motor current can be set specifically for these modes:">eMotorCurrentMode</a> modes.</td></tr>
  </table>
</dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd><ul>
<li>The lengths of the <em>axes</em> and <em>motor_currents</em> vector must match.</li><li>The indices can be given in any order, but the order of their elements must match, i.e. <code>motor_currents</code>[i] will be applied to axis <code>axes</code>[i] (not axis <code>i</code>).</li><li>The indices are checked if they are valid axis indices.</li><li>The motor currents are checked if they are in the allowed range [0 .. <a class="el" href="class_s_d_h_1_1c_s_d_h.html#c2a56629fe34ac72d6cc1ad5cbde2ed0" title="Maximum allowed motor currents (in internal units (Ampere)), including the virtual...">f_max_motor_current_v</a>], i.e. it is checked that <code>motor_currents</code>[i], converted to internal units, is in <code></code>[0 .. <code>f_max_motor_currents_v</code>[axes[i]]].</li><li>If <b>any</b> index or value is invalid then <b>none</b> of the specified values is sent to the SDH, instead a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
</dd></dl>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#fc3046c2e957ee95eda1e61dde389adf">SetAxisMotorCurrent(int,double,eMotorCurrentMode)</a> for an overloaded variant to set a single axis motor current or to set the same motor current for all axes.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming "hand" is a cSDH object ...</span>

          <span class="comment">// Set maximum allowed motor current of all axes to the given values in mode "eMCM_MOVE"::</span>
          std::vector&lt;double&gt; all_motor_currents;
          all_motor_currents.push_back( 0.0 );
          all_motor_currents.push_back( 0.1 );
          all_motor_currents.push_back( 0.2 );
          all_motor_currents.push_back( 0.3 );
          all_motor_currents.push_back( 0.4 );
          all_motor_currents.push_back( 0.5 );
          all_motor_currents.push_back( 0.6 );

          hand.SetAxisMotorCurrent( hand.all_axes, all_motor_currents );


          <span class="comment">// Set maximum allowed motor current of all axes to 0.1 A in mode "eMCM_HOLD":</span>
          hand.SetAxisMotorCurrent( hand.All, 1.0, <a class="code" href="class_s_d_h_1_1c_s_d_h.html#712b0b80382f1e1e5229ad7bec6cdc4d690e9bb2611fe2a597bb2b9443856fe1" title="The motor currents used after &amp;quot;gripping&amp;quot; with a GripHand() command (i.e...">eMCM_HOLD</a> );

          <span class="comment">// Set maximum allowed motor current of axis 3 to 0.75 A in mode "eMCM_MOVE":</span>
          hand.SetAxisMotorCurrent( 3, 0.75, <a class="code" href="class_s_d_h_1_1c_s_d_h.html#712b0b80382f1e1e5229ad7bec6cdc4da0a075991ceba063aff574398f8ff05e" title="The motor currents used while &amp;quot;moving&amp;quot; with a MoveHand() or MoveFinger()...">eMCM_MOVE</a> );

          <span class="comment">// Set maximum allowed motor current of for axis 0, 4 and 2 to 0.0 A,</span>
          <span class="comment">// 0.4 A and 0.2 A respectively in mode "eMCM_GRIP"</span>
          std::vector&lt;int&gt; axes042;
          axes042.push_back( 0 );
          axes042.push_back( 4 );
          axes042.push_back( 2 );
          std::vector&lt;double&gt; motor_currents042;
          motor_currents042.push_back( 0.0 );
          motor_currents042.push_back( 0.4 );
          motor_currents042.push_back( 0.2 );

          hand.SetAxisMotorCurrent( axes042, states042, <a class="code" href="class_s_d_h_1_1c_s_d_h.html#712b0b80382f1e1e5229ad7bec6cdc4d63872c18691513275682b347c68732b5" title="The motor currents used while &amp;quot;gripping&amp;quot; with a GripHand() command.">eMCM_GRIP</a> );
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="599cfc7a5e6cad3f48509612fb8061c9"></a><!-- doxytag: member="SDH::cSDH::SetAxisMotorCurrent" ref="599cfc7a5e6cad3f48509612fb8061c9" args="(int iAxis, double motor_current, eMotorCurrentMode mode=eMCM_MOVE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SDH::cSDH::SetAxisMotorCurrent           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iAxis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>motor_current</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#712b0b80382f1e1e5229ad7bec6cdc4d">eMotorCurrentMode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em> = <code>eMCM_MOVE</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#483d0e5db3acab3dbdf012fdafd49089">SetAxisMotorCurrent(std::vector&lt;int&gt;const&amp;,std::vector&lt;double&gt;const&amp;,eMotorCurrentMode)</a>, just for a single axis <em>iAxis</em> and a single motor current <em>motor_current</em>, see there.<p>
If <em>iAxis</em> is <a class="el" href="class_s_d_h_1_1c_s_d_h_base.html#ab61ed07c53bf24bc87ff5103e74f45a8e09b2cc8bc776a705cd2665fc555881" title="A meta-value that means &quot;access all possible values&quot;.">All</a> then <em>motor_current</em> is set for all axes. 
</div>
</div><p>
<a class="anchor" name="ab0fff919290a372837c42f37831ba58"></a><!-- doxytag: member="SDH::cSDH::GetAxisMotorCurrent" ref="ab0fff919290a372837c42f37831ba58" args="(std::vector&lt; int &gt; const &amp;axes, eMotorCurrentMode mode=eMCM_MOVE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; SDH::cSDH::GetAxisMotorCurrent           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>axes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#712b0b80382f1e1e5229ad7bec6cdc4d">eMotorCurrentMode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em> = <code>eMCM_MOVE</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the maximum allowed motor current(s) of axis(axes).<p>
The maximum allowed motor currents are read from the SDH. The motor currents are stored:<ul>
<li>axis specific</li><li>mode specific (see eMotorCurrentMode)</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axes</em>&nbsp;</td><td>- A vector of axis indices to access. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>- the mode to set the maximum motor current for. One of the <a class="el" href="class_s_d_h_1_1c_s_d_h.html#712b0b80382f1e1e5229ad7bec6cdc4d" title="the motor current can be set specifically for these modes:">eMotorCurrentMode</a> modes.</td></tr>
  </table>
</dl>
<ul>
<li>The indices in <em>axes</em> are checked if they are valid axis indices.</li><li>If <b>any</b> axis index is invalid then a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>A vector of the motor currents of the selected axes.</li><li>The values are converted to the selected external unit system using the configured <a class="el" href="class_s_d_h_1_1c_s_d_h.html#57bb98bd30adf2189a62f31388bc6bae" title="unit converter for motor curent: default = SDH::cSDH::uc_motor_current_ampere">uc_motor_current</a> unit converter object.</li><li>The order of the elements of the <em>axes</em> vector and the returned values vector <em>rv</em> matches. I.e. <code>rv</code>[i] will be the value of axis <code>axes</code>[i] (not axis <code>i</code>).</li></ul>
</dd></dl>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#7a5d62417bdf142e6cf57b40277e500a">GetAxisMotorCurrent(int,eMotorCurrentMode)</a> for an overloaded variant to access a single axis.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming "hand" is a cSDH object ...</span>

          <span class="comment">// Get maximum allowed motor currents of all axes</span>
          std::vector&lt;double&gt; v = hand.GetAxisMotorCurrent( hand.all_axes );
          <span class="comment">// now v is something like {0.1, 0.2, 0.3, 0.4, 0.5, 0,6, 0.7}</span>

          <span class="comment">// Get maximum allowed motor current of axis 3 in mode "eMCM_MOVE"</span>
          <span class="keywordtype">double</span> mc3 = hand.GetAxisMotorCurrent( 3, <a class="code" href="class_s_d_h_1_1c_s_d_h.html#712b0b80382f1e1e5229ad7bec6cdc4da0a075991ceba063aff574398f8ff05e" title="The motor currents used while &amp;quot;moving&amp;quot; with a MoveHand() or MoveFinger()...">eMCM_MOVE</a> );
          <span class="comment">// mc3 is now something like 0.75</span>

          <span class="comment">// Get maximum allowed motor current of axis 3 and 5 in mode "eMCM_GRIP"</span>
          std::vector&lt;int&gt; axes35;
          axes35.push_back( 3 );
          axes35.push_back( 5 );

          v = hand.GetAxisMotorCurrent( axes35, <a class="code" href="class_s_d_h_1_1c_s_d_h.html#712b0b80382f1e1e5229ad7bec6cdc4d63872c18691513275682b347c68732b5" title="The motor currents used while &amp;quot;gripping&amp;quot; with a GripHand() command.">eMCM_GRIP</a> );
          <span class="comment">// now v is something like {0.5,0.5};</span>
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="60b13d32ac395e20429a7fdcc77d9d9e"></a><!-- doxytag: member="SDH::cSDH::GetAxisMotorCurrent" ref="60b13d32ac395e20429a7fdcc77d9d9e" args="(int iAxis, eMotorCurrentMode mode=eMCM_MOVE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SDH::cSDH::GetAxisMotorCurrent           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iAxis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#712b0b80382f1e1e5229ad7bec6cdc4d">eMotorCurrentMode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em> = <code>eMCM_MOVE</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#0a45116eb8edbb9c5700431d67968d6e">GetAxisMotorCurrent(std::vector&lt;int&gt;const&amp;,eMotorCurrentMode)</a>, just for a single axis, see there for details and examples. 
</div>
</div><p>
<a class="anchor" name="a276e94651c0ad40e569e43486b1b1ef"></a><!-- doxytag: member="SDH::cSDH::SetAxisEnable" ref="a276e94651c0ad40e569e43486b1b1ef" args="(std::vector&lt; int &gt; const &amp;axes, std::vector&lt; double &gt; const &amp;states)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SDH::cSDH::SetAxisEnable           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>axes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>states</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set enabled/disabled state of axis controller(s).<p>
The controllers of the selected axes are enabled/disabled in the SDH. Disabled axes are not powered and thus might not remain in their current pose due to gravity, inertia or other external influences. But to prevent overheating the axis controllers should be switched of when not needed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axes</em>&nbsp;</td><td>- A vector of axis indices to access. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>states</em>&nbsp;</td><td>- A vector of enabled states (0 = disabled, !=0 = enabled) to set. If any of the numbers in the vector is <code>NaN</code> (Not a Number) then the currently set enabled state will be kept for the corresponding axis.</td></tr>
  </table>
</dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd><ul>
<li>The lengths of the <em>axes</em> and <em>states</em> vector must match.</li><li>The indices can be given in any order, but the order of their elements must match, i.e. <code>state</code>[i] will be applied to axis <code>axes</code>[i] (not axis <code>i</code>).</li><li>The indices are checked if they are valid axis indices.</li><li>If <b>any</b> index is invalid then <b>none</b> of the specified values is sent to the SDH, instead a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
</dd></dl>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#988759f8400905534fa5e5bcc032dbf4">SetAxisEnable(int,double)</a>, <a class="el" href="class_s_d_h_1_1c_s_d_h.html#60975160fe4a5cc7d1f7f80d5ab05a1c">SetAxisEnable(int,bool)</a> for overloaded variants to set a single axis enabled/disabled or to set the same state for all axes. See further <a class="el" href="class_s_d_h_1_1c_s_d_h.html#40df6819257ce8634e8d0db4b678cfef">SetAxisEnable(std::vector&lt;int&gt;const&amp;,std::vector&lt;bool&gt;const&amp;)</a> for a variant that accepts a <code>bool</code> vector for the states to set.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming 'hand' is a cSDH object ...</span>

          <span class="comment">// Enable all axes:</span>
          hand.SetAxisEnable( hand.all_axes, hand.ones_v );

          <span class="comment">// Disable all axes:</span>
          hand.SetAxisEnable( <a class="code" href="class_s_d_h_1_1c_s_d_h_base.html#ab61ed07c53bf24bc87ff5103e74f45a8e09b2cc8bc776a705cd2665fc555881" title="A meta-value that means &amp;quot;access all possible values&amp;quot;.">All</a>, 0 );

          <span class="comment">// Enable axis 0 and 2 while disabling axis 4:</span>
          std::vector&lt;int&gt; axes042;
          axes042.push_back( 0 );
          axes042.push_back( 4 );
          axes042.push_back( 2 );

          std::vector&lt;double&gt; states042;
          states042.push_back( 1.0 );
          states042.push_back( 0.0 );
          states042.push_back( 1.0 );

          hand.SetAxisEnable( axes042, states042 );


          <span class="comment">// Disable axis 2</span>
          hand.SetAxisEnable( 2, <span class="keyword">false</span> );
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="531b4a64ac39c61db3214fb9d00ed438"></a><!-- doxytag: member="SDH::cSDH::SetAxisEnable" ref="531b4a64ac39c61db3214fb9d00ed438" args="(int iAxis=All, double state=1.0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SDH::cSDH::SetAxisEnable           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iAxis</em> = <code>All</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>state</em> = <code>1.0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#270bf0af4a0bb3f3e8cbe4e1931d7dfd">SetAxisEnable(std::vector&lt;int&gt;const&amp;,std::vector&lt;double&gt;const&amp;)</a>, just for a single axis <em>iAxis</em> and a single axis state <em>state</em>, see there.<p>
If <em>iAxis</em> is <a class="el" href="class_s_d_h_1_1c_s_d_h_base.html#ab61ed07c53bf24bc87ff5103e74f45a8e09b2cc8bc776a705cd2665fc555881" title="A meta-value that means &quot;access all possible values&quot;.">All</a> then <em>state</em> is applied to all axes. 
</div>
</div><p>
<a class="anchor" name="6f10f412bce390ed85af76086e666d77"></a><!-- doxytag: member="SDH::cSDH::SetAxisEnable" ref="6f10f412bce390ed85af76086e666d77" args="(std::vector&lt; int &gt; const &amp;axes, std::vector&lt; bool &gt; const &amp;states)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SDH::cSDH::SetAxisEnable           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>axes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>states</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#270bf0af4a0bb3f3e8cbe4e1931d7dfd">SetAxisEnable(std::vector&lt;int&gt;const&amp;,std::vector&lt;double&gt;const&amp;)</a>, just accepting a vector of <code>bool</code> values as states, see there. 
</div>
</div><p>
<a class="anchor" name="6418b2f6f2acc91dce5c7347652a4ba3"></a><!-- doxytag: member="SDH::cSDH::SetAxisEnable" ref="6418b2f6f2acc91dce5c7347652a4ba3" args="(int iAxis=All, bool state=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SDH::cSDH::SetAxisEnable           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iAxis</em> = <code>All</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>state</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#270bf0af4a0bb3f3e8cbe4e1931d7dfd">SetAxisEnable(std::vector&lt;int&gt;const&amp;,std::vector&lt;double&gt;const&amp;)</a>, just for a single axis <em>iAxis</em> and a single axis state <em>state</em>, see there.<p>
If <em>iAxis</em> is <a class="el" href="class_s_d_h_1_1c_s_d_h_base.html#ab61ed07c53bf24bc87ff5103e74f45a8e09b2cc8bc776a705cd2665fc555881" title="A meta-value that means &quot;access all possible values&quot;.">All</a> then <em>state</em> is applied to all axes. 
</div>
</div><p>
<a class="anchor" name="530e11bf3b8bf7fdba54a5c9c7150cfc"></a><!-- doxytag: member="SDH::cSDH::GetAxisEnable" ref="530e11bf3b8bf7fdba54a5c9c7150cfc" args="(std::vector&lt; int &gt; const &amp;axes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; SDH::cSDH::GetAxisEnable           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>axes</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get enabled/disabled state of axis controller(s).<p>
The enabled/disabled state of the controllers of the selected axes is read from the SDH.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axes</em>&nbsp;</td><td>- A vector of axis indices to access.</td></tr>
  </table>
</dl>
<ul>
<li>The indices in <em>axes</em> are checked if they are valid axis indices.</li><li>If <b>any</b> axis index is invalid then a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>A vector of enabled/disabled states as doubles (0=disabled, 1.0=enabled) of the selected axes.</li><li>The order of the elements of the <em>axes</em> vector and the returned values vector <em>rv</em> matches. I.e. <code>rv</code>[i] will be the value of axis <code>axes</code>[i] (not axis <code>i</code>).</li></ul>
</dd></dl>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#653fff0ee151151babf10f1c6e1f0aef">GetAxisEnable(int)</a> for an overloaded variant to access a single axis.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming 'hand' is a cSDH object ...</span>

          <span class="comment">// Get enabled state of all axes:</span>
          std::vector&lt;double&gt; v = hand.GetAxisEnable( hand.all_axes );
          <span class="comment">// now v is something like {0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0}</span>

          <span class="comment">// Get enabled state of axis 3 and 5</span>
          std::vector&lt;int&gt; axes35;
          axes35.push_back( 3 );
          axes35.push_back( 5 );

          v = hand.GetAxisEnable( axes35 );
          <span class="comment">// now v is something like {1.0, 0.0}</span>


          <span class="comment">// Get enabled state of axis 3</span>
          <span class="keywordtype">double</span> v3 = hand.GetAxisEnable( 3 );
          <span class="comment">// now v3 is something like 1.0</span>
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="8d8d6a76a8e81a32509ad3cd95091c34"></a><!-- doxytag: member="SDH::cSDH::GetAxisEnable" ref="8d8d6a76a8e81a32509ad3cd95091c34" args="(int iAxis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SDH::cSDH::GetAxisEnable           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iAxis</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#e9845847fa4ab972699d79b25e61de3c">GetAxisEnable(std::vector&lt;int&gt;const&amp;)</a>, just for a single axis <em>iAxis</em>, see there for details and examples. 
</div>
</div><p>
<a class="anchor" name="cae1a38dae1b663f14868f3dd9f6e9db"></a><!-- doxytag: member="SDH::cSDH::GetAxisActualState" ref="cae1a38dae1b663f14868f3dd9f6e9db" args="(std::vector&lt; int &gt; const &amp;axes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="class_s_d_h_1_1c_s_d_h.html#b5f553148de415980dd90cb92f30b54b">eAxisState</a>&gt; SDH::cSDH::GetAxisActualState           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>axes</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the current actual state(s) of axis(axes).<p>
The actual axis states are read from the SDH.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axes</em>&nbsp;</td><td>- A vector of axis indices to access.</td></tr>
  </table>
</dl>
<ul>
<li>The indices in <em>axes</em> are checked if they are valid axis indices.</li><li>If <b>any</b> axis index is invalid then a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>A vector of the actual states of the selected axes.</li><li>The values are given as <a class="el" href="class_s_d_h_1_1c_s_d_h.html#b5f553148de415980dd90cb92f30b54b" title="The state of an axis (see TPOSCON_STATE in global.h of the SDH firmware).">eAxisState</a> enum values</li><li>The order of the elements of the <em>axes</em> vector and the returned values vector <em>rv</em> matches. I.e. <code>rv</code>[i] will be the value of axis <code>axes</code>[i] (not axis <code>i</code>).</li></ul>
</dd></dl>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#51d250e208d3d829e40bc1e4c3413640">GetAxisActualState(int)</a> for an overloaded variant to access a single axis.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming "hand" is a cSDH object ...</span>

          <span class="comment">// Get actual axis state of all axes</span>
          std::vector&lt;eAxisState&gt; v = hand.GetAxisActualState( hand.all_axes )
          <span class="comment">// now v is something like {eAS_IDLE, eAS_POSITIONING, eAS_IDLE, eAS_IDLE, eAS_IDLE, eAS_DISABLED, eAS_IDLE}</span>

          <span class="comment">// Get actual axis state of axis 3</span>
          <a class="code" href="class_s_d_h_1_1c_s_d_h.html#b5f553148de415980dd90cb92f30b54b" title="The state of an axis (see TPOSCON_STATE in global.h of the SDH firmware).">eAxisState</a> v3 = hand.GetAxisActualState( 3 );
          <span class="comment">// v3 is now something like eAS_IDLE</span>


          <span class="comment">// Get actual state of axis 2 and 5</span>
          std::vector&lt;int&gt; axes25;
          axes25.push_back( 2 );
          axes25.push_back( 5 );

          v = hand.GetAxisActualState( axes25 );
          <span class="comment">// now v is something like {eAS_IDLE, eAS_DISABLED}</span>
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="250b704684a5ecee8c05d359ca953450"></a><!-- doxytag: member="SDH::cSDH::GetAxisActualState" ref="250b704684a5ecee8c05d359ca953450" args="(int iAxis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_d_h_1_1c_s_d_h.html#b5f553148de415980dd90cb92f30b54b">eAxisState</a> SDH::cSDH::GetAxisActualState           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iAxis</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#d6a6595deb75b468fe8e230c5f356136">GetAxisActualState(std::vector&lt;int&gt;const&amp;)</a>, just for a single axis <em>iAxis</em>, see there for details and examples. 
</div>
</div><p>
<a class="anchor" name="4ab31d14f0da9b8cf23948cd9a894485"></a><!-- doxytag: member="SDH::cSDH::WaitAxis" ref="4ab31d14f0da9b8cf23948cd9a894485" args="(std::vector&lt; int &gt; const &amp;axes, double timeout=-1.0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SDH::cSDH::WaitAxis           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>axes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>-1.0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wait until the movement(s) of of axis(axes) has finished<p>
The state of the given axis(axes) is(are) queried until all axes are no longer moving.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axes</em>&nbsp;</td><td>- A vector of axis indices to access. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>- a timeout in seconds or -1.0 (default) to wait indefinetly.</td></tr>
  </table>
</dl>
<ul>
<li>The indices in <em>axes</em> are checked if they are valid axis indices.</li><li>If <b>any</b> axis index is invalid then a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.<ul>
<li>If <em>timeout</em> &lt; 0 then this function will wait arbitrarily long</li><li>If a <em>timeout</em> is given then this function will throw a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_communication.html" title="Derived exception class for exceptions related to communication between the SDHLibrary...">cSDHErrorCommunication</a> exception if the given axes are still moving after <em>timeout</em> many seconds</li></ul>
</li></ul>
<p>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#38fb5c717c3850c40a3dc557d83e3ced">WaitAxis(int,double)</a> for an overloaded variant to wait for a single axis or all axes.<p>
<dl compact><dt><b><a class="el" href="bug.html#_bug000019">Bug:</a></b></dt><dd>Due to a bug in SDH firmwares prior to 0.0.2.6 the <a class="el" href="class_s_d_h_1_1c_s_d_h.html#ddce51bc94cec44f4fe652e168c7ad44">WaitAxis()</a> command was somewhat unreliable there. When called immediately after a movement command like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#91ecc6595c68f2c6f00d31ffaea22a60">MoveHand()</a>, then the <a class="el" href="class_s_d_h_1_1c_s_d_h.html#ddce51bc94cec44f4fe652e168c7ad44">WaitAxis()</a> command returned immediately without waiting for the end of the movement. With SDH firmwares 0.0.2.6 and newer this is no longer problematic and <a class="el" href="class_s_d_h_1_1c_s_d_h.html#ddce51bc94cec44f4fe652e168c7ad44">WaitAxis()</a> works as expected. <br>
<b>=&gt; Resolved in SDH firmware 0.0.2.6</b></dd></dl>
<dl compact><dt><b><a class="el" href="bug.html#_bug000019">Bug:</a></b></dt><dd>With SDH firmware 0.0.2.6 <a class="el" href="class_s_d_h_1_1c_s_d_h.html#ddce51bc94cec44f4fe652e168c7ad44">WaitAxis()</a> did not work if one of the new velocity based controllers (eCT_VELOCITY, eCT_VELOCITY_ACCELERATION) was used. With SDH firmwares 0.0.2.7 and newer this now works. Here the <a class="el" href="class_s_d_h_1_1c_s_d_h.html#ddce51bc94cec44f4fe652e168c7ad44">WaitAxis()</a> waits until the selected axes come to velocity 0.0 <br>
<b>=&gt; Resolved in SDH firmware 0.0.2.7</b></dd></dl>
<dl class="user" compact><dt><b>Examples:</b></dt><dd>Example 1, WaitAxis and eCT_POSE controller, see also the demo program demo-simple3: <div class="fragment"><pre class="fragment">          <span class="comment">// Assuming "hand" is a cSDH object ...</span>

          hand.SetController( <a class="code" href="class_s_d_h_1_1c_s_d_h_base.html#610f29a16806030c12e25bf83d89abbd4ca0525d11ede40135676cf42ccb13fa" title="coordinated position controller (position per axis =&amp;gt; &amp;quot;pose controller&amp;quot;)...">eCT_POSE</a> );

          <span class="comment">// Set a new target pose for axis 1,2 and 3</span>
          std::vector&lt;int&gt; axes123;
          axes123.push_back( 1 );
          axes123.push_back( 2 );
          axes123.push_back( 3 );

          std::vector&lt;double&gt; angles123;
          angles123.push_back( -20.0 );
          angles123.push_back( -30.0 );
          angles123.push_back( -40.0 );


          hand.SetAxisTargetAngle( axes123, angles123 );

          <span class="comment">// Move axes there non sequentially:</span>
          hand.MoveAxis( axes123, <span class="keyword">false</span> );

          <span class="comment">// The last call returned immediately so we now have time to</span>
          <span class="comment">// do something else while the hand is moving:</span>

          <span class="comment">// ... insert any calculation here ...</span>

          <span class="comment">// Before doing something else with the hand make shure the</span>
          <span class="comment">// selected axes have finished the last movement:</span>
          hand.WaitAxis( axes123 );


          <span class="comment">// go back home (all angles to 0.0):</span>
          hand.SetAxisTargetAngle( hand.All, 0.0 );

          <span class="comment">// Move all axes there non sequentially:</span>
          hand.MoveAxis( hand.All, False );

          <span class="comment">// ... insert any other calculation here ...</span>

          <span class="comment">// Wait until all axes are there, with a timeout of 10s:</span>
          hand.WaitAxis( hand.All, 10.0 );

          <span class="comment">// now we are at the desired position.</span>
</pre></div></dd></dl>
Example 2, WaitAxis and eCT_VELOCITY_ACCELERATION controller, see also the demo program demo-velocity-acceleration <div class="fragment"><pre class="fragment">          <span class="comment">// Assuming "hand" is a cSDH object ...</span>

          hand.SetController( <a class="code" href="class_s_d_h_1_1c_s_d_h_base.html#610f29a16806030c12e25bf83d89abbd82ae7fbb40d0b4eb851ea71a6a80e7bb" title="velocity controller with acceleration ramp, velocities and accelerations of axes...">eCT_VELOCITY_ACCELERATION</a>);

          <span class="comment">// Set a new target velocity for axis 1,2 and 3</span>
          std::vector&lt;int&gt; axes123;
          axes123.push_back( 1 );
          axes123.push_back( 2 );
          axes123.push_back( 3 );

          std::vector&lt;double&gt; velocities123;
          velocities123.push_back( -20.0 );
          velocities123.push_back( -30.0 );
          velocities123.push_back( -40.0 );


          hand.SetAxisTargetVelocity( axes123, velocities123 ); <span class="comment">// this will make the axes move!</span>

          <span class="comment">// The last call returned immediately so we now have time to</span>
          <span class="comment">// do something else while the hand is moving:</span>

          <span class="comment">// ... insert any calculation here ...</span>

          <span class="comment">// to break and stop the movement just set the target velocities to 0.0</span>
          velocities123[0] = 0.0;
          velocities123[1] = 0.0;
          velocities123[2] = 0.0;

          hand.SetAxisTargetVelocity( axes123, velocities123 ); <span class="comment">// this will make the axes break with the default (de)acceleration</span>

          <span class="comment">// The previous command returned immediately, so</span>
          <span class="comment">// before doing something else with the hand make shure the</span>
          <span class="comment">// selected axes have stopped:</span>
          hand.WaitAxis( axes123 );

          <span class="comment">// now the axes have stopped</span>
</pre></div><p>
<hr>
 
</div>
</div><p>
<a class="anchor" name="4d9b57c99d3f350b32c9d5f41ca3ab1e"></a><!-- doxytag: member="SDH::cSDH::WaitAxis" ref="4d9b57c99d3f350b32c9d5f41ca3ab1e" args="(int iAxis, double timeout=-1.0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SDH::cSDH::WaitAxis           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iAxis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>-1.0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#ddce51bc94cec44f4fe652e168c7ad44">WaitAxis(std::vector&lt;int&gt;const&amp;,double)</a>, just for a single axis <em>iAxis</em>, see there for details and examples.<p>
If <em>iAxis</em> is <a class="el" href="class_s_d_h_1_1c_s_d_h_base.html#ab61ed07c53bf24bc87ff5103e74f45a8e09b2cc8bc776a705cd2665fc555881" title="A meta-value that means &quot;access all possible values&quot;.">All</a> then wait for all axes axes. 
</div>
</div><p>
<a class="anchor" name="3a116b9ccdb5e05c6f5fbf9cd78ae2c9"></a><!-- doxytag: member="SDH::cSDH::SetAxisTargetAngle" ref="3a116b9ccdb5e05c6f5fbf9cd78ae2c9" args="(std::vector&lt; int &gt; const &amp;axes, std::vector&lt; double &gt; const &amp;angles)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SDH::cSDH::SetAxisTargetAngle           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>axes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>angles</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the target angle(s) for axis(axes).<p>
The target angles are stored in the SDH, the movement is not executed until an additional move command is sent.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axes</em>&nbsp;</td><td>- A vector of axis indices to access. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>angles</em>&nbsp;</td><td>- A vector of axis target angles to set. If any of the numbers in the vector is <code>NaN</code> (Not a Number) then the currently set axis target angle will be kept for the corresponding axis. The value(s) are expected in the configured angle unit system <a class="el" href="class_s_d_h_1_1c_s_d_h.html#bcb9da3cf0236c0e09cdd7af1a78225e" title="unit convert for (axis) angles: default = SDH::cSDH::uc_angle_degrees">uc_angle</a>.</td></tr>
  </table>
</dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd><ul>
<li>Setting the target angle will <b>not</b> make the axis/axes move.</li><li>The lengths of the <em>axes</em> and <em>angles</em> vector must match.</li><li>The indices can be given in any order, but the order of their elements must match, i.e. <code>angles</code>[i] will be applied to axis <code>axes</code>[i] (not axis <code>i</code>).</li><li>The indices are checked if they are valid axis indices.</li><li>The angles are checked if they are in the allowed range [0 .. <a class="el" href="class_s_d_h_1_1c_s_d_h.html#bd406a461d7fd466b6ae8708b1011e0c" title="Maximum allowed axis angles (in internal units (degrees)), including the virtual...">f_max_angle_v</a>], i.e. it is checked that <code>angles</code>[i], converted to internal units, is in <code></code>[0 .. <code>f_max_angle_v</code>[axes[i]]].</li><li>If <b>any</b> index or value is invalid then <b>none</b> of the specified values is sent to the SDH, instead a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
</dd></dl>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#079b2a7c493eab45984ea64b773124a3">SetAxisTargetAngle(int,double)</a> for an overloaded variant to set a single axis target angle or to set the same target angle for all axes.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming "hand" is a cSDH object ...</span>

          <span class="comment">// Set target axis angle of all axes to the given values:</span>
          std::vector&lt;double&gt; all_angles;
          all_angles.push_back( 0.0 );
          all_angles.push_back( -11.0 );
          all_angles.push_back( -22.0 );
          all_angles.push_back( -33.0 );
          all_angles.push_back( -44.0 );
          all_angles.push_back( -55.0 );
          all_angles.push_back( -66.0 );

          hand.SetAxisTargetAngle( hand.all_axes, all_angles );


          <span class="comment">// Set target axis angle of axis 3 to -42:</span>
          hand.SetAxisTargetAngle( 3, -42.0 );

          <span class="comment">// Set target angle of for axis 0, 4 and 2 to 0.0, -44.4 and -2.22 respectively:</span>
          std::vector&lt;int&gt; axes042;
          axes042.push_back( 0 );
          axes042.push_back( 4 );
          axes042.push_back( 2 );
          std::vector&lt;double&gt; angles042;
          angles042.push_back( 0.0 );
          angles042.push_back( -44.4 );
          angles042.push_back( -2.22 );

          hand.SetAxisTargetAngle( axes042, angles042 );


          <span class="comment">// Set target axis angle of all axes to 0 (home-position)</span>
          hand.SetAxisTargetAngle( hand.All, 0.0 );
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="d51fe77cc80cd12e68c375c72a1f3722"></a><!-- doxytag: member="SDH::cSDH::SetAxisTargetAngle" ref="d51fe77cc80cd12e68c375c72a1f3722" args="(int iAxis, double angle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SDH::cSDH::SetAxisTargetAngle           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iAxis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>angle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#f14021a2e8c95353d64f86b9208a0904">SetAxisTargetAngle(std::vector&lt;int&gt;const&amp;,std::vector&lt;double&gt;const&amp;)</a>, just for a single axis <em>iAxis</em> and a single angle <em>angle</em>, see there for details and examples.<p>
If <em>iAxis</em> is <a class="el" href="class_s_d_h_1_1c_s_d_h_base.html#ab61ed07c53bf24bc87ff5103e74f45a8e09b2cc8bc776a705cd2665fc555881" title="A meta-value that means &quot;access all possible values&quot;.">All</a> then <em>motor_current</em> is set for all axes. 
</div>
</div><p>
<a class="anchor" name="cf19050a8683914a0e2c2c157c1eb599"></a><!-- doxytag: member="SDH::cSDH::GetAxisTargetAngle" ref="cf19050a8683914a0e2c2c157c1eb599" args="(std::vector&lt; int &gt; const &amp;axes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; SDH::cSDH::GetAxisTargetAngle           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>axes</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the target angle(s) of axis(axes).<p>
The currently set target angles are read from the SDH.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axes</em>&nbsp;</td><td>- A vector of axis indices to access.</td></tr>
  </table>
</dl>
<ul>
<li>The indices in <em>axes</em> are checked if they are valid axis indices.</li><li>If <b>any</b> axis index is invalid then a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>A vector of the target angles of the selected axes.</li><li>The values are converted to the selected external unit system using the configured <a class="el" href="class_s_d_h_1_1c_s_d_h.html#bcb9da3cf0236c0e09cdd7af1a78225e" title="unit convert for (axis) angles: default = SDH::cSDH::uc_angle_degrees">uc_angle</a> unit converter object.</li><li>The order of the elements of the <em>axes</em> vector and the returned values vector <em>rv</em> matches. I.e. <code>rv</code>[i] will be the value of axis <code>axes</code>[i] (not axis <code>i</code>).</li></ul>
</dd></dl>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#37e84aed060f18bd0581a491cf7c3123">GetAxisTargetAngle(int)</a> for an overloaded variant to access a single axis.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming "hand" is a cSDH object ...</span>

          <span class="comment">// Get target axis angle of all axes</span>
          std::vector&lt;double&gt; v = hand.GetAxisTargetAngle( hand.all_axes );
          <span class="comment">// now v is something like {0.0, 0.0, 42.0, 0.0, 47.11, 0,0, 0.0}</span>

          <span class="comment">// Get target axis angle of axis 2</span>
          <span class="keywordtype">double</span> v2 = hand.GetAxisTargetAngle( 2 );
          <span class="comment">// v2 is now something like 42.0</span>


          <span class="comment">// Get target axis angle of axis 2 and 4</span>
          std::vector&lt;int&gt; axes24;
          axes24.push_back( 2 );
          axes24.push_back( 4 );

          v = hand.GetAxisTargetAngle( axes24 );
          <span class="comment">// now v is something like {42.0, 47.11}</span>
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="d89e5e69c4e1ea5f0700f46033da1e4d"></a><!-- doxytag: member="SDH::cSDH::GetAxisTargetAngle" ref="d89e5e69c4e1ea5f0700f46033da1e4d" args="(int iAxis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SDH::cSDH::GetAxisTargetAngle           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iAxis</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#f3f5d34fe7fdabb0d6822a79e856e5d1">GetAxisTargetAngle(std::vector&lt;int&gt;const&amp;)</a>, just for a single axis <em>iAxis</em> and returning a single angle, see there for details and examples. 
</div>
</div><p>
<a class="anchor" name="17927d32a415312baf17759c4625779b"></a><!-- doxytag: member="SDH::cSDH::GetAxisActualAngle" ref="17927d32a415312baf17759c4625779b" args="(std::vector&lt; int &gt; const &amp;axes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; SDH::cSDH::GetAxisActualAngle           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>axes</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the current actual angle(s) of axis(axes).<p>
The actual angles are read from the SDH.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axes</em>&nbsp;</td><td>- A vector of axis indices to access.</td></tr>
  </table>
</dl>
<ul>
<li>The indices in <em>axes</em> are checked if they are valid axis indices.</li><li>If <b>any</b> axis index is invalid then a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>A vector of the actual angles of the selected axes.</li><li>The values are converted to the selected external unit system using the configured <a class="el" href="class_s_d_h_1_1c_s_d_h.html#bcb9da3cf0236c0e09cdd7af1a78225e" title="unit convert for (axis) angles: default = SDH::cSDH::uc_angle_degrees">uc_angle</a> unit converter object.</li><li>The order of the elements of the <em>axes</em> vector and the returned values vector <em>rv</em> matches. I.e. <code>rv</code>[i] will be the value of axis <code>axes</code>[i] (not axis <code>i</code>).</li></ul>
</dd></dl>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#318a0395f2483fba7fd232365b610c70">GetAxisActualAngle(int)</a> for an overloaded variant to access a single axis.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming "hand" is a cSDH object ...</span>

          <span class="comment">// Get actual axis angle of all axes</span>
          std::vector&lt;double&gt; v = hand.GetAxisActualAngle( hand.all_axes );
          <span class="comment">// now v is something like {0.0, 0.0, 42.0, 0.0, 47.11, 0,0, 0.0}</span>

          <span class="comment">// Get actual axis angle of axis 2</span>
          <span class="keywordtype">double</span> v2 = hand.GetAxisActualAngle( 2 );
          <span class="comment">// 2 is now something like 42.0</span>


          <span class="comment">// Get actual axis angle of axis 2 and 4</span>
          std::vector&lt;int&gt; axes24;
          axes24.push_back( 2 );
          axes24.push_back( 4 );

          v = hand.GetAxisActualAngle( axes24 );
          <span class="comment">// now v is something like {42.0, 47.11}</span>
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="3c0ad4255d850eceea30fd88f1d95d38"></a><!-- doxytag: member="SDH::cSDH::GetAxisActualAngle" ref="3c0ad4255d850eceea30fd88f1d95d38" args="(int iAxis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SDH::cSDH::GetAxisActualAngle           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iAxis</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#9a429222a54007b1e966cd6d2001c10a">GetAxisActualAngle(std::vector&lt;int&gt;const&amp;)</a>, just for a single axis <em>iAxis</em> and returning a single angle, see there for details and examples. 
</div>
</div><p>
<a class="anchor" name="cca3f17cce0cb3bc7c5662aaadb7af57"></a><!-- doxytag: member="SDH::cSDH::SetAxisTargetVelocity" ref="cca3f17cce0cb3bc7c5662aaadb7af57" args="(std::vector&lt; int &gt; const &amp;axes, std::vector&lt; double &gt; const &amp;velocities)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SDH::cSDH::SetAxisTargetVelocity           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>axes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>velocities</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the target velocity(s) for axis(axes).<p>
The target velocities are stored in the SDH. The time at which a new target velocities will take effect depends on the current axis controller type:<ul>
<li>in eCT_POSE controller type the new target velocities will not take effect until an additional move command is sent: <a class="el" href="class_s_d_h_1_1c_s_d_h.html#a52181be374dd44517e0b2fef09130c1">MoveAxis()</a>, <a class="el" href="class_s_d_h_1_1c_s_d_h.html#67baba337dd775a0c8798b7f82738d6d">MoveFinger()</a>, <a class="el" href="class_s_d_h_1_1c_s_d_h.html#91ecc6595c68f2c6f00d31ffaea22a60">MoveHand()</a></li><li>in eCT_VELOCITY and eCT_VELOCITY_ACCELERATION controller type the new target velocity will take effect immediately. This means that in eCT_VELOCITY_ACCELERATION controller type the accelerations must be set with <a class="el" href="class_s_d_h_1_1c_s_d_h.html#4849b377325f407b464ebcd324f4510b">SetAxisTargetAcceleration()</a> <b>before</b> calling <a class="el" href="class_s_d_h_1_1c_s_d_h.html#9f27d454810035a480e2989ed471fcad">SetAxisTargetVelocity()</a>.</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axes</em>&nbsp;</td><td>- A vector of axis indices to access. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>velocities</em>&nbsp;</td><td>- A vector of axis target angles to set. If any of the numbers in the vector is <code>NaN</code> (Not a Number) then the currently set axis target velocity will be kept for the corresponding axis. The value(s) are expected in the configured angular velocity unit system <a class="el" href="class_s_d_h_1_1c_s_d_h.html#81c208eb64b0954dfef4182575ff6bc9" title="unit convert for (axis) angular velocities: default = SDH::cSDH::uc_angular_velocity_degrees_per_sec...">uc_angular_velocity</a>.</td></tr>
  </table>
</dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd><ul>
<li>The lengths of the <em>axes</em> and <em>velocities</em> vector must match.</li><li>The indices can be given in any order, but the order of their elements must match, i.e. <code>velocities</code>[i] will be applied to axis <code>axes</code>[i] (not axis <code>i</code>).</li><li>The indices are checked if they are valid axis indices.</li><li>The velocities are checked if they are in the allowed range [0 .. <a class="el" href="class_s_d_h_1_1c_s_d_h.html#3ec3baeb713e23b6585be21d54f43b21" title="Maximum allowed axis velocity (in internal units (degrees/second)), including the...">f_max_velocity_v</a>], i.e. it is checked that <code>velocities</code>[i], converted to internal units, is in <code></code>[0 .. <code>f_max_velocity_v</code>[axes[i]]].</li><li>If <b>any</b> index or value is invalid then <b>none</b> of the specified values is sent to the SDH, instead a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
</dd></dl>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#2bde8d04f76fe8c56a076f2843616e40">SetAxisTargetVelocity(int,double)</a> for an overloaded variant to set a single axis target velocity or to set the same target velocity for all axes.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming "hand" is a cSDH object ...</span>

          <span class="comment">// Set target axis velocity of all axes to the given values:</span>
          std::vector&lt;double&gt; all_velocities;
          all_velocities.push_back( 0.0 );
          all_velocities.push_back( 11.0 );
          all_velocities.push_back( 22.0 );
          all_velocities.push_back( 33.0 );
          all_velocities.push_back( 44.0 );
          all_velocities.push_back( 55.0 );
          all_velocities.push_back( 66.0 );

          hand.SetAxisTargetVelocity( hand.all_axes, all_velocities );


          <span class="comment">// Set target axis velocity of axis 3 to 42/s:</span>
          hand.SetAxisTargetVelocity( 3, 42.0 );

          <span class="comment">// Set target velocity of for axis 0,4 and 2 to 0.0/s, 44.4/s and 2.22/s respectively:</span>
          std::vector&lt;int&gt; axes042;
          axes042.push_back( 0 );
          axes042.push_back( 4 );
          axes042.push_back( 2 );
          std::vector&lt;double&gt; velocities042;
          velocities042.push_back( 0.0 );
          velocities042.push_back( 44.4 );
          velocities042.push_back( 2.22 );

          hand.SetAxisTargetVelocity( axes042, velocities042 );


          <span class="comment">// Set target axis velocity of all axes to 47.11/s</span>
          hand.SetAxisTargetVelocity( hand.All, 47.11 );
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="280565f4bb82ea0e90966cbf0932b88d"></a><!-- doxytag: member="SDH::cSDH::SetAxisTargetVelocity" ref="280565f4bb82ea0e90966cbf0932b88d" args="(int iAxis, double velocity)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SDH::cSDH::SetAxisTargetVelocity           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iAxis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>velocity</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#9f27d454810035a480e2989ed471fcad">SetAxisTargetVelocity(std::vector&lt;int&gt;const&amp;,std::vector&lt;double&gt;const&amp;)</a>, just for a single axis <em>iAxis</em> and a single velocity <em>velocity</em>, see there for details and examples. 
</div>
</div><p>
<a class="anchor" name="245e28f18d25a3f1409bcd803d2cd69a"></a><!-- doxytag: member="SDH::cSDH::GetAxisTargetVelocity" ref="245e28f18d25a3f1409bcd803d2cd69a" args="(std::vector&lt; int &gt; const &amp;axes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; SDH::cSDH::GetAxisTargetVelocity           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>axes</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the target velocity(s) of axis(axes).<p>
The currently set target velocities are read from the SDH.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axes</em>&nbsp;</td><td>- A vector of axis indices to access.</td></tr>
  </table>
</dl>
<ul>
<li>The indices in <em>axes</em> are checked if they are valid axis indices.</li><li>If <b>any</b> axis index is invalid then a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>A vector of the target velocities of the selected axes.</li><li>The values are converted to the selected external unit system using the configured <a class="el" href="class_s_d_h_1_1c_s_d_h.html#81c208eb64b0954dfef4182575ff6bc9" title="unit convert for (axis) angular velocities: default = SDH::cSDH::uc_angular_velocity_degrees_per_sec...">uc_angular_velocity</a> unit converter object.</li><li>The order of the elements of the <em>axes</em> vector and the returned values vector <em>rv</em> matches. I.e. <code>rv</code>[i] will be the value of axis <code>axes</code>[i] (not axis <code>i</code>).</li></ul>
</dd></dl>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#7ceceb1884ef7e5b3d601bf8174e540b">GetAxisTargetVelocity(int)</a> for an overloaded variant to access a single axis.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming "hand" is a cSDH object ...</span>

          <span class="comment">// Get target axis velocity of all axes</span>
          std::vector&lt;double&gt; v = hand.GetAxisTargetVelocity( hand.all_axes );
          <span class="comment">// now v is something like {0.0, 0.0, 42.0, 0.0, 47.11, 0,0, 0.0}</span>

          <span class="comment">// Get target axis velocity of axis 2</span>
          <span class="keywordtype">double</span> v2 = hand.GetAxisTargetVelocity( 2 );
          <span class="comment">// v2 is now something like 42.0</span>


          <span class="comment">// Get target axis velocity of axis 2 and 4</span>
          std::vector&lt;int&gt; axes24;
          axes24.push_back( 2 );
          axes24.push_back( 4 );

          v = hand.GetAxisTargetVelocity( axes24 );
          <span class="comment">// now v is something like {42.0, 47.11}</span>
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="36c8071c0db3e66a7d14d05bfa093dc7"></a><!-- doxytag: member="SDH::cSDH::GetAxisTargetVelocity" ref="36c8071c0db3e66a7d14d05bfa093dc7" args="(int iAxis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SDH::cSDH::GetAxisTargetVelocity           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iAxis</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#7bab675982757994c774a9ed1baa30b3">GetAxisTargetVelocity(std::vector&lt;int&gt;const&amp;)</a>, just for a single axis <em>iAxis</em> and returning a single velocity, see there for details and examples. 
</div>
</div><p>
<a class="anchor" name="71bdd7ba710b65c25719ebe34ce7f32e"></a><!-- doxytag: member="SDH::cSDH::GetAxisLimitVelocity" ref="71bdd7ba710b65c25719ebe34ce7f32e" args="(std::vector&lt; int &gt; const &amp;axes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; SDH::cSDH::GetAxisLimitVelocity           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>axes</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the velocity limit(s) of axis(axes).<p>
The velocity limit(s) are read from the SDH.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axes</em>&nbsp;</td><td>- A vector of axis indices to access.</td></tr>
  </table>
</dl>
<ul>
<li>The indices in <em>axes</em> are checked if they are valid axis indices.</li><li>If <b>any</b> axis index is invalid then a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>A vector of the velocity limits of the selected axes.</li><li>The values are converted to the selected external unit system using the configured <a class="el" href="class_s_d_h_1_1c_s_d_h.html#81c208eb64b0954dfef4182575ff6bc9" title="unit convert for (axis) angular velocities: default = SDH::cSDH::uc_angular_velocity_degrees_per_sec...">uc_angular_velocity</a> unit converter object.</li><li>The order of the elements of the <em>axes</em> vector and the returned values vector <em>rv</em> matches. I.e. <code>rv</code>[i] will be the value of axis <code>axes</code>[i] (not axis <code>i</code>).</li></ul>
</dd></dl>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#0ca4c1473934ba6ed468d68be66f5fe9">GetAxisLimitVelocity(int)</a> for an overloaded variant to access a single axis.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming "hand" is a cSDH object ...</span>

          <span class="comment">// Get axis velocity limits of all axes</span>
          std::vector&lt;double&gt; v = hand.GetAxisLimitVelocity( hand.all_axes );
          <span class="comment">// now v is something like {81.0, 140.0, 120.0, 140.0, 120.0, 140.0, 120.0}</span>

          <span class="comment">// Get axis velocity limit of axis 2</span>
          <span class="keywordtype">double</span> v2 = hand.GetAxisLimitVelocity( 2 );
          <span class="comment">// v2 is now something like 120.0</span>


          <span class="comment">// Get axis velocity limits of axis 2 and 4</span>
          std::vector&lt;int&gt; axes24;
          axes24.push_back( 2 );
          axes24.push_back( 4 );

          v = hand.GetAxisLimitVelocity( axes24 );
          <span class="comment">// now v is something like {120.0,120.0}</span>
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="b2c7ace95a9705b63e4680e38cc0a31b"></a><!-- doxytag: member="SDH::cSDH::GetAxisLimitVelocity" ref="b2c7ace95a9705b63e4680e38cc0a31b" args="(int iAxis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SDH::cSDH::GetAxisLimitVelocity           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iAxis</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#9824173a1618ef9486349a2b99196242">GetAxisLimitVelocity(std::vector&lt;int&gt;const&amp;)</a>, just for a single axis <em>iAxis</em> and returning a single velocity limit, see there for details and examples. 
</div>
</div><p>
<a class="anchor" name="c3e9249a68187d9bd206b80008ac6dc6"></a><!-- doxytag: member="SDH::cSDH::GetAxisLimitAcceleration" ref="c3e9249a68187d9bd206b80008ac6dc6" args="(std::vector&lt; int &gt; const &amp;axes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; SDH::cSDH::GetAxisLimitAcceleration           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>axes</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the acceleration limit(s) of axis(axes).<p>
The acceleration limit(s) are read from the SDH.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axes</em>&nbsp;</td><td>- A vector of axis indices to access.</td></tr>
  </table>
</dl>
<ul>
<li>The indices in <em>axes</em> are checked if they are valid axis indices.</li><li>If <b>any</b> axis index is invalid then a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>A vector of the acceleration limits of the selected axes.</li><li>The values are converted to the selected external unit system using the configured <a class="el" href="class_s_d_h_1_1c_s_d_h.html#8dc039c618c3383d5fefd85d41866f9e" title="unit convert for (axis) angular accelerations: default = SDH::cSDH::uc_angular_acceleration_degrees_...">uc_angular_acceleration</a> unit converter object.</li><li>The order of the elements of the <em>axes</em> vector and the returned values vector <em>rv</em> matches. I.e. <code>rv</code>[i] will be the value of axis <code>axes</code>[i] (not axis <code>i</code>).</li></ul>
</dd></dl>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#45d26862cee701b9f45bfe7c6f1e9c4c">GetAxisLimitAcceleration(int)</a> for an overloaded variant to access a single axis.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming "hand" is a cSDH object ...</span>

          <span class="comment">// Get axis acceleration limits of all axes</span>
          std::vector&lt;double&gt; v = hand.GetAxisLimitAcceleration( hand.all_axes );
          <span class="comment">// now v is something like {81.0, 140.0, 120.0, 140.0, 120.0, 140.0, 120.0}</span>

          <span class="comment">// Get axis acceleration limit of axis 2</span>
          <span class="keywordtype">double</span> v2 = hand.GetAxisLimitAcceleration( 2 );
          <span class="comment">// v2 is now something like 120.0</span>


          <span class="comment">// Get axis acceleration limits of axis 2 and 4</span>
          std::vector&lt;int&gt; axes24;
          axes24.push_back( 2 );
          axes24.push_back( 4 );

          v = hand.GetAxisLimitAcceleration( axes24 );
          <span class="comment">// now v is something like {120.0,120.0}</span>
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="031364bfcb90023f3f31fa53e7e92487"></a><!-- doxytag: member="SDH::cSDH::GetAxisLimitAcceleration" ref="031364bfcb90023f3f31fa53e7e92487" args="(int iAxis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SDH::cSDH::GetAxisLimitAcceleration           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iAxis</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#d70ae2e08313f32a6c2f80061f4ff1a3">GetAxisLimitAcceleration(std::vector&lt;int&gt;const&amp;)</a>, just for a single axis <em>iAxis</em> and returning a single acceleration limit, see there for details and examples. 
</div>
</div><p>
<a class="anchor" name="3f1819ddd81a4360fd09569d4a332492"></a><!-- doxytag: member="SDH::cSDH::GetAxisActualVelocity" ref="3f1819ddd81a4360fd09569d4a332492" args="(std::vector&lt; int &gt;const &amp;axes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; SDH::cSDH::GetAxisActualVelocity           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt;const &amp;&nbsp;</td>
          <td class="paramname"> <em>axes</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the actual velocity(s) of axis(axes).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axes</em>&nbsp;</td><td>- A vector of axis indices to access.</td></tr>
  </table>
</dl>
<ul>
<li>The indices in <em>axes</em> are checked if they are valid axis indices.</li><li>If <b>any</b> axis index is invalid then a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>A vector of the actual velocities of the selected axes.</li><li>The values are converted to the selected external unit system using the configured <a class="el" href="class_s_d_h_1_1c_s_d_h.html#81c208eb64b0954dfef4182575ff6bc9" title="unit convert for (axis) angular velocities: default = SDH::cSDH::uc_angular_velocity_degrees_per_sec...">uc_angular_velocity</a> unit converter object.</li><li>The order of the elements of the <em>axes</em> vector and the returned values vector <em>rv</em> matches. I.e. <code>rv</code>[i] will be the value of axis <code>axes</code>[i] (not axis <code>i</code>).</li></ul>
</dd></dl>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#dbf81a0ec719384676d3e4817a308edc">GetAxisActualVelocity(int)</a> for an overloaded variant to access a single axis.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming "hand" is a cSDH object ...</span>

          <span class="comment">// Get actual axis velocity of all axes</span>
          std::vector&lt;double&gt; v = hand.GetAxisActualVelocity( hand.all_axes );
          <span class="comment">// now v is something like {0.1, 0.2, 0.3, 13.2, 0.5, 0.0, 0.7}</span>

          <span class="comment">// Get actual axis velocity of axis 2 and 4</span>
          std::vector&lt;int&gt; axes24;
          axes24.push_back( 2 );
          axes24.push_back( 4 );
          v = hand.GetAxisActualVelocity( axes24 );
          <span class="comment">// now v is something like {13.2, 0.0}</span>

          <span class="comment">// Get actual axis velocity of axis 2</span>
          <span class="keywordtype">double</span> v3 = hand.GetAxisActualVelocity( 2 );
          <span class="comment">// v3 is now something like 13.2</span>
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="bcc7c1f7054ad59faa31547a1108b3cf"></a><!-- doxytag: member="SDH::cSDH::GetAxisActualVelocity" ref="bcc7c1f7054ad59faa31547a1108b3cf" args="(int iAxis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SDH::cSDH::GetAxisActualVelocity           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iAxis</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#3e88d83d6cc7e03362bfad2da9d5630e">GetAxisActualVelocity(std::vector&lt;int&gt;const&amp;)</a>, just for a single axis <em>iAxis</em> and returning a single velocity, see there for details and examples. 
</div>
</div><p>
<a class="anchor" name="52b90acfdb27d3a1101f18e5b50f1c11"></a><!-- doxytag: member="SDH::cSDH::GetAxisReferenceVelocity" ref="52b90acfdb27d3a1101f18e5b50f1c11" args="(std::vector&lt; int &gt;const &amp;axes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; SDH::cSDH::GetAxisReferenceVelocity           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt;const &amp;&nbsp;</td>
          <td class="paramname"> <em>axes</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the current reference velocity(s) of axis(axes). (This velocity is used internally by the SDH in eCT_VELOCITY_ACCELERATION mode).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axes</em>&nbsp;</td><td>- A vector of axis indices to access.</td></tr>
  </table>
</dl>
<ul>
<li>The indices in <em>axes</em> are checked if they are valid axis indices.</li><li>If <b>any</b> axis index is invalid then a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>A vector of the reference velocities of the selected axes.</li><li>The values are converted to the selected external unit system using the configured <a class="el" href="class_s_d_h_1_1c_s_d_h.html#81c208eb64b0954dfef4182575ff6bc9" title="unit convert for (axis) angular velocities: default = SDH::cSDH::uc_angular_velocity_degrees_per_sec...">uc_angular_velocity</a> unit converter object.</li><li>The order of the elements of the <em>axes</em> vector and the returned values vector <em>rv</em> matches. I.e. <code>rv</code>[i] will be the value of axis <code>axes</code>[i] (not axis <code>i</code>).</li></ul>
</dd></dl>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#084b4ef840f147ac7cd4dfa5532cffc3">GetAxisReferenceVelocity(int)</a> for an overloaded variant to access a single axis.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming "hand" is a cSDH object ...</span>

          <span class="comment">// Switch to "velocity control with acceleration ramp" controller mode first.</span>
          <span class="comment">// (When in another controller mode like the default eCT_POSE,</span>
          <span class="comment">//  then the reference velocities will not be valid):</span>
          hand.SetController( <a class="code" href="class_s_d_h_1_1c_s_d_h_base.html#610f29a16806030c12e25bf83d89abbd82ae7fbb40d0b4eb851ea71a6a80e7bb" title="velocity controller with acceleration ramp, velocities and accelerations of axes...">eCT_VELOCITY_ACCELERATION</a> );

          <span class="comment">// Get reference axis velocity of all axes</span>
          std::vector&lt;double&gt; v = hand.GetAxisReferenceVelocity( hand.all_axes );
          <span class="comment">// now v is something like {0.1, 0.2, 0.3, 13.2, 0.5, 0.0, 0.7}</span>

          <span class="comment">// Get reference axis velocity of axis 2 and 4</span>
          std::vector&lt;int&gt; axes24;
          axes24.push_back( 2 );
          axes24.push_back( 4 );
          v = hand.GetAxisReferenceVelocity( axes24 );
          <span class="comment">// now v is something like {13.2, 0.0}</span>

          <span class="comment">// Get reference axis velocity of axis 2</span>
          <span class="keywordtype">double</span> v3 = hand.GetAxisReferenceVelocity( 2 );
          <span class="comment">// v3 is now something like 13.2</span>
</pre></div></dd></dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd><ul>
<li>the underlying rvel command of the SDH firmware is not available in firmwares prior to 0.0.2.6. For such hands calling rvel will fail miserably.</li><li>The availability of an appropriate SDH firmware is <b>not</b> checked here due to performance losses when this function is used often.</li></ul>
</dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="5afc15e1866148b7f84de084a384693f"></a><!-- doxytag: member="SDH::cSDH::GetAxisReferenceVelocity" ref="5afc15e1866148b7f84de084a384693f" args="(int iAxis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SDH::cSDH::GetAxisReferenceVelocity           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iAxis</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#3e741ff4ff6bcb387f32e9ff9928e45b">GetAxisReferenceVelocity(std::vector&lt;int&gt;const&amp;)</a>, just for a single axis <em>iAxis</em> and returning a single velocity, see there for details and examples. 
</div>
</div><p>
<a class="anchor" name="de124d4d2c0af8a452436f9a8af1f7dc"></a><!-- doxytag: member="SDH::cSDH::SetAxisTargetAcceleration" ref="de124d4d2c0af8a452436f9a8af1f7dc" args="(std::vector&lt; int &gt;const &amp;axes, std::vector&lt; double &gt;const &amp;accelerations)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SDH::cSDH::SetAxisTargetAcceleration           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt;const &amp;&nbsp;</td>
          <td class="paramname"> <em>axes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;const &amp;&nbsp;</td>
          <td class="paramname"> <em>accelerations</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the target acceleration(s) for axis(axes).<p>
The target accelerations are stored in the SDH and are used only for:<ul>
<li>the eCT_POSE controller type with eVP_RAMP velocity profile</li><li>the eCT_VELOCITY_ACCELERATION controller type</li></ul>
<p>
Setting the target acceleration will not affect an ongoing movement, nor will it start a new movement. To take effect an additional command must be sent:<ul>
<li>in eCT_POSE controller type a move command: <a class="el" href="class_s_d_h_1_1c_s_d_h.html#a52181be374dd44517e0b2fef09130c1">MoveAxis()</a> <a class="el" href="class_s_d_h_1_1c_s_d_h.html#67baba337dd775a0c8798b7f82738d6d">MoveFinger()</a> <a class="el" href="class_s_d_h_1_1c_s_d_h.html#91ecc6595c68f2c6f00d31ffaea22a60">MoveHand()</a></li><li>in eCT_VELOCITY_ACCELERATION controller type the velocity must be set: <a class="el" href="class_s_d_h_1_1c_s_d_h.html#9f27d454810035a480e2989ed471fcad">SetAxisTargetVelocity()</a></li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axes</em>&nbsp;</td><td>- A vector of axis indices to access. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>accelerations</em>&nbsp;</td><td>- A vector of axis target accelerations to set. If any of the numbers in the vector is <code>NaN</code> (Not a Number) then the currently set axis target angle will be kept for the corresponding axis. The value(s) are expected in the configured angular acceleration unit system <a class="el" href="class_s_d_h_1_1c_s_d_h.html#8dc039c618c3383d5fefd85d41866f9e" title="unit convert for (axis) angular accelerations: default = SDH::cSDH::uc_angular_acceleration_degrees_...">uc_angular_acceleration</a>.</td></tr>
  </table>
</dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd><ul>
<li>The lengths of the <em>axes</em> and <em>accelerations</em> vector must match.</li><li>The indices can be given in any order, but the order of their elements must match, i.e. <code>accelerations</code>[i] will be applied to axis <code>axes</code>[i] (not axis <code>i</code>).</li><li>The indices are checked if they are valid axis indices.</li><li>The accelerations are checked if they are in the allowed range [0 .. <a class="el" href="class_s_d_h_1_1c_s_d_h.html#3ec3baeb713e23b6585be21d54f43b21" title="Maximum allowed axis velocity (in internal units (degrees/second)), including the...">f_max_velocity_v</a>], i.e. it is checked that <code>accelerations</code>[i], converted to internal units, is in <code></code>[0 .. <code>f_max_velocity_v</code>[axes[i]]].</li><li>If <b>any</b> index or value is invalid then <b>none</b> of the specified values is sent to the SDH, instead a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
</dd></dl>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#d1a4568a8808ea3ea824cc15faffc127">SetAxisTargetAcceleration(int,double)</a> for an overloaded variant to set a single axis target acceleration or to set the same target acceleration for all axes.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming "hand" is a cSDH object ...</span>

          <span class="comment">// Set target axis acceleration of all axes to the given values:</span>
          std::vector&lt;double&gt; all_accelerations;
          all_accelerations.push_back( 100.0 );
          all_accelerations.push_back( 101.0 );
          all_accelerations.push_back( 102.0 );
          all_accelerations.push_back( 103.0 );
          all_accelerations.push_back( 104.0 );
          all_accelerations.push_back( 105.0 );
          all_accelerations.push_back( 106.0 );

          hand.SetAxisTargetAcceleration( hand.all_axes, all_accelerations );


          <span class="comment">// Set target axis acceleration of axis 3 to 420/s:</span>
          hand.SetAxisTargetAcceleration( 3, 420.0 );

          <span class="comment">// Set target acceleration of for axis 0,4 and 2 to 0.0/s, 444.0/s and 222/s respectively:</span>
          std::vector&lt;int&gt; axes042;
          axes042.push_back( 0 );
          axes042.push_back( 4 );
          axes042.push_back( 2 );
          std::vector&lt;double&gt; accelerations042;
          accelerations042.push_back( 100.0 );
          accelerations042.push_back( 104.0 );
          accelerations042.push_back( 102.0 );

          hand.SetAxisTargetAcceleration( axes042, accelerations042 );


          <span class="comment">// Set target axis acceleration of all axes to 142.1/s</span>
          hand.SetAxisTargetAcceleration( hand.All, 142.1 );
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="ca70dc0050cbc0a40676f92bf05488f1"></a><!-- doxytag: member="SDH::cSDH::SetAxisTargetAcceleration" ref="ca70dc0050cbc0a40676f92bf05488f1" args="(int iAxis, double acceleration)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SDH::cSDH::SetAxisTargetAcceleration           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iAxis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>acceleration</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#4849b377325f407b464ebcd324f4510b">SetAxisTargetAcceleration(std::vector&lt;int&gt;const&amp;,std::vector&lt;double&gt;const&amp;)</a>, just for a single axis <em>iAxis</em> and a single acceleration <em>acceleration</em>, see there for details and examples. 
</div>
</div><p>
<a class="anchor" name="dd6c5e7880d0fef34d5a610c5cf6c3f8"></a><!-- doxytag: member="SDH::cSDH::GetAxisTargetAcceleration" ref="dd6c5e7880d0fef34d5a610c5cf6c3f8" args="(std::vector&lt; int &gt;const &amp;axes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; SDH::cSDH::GetAxisTargetAcceleration           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt;const &amp;&nbsp;</td>
          <td class="paramname"> <em>axes</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the target acceleration(s) of axis(axes).<p>
The currently set target accelerations are read from the SDH.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axes</em>&nbsp;</td><td>- A vector of axis indices to access.</td></tr>
  </table>
</dl>
<ul>
<li>The indices in <em>axes</em> are checked if they are valid axis indices.</li><li>If <b>any</b> axis index is invalid then a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>A vector of the target accelerations of the selected axes.</li><li>The values are converted to the selected external unit system using the configured <a class="el" href="class_s_d_h_1_1c_s_d_h.html#8dc039c618c3383d5fefd85d41866f9e" title="unit convert for (axis) angular accelerations: default = SDH::cSDH::uc_angular_acceleration_degrees_...">uc_angular_acceleration</a> unit converter object.</li><li>The order of the elements of the <em>axes</em> vector and the returned values vector <em>rv</em> matches. I.e. <code>rv</code>[i] will be the value of axis <code>axes</code>[i] (not axis <code>i</code>).</li></ul>
</dd></dl>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#07c6b856a2dd244036686aaeb40965cd">GetAxisTargetAcceleration(int)</a> for an overloaded variant to access a single axis.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming "hand" is a cSDH object ...</span>

          <span class="comment">// Get target axis acceleration of all axes</span>
          std::vector&lt;double&gt; v = hand.GetAxisTargetAcceleration( hand.all_axes );
          <span class="comment">// now v is something like {100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0}</span>

          <span class="comment">// Get target axis acceleration of axis 2</span>
          <span class="keywordtype">double</span> v2 = hand.GetAxisTargetAcceleration( 2 );
          <span class="comment">// v2 is now something like 100.0</span>


          <span class="comment">// Get target axis acceleration of axis 2 and 4</span>
          std::vector&lt;int&gt; axes24;
          axes24.push_back( 2 );
          axes24.push_back( 4 );

          v = hand.GetAxisTargetAcceleration( axes24 );
          <span class="comment">// now v is something like {100.0, 100.0}</span>
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="a22a2c14c8f1a39fc0f5b56069a42791"></a><!-- doxytag: member="SDH::cSDH::GetAxisTargetAcceleration" ref="a22a2c14c8f1a39fc0f5b56069a42791" args="(int iAxis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SDH::cSDH::GetAxisTargetAcceleration           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iAxis</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#8148b4f44c2631ce0f7b1e2dfc450831">GetAxisTargetAcceleration(std::vector&lt;int&gt;const&amp;)</a>, just for a single axis <em>iAxis</em> and returning a single acceleration, see there for details and examples. 
</div>
</div><p>
<a class="anchor" name="db0de094c9cdd1d9e2749c63e1aeeb64"></a><!-- doxytag: member="SDH::cSDH::GetAxisMinAngle" ref="db0de094c9cdd1d9e2749c63e1aeeb64" args="(std::vector&lt; int &gt; const &amp;axes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; SDH::cSDH::GetAxisMinAngle           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>axes</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the minimum angle(s) of axis(axes).<p>
The minimum angles are currently not read from the SDH, but are stored in the library.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axes</em>&nbsp;</td><td>- A vector of axis indices to access.</td></tr>
  </table>
</dl>
<ul>
<li>The indices in <em>axes</em> are checked if they are valid axis indices.</li><li>If <b>any</b> axis index is invalid then a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>A vector of the min angles of the selected axes.</li><li>The values are converted to the selected external unit system using the configured <a class="el" href="class_s_d_h_1_1c_s_d_h.html#bcb9da3cf0236c0e09cdd7af1a78225e" title="unit convert for (axis) angles: default = SDH::cSDH::uc_angle_degrees">uc_angle</a> unit converter object.</li><li>The order of the elements of the <em>axes</em> vector and the returned values vector <em>rv</em> matches. I.e. <code>rv</code>[i] will be the value of axis <code>axes</code>[i] (not axis <code>i</code>).</li></ul>
</dd></dl>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#301351d4a00cc942c6b3cafd5b6f0d2d">GetAxisMinAngle(int)</a> for an overloaded variant to access a single axis.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming "hand" is a cSDH object ...</span>

          <span class="comment">// Get minimum axis angles of all axes</span>
          std::vector&lt;double&gt; v = hand.GetAxisMinAngle( hand.all_axes );
          <span class="comment">// now v is something like {0.0, -90.0, -90.0, -90.0, -90.0, -90.0, -90.0}</span>

          <span class="comment">// Get minimum axis angle of axis 3</span>
          <span class="keywordtype">double</span> v3 = hand.GetAxisMinAngle( 3 );
          <span class="comment">// v3 is now something like -90.0</span>

          <span class="comment">// Get minimum axis angle of axis 2 and 4</span>
          std::vector&lt;int&gt; axes24;
          axes24.push_back( 2 );
          axes24.push_back( 4 );

          v = hand.GetAxisMinAngle( axes24 );
          <span class="comment">// now v is something like {-90.0, -90.0}</span>


          <span class="comment">// Or if you change the angle unit system:</span>
          hand.UseRadians();

          v = hand.GetAxisMinAngle( hand.all_axes );
          <span class="comment">// now v is something like {0.0, -1.5707963267948966, -1.5707963267948966, -1.5707963267948966, -1.5707963267948966, -1.5707963267948966, -1.5707963267948966}</span>
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="0f5c6f7376e92135e7116714b9a6853d"></a><!-- doxytag: member="SDH::cSDH::GetAxisMinAngle" ref="0f5c6f7376e92135e7116714b9a6853d" args="(int iAxis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SDH::cSDH::GetAxisMinAngle           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iAxis</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#c2b8ad56584f8ac5a5d0ff010ef8fc54">GetAxisMinAngle(std::vector&lt;int&gt;const&amp;)</a>, just for a single axis <em>iAxis</em> and returning a single minimum angle, see there for details and examples. 
</div>
</div><p>
<a class="anchor" name="fb5de902b53b4819ec9d86e83a3a646b"></a><!-- doxytag: member="SDH::cSDH::GetAxisMaxAngle" ref="fb5de902b53b4819ec9d86e83a3a646b" args="(std::vector&lt; int &gt; const &amp;axes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; SDH::cSDH::GetAxisMaxAngle           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>axes</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the maximum angle(s) of axis(axes).<p>
The maximum angles are currently not read from the SDH, but are stored in the library.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axes</em>&nbsp;</td><td>- A vector of axis indices to access.</td></tr>
  </table>
</dl>
<ul>
<li>The indices in <em>axes</em> are checked if they are valid axis indices.</li><li>If <b>any</b> axis index is invalid then a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>A vector of the max angles of the selected axes.</li><li>The values are converted to the selected external unit system using the configured <a class="el" href="class_s_d_h_1_1c_s_d_h.html#bcb9da3cf0236c0e09cdd7af1a78225e" title="unit convert for (axis) angles: default = SDH::cSDH::uc_angle_degrees">uc_angle</a> unit converter object.</li><li>The order of the elements of the <em>axes</em> vector and the returned values vector <em>rv</em> matches. I.e. <code>rv</code>[i] will be the value of axis <code>axes</code>[i] (not axis <code>i</code>).</li></ul>
</dd></dl>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#c77ca1ad96d5f7e63cb513b176f9e94c">GetAxisMaxAngle(int)</a> for an overloaded variant to access a single axis.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming "hand" is a cSDH object ...</span>

          <span class="comment">// Get maximum axis angles of all axes</span>
          std::vector&lt;double&gt; v = hand.GetAxisMaxAngle( hand.all_axes );
          <span class="comment">// now v is something like {90.0, 90.0, 90.0, 90.0, 90.0, 90.0, 90.0}</span>

          <span class="comment">// Get maximum axis angle of axis 3</span>
          <span class="keywordtype">double</span> v3 = hand.GetAxisMaxAngle( 3 );
          <span class="comment">// v3 is now something like 90.0</span>

          <span class="comment">// Get maximum axis angle of axis 2 and 4</span>
          std::vector&lt;int&gt; axes24;
          axes24.push_back( 2 );
          axes24.push_back( 4 );

          v = hand.GetAxisMaxAngle( axes24 );
          <span class="comment">// now v is something like {90.0, 90.0}</span>


          <span class="comment">// Or if you change the angle unit system:</span>
          hand.UseRadians();

          v = hand.GetAxisMaxAngle( hand.all_axes );
          <span class="comment">// now v is something like { 1.5707963267948966, 1.5707963267948966, 1.5707963267948966, 1.5707963267948966, 1.5707963267948966, 1.5707963267948966, 1.5707963267948966}</span>
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="2d3a5f135c2ed3adea95f47c4b22209b"></a><!-- doxytag: member="SDH::cSDH::GetAxisMaxAngle" ref="2d3a5f135c2ed3adea95f47c4b22209b" args="(int iAxis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SDH::cSDH::GetAxisMaxAngle           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iAxis</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#d12978c317ec5a3ea785453e8907e46f">GetAxisMaxAngle(std::vector&lt;int&gt;const&amp;)</a>, just for a single axis <em>iAxis</em> and returning a single maximum angle, see there for details and examples. 
</div>
</div><p>
<a class="anchor" name="a2db56e2125830e2670365d24b1994f6"></a><!-- doxytag: member="SDH::cSDH::GetAxisMaxVelocity" ref="a2db56e2125830e2670365d24b1994f6" args="(std::vector&lt; int &gt; const &amp;axes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; SDH::cSDH::GetAxisMaxVelocity           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>axes</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the maximum velocity(s) of axis(axes). These are the (theoretical) maximum velocities as determined by the maximum motor velocity and gear box ratio. The values do not take things like friction or inertia into account. So it is likely that these maximum velocities cannot be reached by the real hardware in reality.<p>
The maximum velocities are currently read once from the SDH when the communication to the SDH is opened. Later queries of this maximum velocities will use the values stored in the library.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axes</em>&nbsp;</td><td>- A vector of axis indices to access.</td></tr>
  </table>
</dl>
<ul>
<li>The indices in <em>axes</em> are checked if they are valid axis indices.</li><li>If <b>any</b> axis index is invalid then a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>A vector of the max angular velocities of the selected axes.</li><li>The values are converted to the selected external unit system using the configured <a class="el" href="class_s_d_h_1_1c_s_d_h.html#81c208eb64b0954dfef4182575ff6bc9" title="unit convert for (axis) angular velocities: default = SDH::cSDH::uc_angular_velocity_degrees_per_sec...">uc_angular_velocity</a> unit converter object.</li><li>The order of the elements of the <em>axes</em> vector and the returned values vector <em>rv</em> matches. I.e. <code>rv</code>[i] will be the value of axis <code>axes</code>[i] (not axis <code>i</code>).</li></ul>
</dd></dl>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#db06920236cba9b86f529452a5cffc47">GetAxisMaxVelocity(int)</a> for an overloaded variant to access a single axis.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming "hand" is a cSDH object ...</span>

          <span class="comment">// Get maximum axis angular velocities of all axes</span>
          std::vector&lt;double&gt; v = hand.GetAxisMaxVelocity( hand.all_axes );
          <span class="comment">// now v is something like {83.857,200.000,157.895,200.000,157.895,200.000,157.895}</span>

          <span class="comment">// Get maximum axis angular velocity of axis 3</span>
          <span class="keywordtype">double</span> v3 = hand.GetAxisMaxVelocity( 3 );
          <span class="comment">// v3 is now something like 200.0</span>

          <span class="comment">// Get maximum axis angular velocity of axis 2 and 4</span>
          std::vector&lt;int&gt; axes24;
          axes24.push_back( 2 );
          axes24.push_back( 4 );

          v = hand.GetAxisMaxVelocity( axes24 );
          <span class="comment">// now v is something like {157.895, 157.895}</span>


          <span class="comment">// Or if you change the angular velocity unit system:</span>
          hand.UseRadians();

          v = hand.GetAxisMaxVelocity( hand.all_axes );
          <span class="comment">// now v is something like {1.46358075084, 3.49065850399, 2.75578762244, 3.49065850399, 2.75578762244, 3.49065850399, 2.75578762244}</span>
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="2d5985478e1bfb7183a3adffe0cd3ae6"></a><!-- doxytag: member="SDH::cSDH::GetAxisMaxVelocity" ref="2d5985478e1bfb7183a3adffe0cd3ae6" args="(int iAxis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SDH::cSDH::GetAxisMaxVelocity           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iAxis</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#3494e3b5bc533764be487cf057850f79">GetAxisMaxVelocity(std::vector&lt;int&gt;const&amp;)</a>, just for a single axis <em>iAxis</em> and returning a single minimum angle, see there for details and examples. 
</div>
</div><p>
<a class="anchor" name="77b81cd9d1fd2485e00c56bf0109e0ed"></a><!-- doxytag: member="SDH::cSDH::GetAxisMaxAcceleration" ref="77b81cd9d1fd2485e00c56bf0109e0ed" args="(std::vector&lt; int &gt; const &amp;axes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; SDH::cSDH::GetAxisMaxAcceleration           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>axes</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the maximum acceleration(s) of axis(axes).<p>
The maximum accelerations are currently not read from the SDH, but are stored in the library.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axes</em>&nbsp;</td><td>- A vector of axis indices to access.</td></tr>
  </table>
</dl>
<ul>
<li>The indices in <em>axes</em> are checked if they are valid axis indices.</li><li>If <b>any</b> axis index is invalid then a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>A vector of the max angular accelerations of the selected axes.</li><li>The values are converted to the selected external unit system using the configured <a class="el" href="class_s_d_h_1_1c_s_d_h.html#8dc039c618c3383d5fefd85d41866f9e" title="unit convert for (axis) angular accelerations: default = SDH::cSDH::uc_angular_acceleration_degrees_...">uc_angular_acceleration</a> unit converter object.</li><li>The order of the elements of the <em>axes</em> vector and the returned values vector <em>rv</em> matches. I.e. <code>rv</code>[i] will be the value of axis <code>axes</code>[i] (not axis <code>i</code>).</li></ul>
</dd></dl>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#c2176ca2a159dfa038b249ccc41ae808">GetAxisMaxAcceleration(int)</a> for an overloaded variant to access a single axis.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming "hand" is a cSDH object ...</span>

          <span class="comment">// Get maximum axis angular accelerations of all axes</span>
          std::vector&lt;double&gt; v = hand.GetAxisMaxAcceleration( hand.all_axes );
          <span class="comment">// now v is something like {1000.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0}</span>

          <span class="comment">// Get maximum axis angular acceleration of axis 3</span>
          <span class="keywordtype">double</span> v3 = hand.GetAxisMaxAcceleration( 3 );
          <span class="comment">// v3 is now something like 1000.0</span>

          <span class="comment">// Get maximum axis angular acceleration of axis 2 and 4</span>
          std::vector&lt;int&gt; axes24;
          axes24.push_back( 2 );
          axes24.push_back( 4 );

          v = hand.GetAxisMaxAcceleration( axes24 );
          <span class="comment">// now v is something like {1000.0, 1000.0}</span>


          <span class="comment">// Or if you change the angular acceleration unit system:</span>
          hand.UseRadians();

          v = hand.GetAxisMaxAcceleration( hand.all_axes );
          <span class="comment">// now v is something like {17.453292519943293, 17.453292519943293, 17.453292519943293, 17.453292519943293, 17.453292519943293, 17.453292519943293, 17.453292519943293}</span>
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="12c98d0559eca3f25974d0de67cb93b4"></a><!-- doxytag: member="SDH::cSDH::GetAxisMaxAcceleration" ref="12c98d0559eca3f25974d0de67cb93b4" args="(int iAxis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SDH::cSDH::GetAxisMaxAcceleration           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iAxis</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#f62c9a768ef8ab7f721b6b390de40935">GetAxisMaxAcceleration(std::vector&lt;int&gt;const&amp;)</a>, just for a single axis <em>iAxis</em> and returning a single minimum angle, see there for details and examples. 
</div>
</div><p>
<a class="anchor" name="bb33108543e81540ce17705e837ed54d"></a><!-- doxytag: member="SDH::cSDH::MoveAxis" ref="bb33108543e81540ce17705e837ed54d" args="(std::vector&lt; int &gt;const &amp;axes, bool sequ=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SDH::cSDH::MoveAxis           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt;const &amp;&nbsp;</td>
          <td class="paramname"> <em>axes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>sequ</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Move selected axis/axes to the previously set target pose with the previously set velocity profile, (maximum) target velocities and target accelerations<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>axes</em>&nbsp;</td><td>- A vector of axis indices to access. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sequ</em>&nbsp;</td><td>- flag: if true (default) then the function executes sequentially and returns not until after the SDH has finished the movement. If false then the function returns immediately after the movement command has been sent to the SDH (the currently set target axis angles for other axes will then be <b>overwritten</b> with their current actual axis angles).</td></tr>
  </table>
</dl>
<ul>
<li>The indices in <em>axes</em> are checked if they are valid axis indices.</li><li>If any index is invalid then no movement is performed, instead a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The expected/elapsed execution time for the movement in the configured time unit system <a class="el" href="class_s_d_h_1_1c_s_d_h.html#7479296b9f0c7300dc50452c7c929bc2" title="unit convert for times: default = uc_time_seconds">uc_time</a></dd></dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd><ul>
<li>The axes will be enabled automatically.</li><li>Currently the actual movement velocity of an axis is determined by the SDH firmware to make the movements of all involved axes start and end synchronously at the same time. Therefore the axis that needs the longest time for its movement at its given maximum velocity determines the velocities of all the other axes.</li><li>Other axes than those selected by <em>axes</em> will <b>NOT</b> move, even if target axis angles for the axes have been set. (Remember: as axis 0 is used by finger 0 and 2 these two fingers cannot be moved completely idependent of each other.)</li><li>If <em>sequ</em> is true then the currently set target axis angles for other fingers will be restored upon return of the function.</li><li>If <em>sequ</em> is false then the currently set target axis angles for other fingers will be <b>overwritten</b> with their current actual axis angles</li></ul>
</dd></dl>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#112b655f39c71eacb4b407fce1cc3f2a">MoveAxis(int,bool)</a> for an overloaded variant to move a single axis.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming 'hand' is a cSDH object ...</span>

          <span class="comment">// create an index vector for adressing axes 0, 4 and 2 (in that order)</span>
          std::vector&lt;int&gt; axes042;
          axes042.push_back( 0 );
          axes042.push_back( 4 );
          axes042.push_back( 2 );

          <span class="comment">// Set a new target pose for axes 0, 4 and 2:</span>
          std::vector&lt;double&gt; angles042;
          angles042.push_back( 0.0 );
          angles042.push_back( -44.4 );
          angles042.push_back( -22.2 );

          hand.SetFingerTargetAngle( axes042, angles042 );


          <span class="comment">// First move Axis 0 only to its new target position:</span>
          hand.MoveAxis( 0 );

          <span class="comment">// The axis 0 has now reached its target position 0.0.  The</span>
          <span class="comment">// target poses for axes 4 and 2 are still set since the</span>
          <span class="comment">// last MoveAxes() call was sequentially (und thus it could</span>
          <span class="comment">// restore the previously set target axis angles of not</span>
          <span class="comment">// selected axes after the movement finished)</span>


          <span class="comment">// So move axes 4 and 2 now, this time non-sequentially:</span>
          std::vector&lt;int&gt; axes42;
          axes42.push_back( 4 );
          axes42.push_back( 2 );

          <span class="keywordtype">double</span> t = hand.MoveAxes( axis42, <span class="keyword">false</span> );

          <span class="comment">// The two axes 4 and 2 are now moving to their target position.</span>
          <span class="comment">// We have to wait until the non-sequential call has finished:</span>
          <a class="code" href="namespace_s_d_h.html#57c7b26a892e19cbc34a44b8056f81aa">SleepSec</a>( t );

          <span class="comment">// The axes 4 and 2 have now moved to -44.4 and -22.2.</span>

          <span class="comment">// The target angles for other axes have by now been</span>
          <span class="comment">// overwritten since the last MoveAxis() call was</span>
          <span class="comment">// non-sequentially (und thus it could \b NOT restore the</span>
          <span class="comment">// previously set target axis angles of not selected axes</span>
          <span class="comment">// after the movement finished)</span>


          <span class="comment">// Set new target angles for all axes ("home pose");</span>
          hand.SetAxisTargetAngle( hand.All, 0.0 );

          <span class="comment">// Now move all axes back to home pose:</span>
          hand.MoveAxes( hand.All );
</pre></div></dd></dl>
<dl compact><dt><b><a class="el" href="bug.html#_bug000021">Bug:</a></b></dt><dd>With SDH firmware &lt; 0.0.2.7 calling <a class="el" href="class_s_d_h_1_1c_s_d_h.html#a52181be374dd44517e0b2fef09130c1">MoveAxis()</a> while some axes are moving in eCT_POSE controller type will make the joints jerk. This is resolved in SDH firmware 0.0.2.7 for the eCT_POSE controller type with velocity profile eVP_RAMP. For the eCT_POSE controller type with velocity profile eVP_SIN_SQUARE changing target points/ velocities while moving will still make the axes jerk. <br>
<b>=&gt; Partly resolved in SDH firmware 0.0.2.7</b></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="cecaf65810c9fc16868e9980fcbf6204"></a><!-- doxytag: member="SDH::cSDH::MoveAxis" ref="cecaf65810c9fc16868e9980fcbf6204" args="(int iAxis, bool sequ=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SDH::cSDH::MoveAxis           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iAxis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>sequ</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#a52181be374dd44517e0b2fef09130c1">MoveAxis(std::vector&lt;int&gt;const&amp;,bool)</a>, just for a single axis <em>iAxis</em> (or all axes if <a class="el" href="class_s_d_h_1_1c_s_d_h_base.html#ab61ed07c53bf24bc87ff5103e74f45a8e09b2cc8bc776a705cd2665fc555881" title="A meta-value that means &quot;access all possible values&quot;.">All</a> is given). 
</div>
</div><p>
<a class="anchor" name="b5d9758efb25947cb363d037b17adc21"></a><!-- doxytag: member="SDH::cSDH::SetFingerEnable" ref="b5d9758efb25947cb363d037b17adc21" args="(std::vector&lt; int &gt; const &amp;fingers, std::vector&lt; double &gt; const &amp;states)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SDH::cSDH::SetFingerEnable           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>fingers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>states</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set enabled/disabled state of axis controllers of finger(s).<p>
The controllers of the axes of the selected fingers are enabled/disabled in the SDH. Disabled axes are not powered and thus might not remain in their current pose due to gravity, inertia or other external influences. But to prevent overheating the axis controllers should be switched of when not needed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fingers</em>&nbsp;</td><td>- A vector of finger indices to access. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>states</em>&nbsp;</td><td>- A vector of enabled states (0 = disabled, !=0 = enabled) to set. If any of the numbers in the vector is <code>NaN</code> (Not a Number) then the currently set enabled state will be kept for the corresponding axis.</td></tr>
  </table>
</dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd><ul>
<li>The lengths of the <em>fingers</em> and <em>states</em> vector must match.</li><li>The indices can be given in any order, but the order of their elements must match, i.e. <code>state</code>[i] will be applied to finger <code>fingers</code>[i] (not finger <code>i</code>).</li><li>The indices are checked if they are valid finger indices.</li><li>If <b>any</b> index is invalid then <b>none</b> of the specified values is sent to the SDH, instead a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li><li>As axis 0 is used for finger 0 and 2, axis 0 is disabled only if both finger 0 and 1 are disabled.</li></ul>
</dd></dl>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#d7d76fcf094c1c37a1ecfe5911a9c186">SetFingerEnable(int,double)</a>, <a class="el" href="class_s_d_h_1_1c_s_d_h.html#cfb60044e845bc4dd736b8731eb88035">SetFingerEnable(int,bool)</a> for overloaded variants to set a single finger enabled/disabled or to set the same state for all fingers. See further <a class="el" href="class_s_d_h_1_1c_s_d_h.html#8e2db3c372a62078954c4eb21396af73">SetFingerEnable(std::vector&lt;int&gt;const&amp;,std::vector&lt;bool&gt;const&amp;)</a> for a variant that accepts a <code>bool</code> vector for the states to set.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming "hand" is a cSDH object ...</span>

          <span class="comment">// Enable finger 1 and 2 while disabling finger 0 :</span>
          std::vector&lt;double&gt; states012;
          states012.push_back( 0.0 );
          states012.push_back( 1.0 );
          states012.push_back( 1.0 );

          hand.SetFingerEnable( hand.all_axes, states012 );
          <span class="comment">// (this will keep axis 0 (used by the disabled finger 0) enabled,</span>
          <span class="comment">// since axis 0 is needed by the enabled finger 2 too);</span>

          <span class="comment">// Enable all fingers:</span>
          hand.SetFingerEnable( hand.All,<span class="keyword">true</span> );

          <span class="comment">// Disable all fingers:</span>
          hand.SetFingerEnable( hand.All, 0.0 );

          <span class="comment">// Disable finger 2:</span>
          hand.SetFingerEnable( 2, <span class="keyword">false</span> );
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="d46a1dc341e307ab053b98b50317e328"></a><!-- doxytag: member="SDH::cSDH::SetFingerEnable" ref="d46a1dc341e307ab053b98b50317e328" args="(int iFinger, double state=1.0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SDH::cSDH::SetFingerEnable           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iFinger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>state</em> = <code>1.0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#4246f404decae71bfea1ff4b27e4cbb6">SetFingerEnable(std::vector&lt;int&gt;const&amp;,std::vector&lt;double&gt;const&amp;)</a>, just for a single finger <em>iAxis</em> and a single angle <em>angle</em>, see there for details and examples. 
</div>
</div><p>
<a class="anchor" name="7a5037fbff82d34eb47fc91fd516b921"></a><!-- doxytag: member="SDH::cSDH::SetFingerEnable" ref="7a5037fbff82d34eb47fc91fd516b921" args="(std::vector&lt; int &gt; const &amp;fingers, std::vector&lt; bool &gt; const &amp;states)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SDH::cSDH::SetFingerEnable           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>fingers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>states</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#4246f404decae71bfea1ff4b27e4cbb6">SetFingerEnable(std::vector&lt;int&gt;const&amp;,std::vector&lt;double&gt;const&amp;)</a>, just with states as vector of <code>bool</code> values, see there for details and examples. 
</div>
</div><p>
<a class="anchor" name="27b344e7929e2a33767957dcd5c69673"></a><!-- doxytag: member="SDH::cSDH::SetFingerEnable" ref="27b344e7929e2a33767957dcd5c69673" args="(int iFinger, bool state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SDH::cSDH::SetFingerEnable           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iFinger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>state</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#4246f404decae71bfea1ff4b27e4cbb6">SetFingerEnable(std::vector&lt;int&gt;const&amp;,std::vector&lt;double&gt;const&amp;)</a>, just for a single finger <em>iAxis</em> and a single angle <em>angle</em>, see there for details and examples. 
</div>
</div><p>
<a class="anchor" name="6d4772f468b551976b2c4d26228e3f2d"></a><!-- doxytag: member="SDH::cSDH::GetFingerEnable" ref="6d4772f468b551976b2c4d26228e3f2d" args="(std::vector&lt; int &gt; const &amp;fingers)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; SDH::cSDH::GetFingerEnable           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>fingers</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get enabled/disabled state of axis controllers of finger(s).<p>
The enabled/disabled state of the controllers of the selected fingers is read from the SDH. A finger is reported disabled if any of its axes is disabled and reported enabled if all its axes are enabled.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fingers</em>&nbsp;</td><td>- A vector of finger indices to access.</td></tr>
  </table>
</dl>
<ul>
<li>The indices in <em>fingers</em> are checked if they are valid finger indices.</li><li>If <b>any</b> finger index is invalid then a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>A vector of enabled/disabled states as doubles (0=disabled, 1.0=enabled) of the selected axes.</li><li>The order of the elements of the <em>axes</em> vector and the returned values vector <em>rv</em> matches. I.e. <code>rv</code>[i] will be the value of axis <code>axes</code>[i] (not axis <code>i</code>).</li></ul>
</dd></dl>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#653fff0ee151151babf10f1c6e1f0aef">GetAxisEnable(int)</a> for an overloaded variant to access a single axis.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming "hand" is a cSDH object ...</span>

          <span class="comment">// Get enabled state of all fingers:</span>
          std::vector&lt;double&gt; v = hand.GetFingerEnable( hand.all_fingers );
          <span class="comment">// now v is something like {0.0, 1.0, 0.0}</span>

          <span class="comment">// Get enabled state of finger 0 and 2</span>
          std::vector&lt;int&gt; fingers02;
          fingers02.push_back( 0 );
          fingers02.push_back( 2 );

          v = hand.GetFingerEnable( fingers02 );
          <span class="comment">// now v is something like {0.0, 0.0}</span>

          <span class="comment">// Get enabled state of finger 1</span>
          <span class="keywordtype">double</span> v1 = hand.GetFingerEnable( 1 );
          <span class="comment">// now v1 is something like 1.0</span>
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="0b586dd9f1434f06062df3af1e507f92"></a><!-- doxytag: member="SDH::cSDH::GetFingerEnable" ref="0b586dd9f1434f06062df3af1e507f92" args="(int iFinger)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SDH::cSDH::GetFingerEnable           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iFinger</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#1037c7d5b94845cfc65cb82defca07fe">GetFingerEnable(std::vector&lt;int&gt;const&amp;)</a>, just for a single finger <em>iFinger</em> and returning a single double value 
</div>
</div><p>
<a class="anchor" name="e27bd1e53e6f8e232f83436711213e8b"></a><!-- doxytag: member="SDH::cSDH::SetFingerTargetAngle" ref="e27bd1e53e6f8e232f83436711213e8b" args="(int iFinger, std::vector&lt; double &gt; const &amp;angles)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SDH::cSDH::SetFingerTargetAngle           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iFinger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>angles</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the target angle(s) for a single finger.<p>
The target axis angles <em>angle</em> of finger <em>iFinger</em> are stored in the SDH. The movement is not executed until an additional move command is sent.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iFinger</em>&nbsp;</td><td>- index of finger to access. This must be a single index. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>angles</em>&nbsp;</td><td>- the angle(s) to set or <code>None</code> to set the current actual axis angles of the finger as target angle. This can be a single number or a <a class="el" href="class_s_d_h_1_1c_s_d_h.html#sdhlibrary_cpp_sdh_h_csdh_vector">vector</a> of numbers. The value(s) are expected in the configured angle unit system <a class="el" href="class_s_d_h_1_1c_s_d_h.html#bcb9da3cf0236c0e09cdd7af1a78225e" title="unit convert for (axis) angles: default = SDH::cSDH::uc_angle_degrees">uc_angle</a>.</td></tr>
  </table>
</dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd><ul>
<li>Setting the target angles will <b>not</b> make the finger move.</li><li>The <em>iFinger</em> index is checked if it is a valid finger index.</li><li>The angles are checked if they are in the allowed range [0 .. <a class="el" href="class_s_d_h_1_1c_s_d_h.html#bd406a461d7fd466b6ae8708b1011e0c" title="Maximum allowed axis angles (in internal units (degrees)), including the virtual...">f_max_angle_v</a>], i.e. it is checked that <code>angles</code>[i], converted to internal units, is in <code></code>[0 .. <code>f_max_angle_v</code>[finger_axis_index[iFinger][i]]].</li><li>If <b>any</b> index or value is invalid then <b>none</b> of the specified values is sent to the SDH, instead a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
</dd></dl>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#c078e2f72e4b6006fe95d8711aceb2ef">SetFingerTargetAngle(int,double,double,double)</a> for an overloaded variant to set finger axis target angles from single <code>double</code> values.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming "hand" is a cSDH object ...</span>

          <span class="comment">// Set target axis angles of finger 0 to { 10.0, -08.15, 47.11 }</span>
          std::vector&lt;double&gt; angles;
          angles.push_back( 10.0 );
          angles.push_back( -08.15 );
          angles.push_back(  47.11 );

          hand.SetFingerTargetAngle( 0, angles );


          <span class="comment">// Set target axis angles of finger 1 to { 0.0, 24.7, 17.4 }</span>
          angles[0] = 0.0;   <span class="comment">// "virtual" base axis of finger 1</span>
          angles[1] = 24.7;
          angles[2] = 17.4;
          hand.SetFingerTargetAngle( 1, { 0.0, 24.7, 17.4 } );


          <span class="comment">// Set target axis angles of all axes of finger 0 to 12.34</span>
          hand.SetFingerTargetAngle( 0, 12.34, 12.34, 12.34 );


          <span class="comment">// REMARK: the last command changed the previously set target axis</span>
          <span class="comment">// angle for axis 0, since axis 0 is used as base axis for both</span>
          <span class="comment">// finger 0 and 2!</span>
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="e392128c9200b5c85d10125a44fbc7c6"></a><!-- doxytag: member="SDH::cSDH::SetFingerTargetAngle" ref="e392128c9200b5c85d10125a44fbc7c6" args="(int iFinger, double a0, double a1, double a2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SDH::cSDH::SetFingerTargetAngle           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iFinger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>a0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#ba34c83c19e7c5338e6fc09bbf1cebcf">SetFingerTargetAngle(int,std::vector&lt;double&gt;const&amp;)</a>, just with individual finger axis angles <em>a0</em>, <em>a1</em> and <em>a2</em>. 
</div>
</div><p>
<a class="anchor" name="73828a841ebaadf20ccca5a2027a0e25"></a><!-- doxytag: member="SDH::cSDH::GetFingerTargetAngle" ref="73828a841ebaadf20ccca5a2027a0e25" args="(int iFinger)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; SDH::cSDH::GetFingerTargetAngle           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iFinger</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the target axis angles of a single finger.<p>
The target axis angles of finger <em>iFinger</em> are read from the SDH.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iFinger</em>&nbsp;</td><td>- index of finger to access. This must be a single index</td></tr>
  </table>
</dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd><ul>
<li>The <em>iFinger</em> index is checked if it is a valid finger index.</li><li>If <em>iFinger</em> is invalid then a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>A list of the selected fingers target axis angles</li><li>The values are returned in the configured angle unit system <a class="el" href="class_s_d_h_1_1c_s_d_h.html#bcb9da3cf0236c0e09cdd7af1a78225e" title="unit convert for (axis) angles: default = SDH::cSDH::uc_angle_degrees">uc_angle</a>.</li></ul>
</dd></dl>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#2a96a70cf10eea86fefcb47a55e26b0e">GetFingerTargetAngle(int,double&amp;,double&amp;,double&amp;)</a> for an overloaded variant to get finger axis target angles into single <code>double</code> values.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming "hand" is a cSDH object ...</span>

          <span class="comment">// Get target axis angles of finger 0</span>
          std::vector&lt;double&gt; v = hand.GetFingerTargetAngle( 0 );
          <span class="comment">// now v is something like {42.0, -10.0, 47.11}</span>

          <span class="comment">// Get target axis angles of finger 1</span>
          <span class="keywordtype">double</span> a0, a1, a2;
          hand.GetFingerTargetAngle( 1, a0, a1, a2 );
          <span class="comment">// now a0, a1, a2 are something like 0.0, 24.7 and -5.5 respectively.</span>
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="9b935b79913c571628d98ab87c07ccef"></a><!-- doxytag: member="SDH::cSDH::GetFingerTargetAngle" ref="9b935b79913c571628d98ab87c07ccef" args="(int iFinger, double &amp;a0, double &amp;a1, double &amp;a2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SDH::cSDH::GetFingerTargetAngle           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iFinger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>a0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#18c5a988ce669f2d46def2a1f0f779b4">GetFingerTargetAngle(int)</a>, just returning the target axis angles in the <em>a0</em>, <em>a1</em> and <em>a2</em> parameters which are given by reference. 
</div>
</div><p>
<a class="anchor" name="3a4557f390f381811e269827a3d162cc"></a><!-- doxytag: member="SDH::cSDH::GetFingerActualAngle" ref="3a4557f390f381811e269827a3d162cc" args="(int iFinger)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; SDH::cSDH::GetFingerActualAngle           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iFinger</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the current actual axis angles of a single finger.<p>
The current actual axis angles of finger <em>iFinger</em> are read from the SDH.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iFinger</em>&nbsp;</td><td>- index of finger to access. This must be a single index.</td></tr>
  </table>
</dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd><ul>
<li>The <em>iFinger</em> index is checked if it is a valid finger index.</li><li>If <em>iFinger</em> is invalid then a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>A list of the current actual axis angles of the selected finger</li><li>The values are returned in the configured angle unit system <a class="el" href="class_s_d_h_1_1c_s_d_h.html#bcb9da3cf0236c0e09cdd7af1a78225e" title="unit convert for (axis) angles: default = SDH::cSDH::uc_angle_degrees">uc_angle</a>.</li></ul>
</dd></dl>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#c2e42748f9c6979959e8e6f1e155a7ec">GetFingerActualAngle(int,double&amp;,double&amp;,double&amp;)</a> for an overloaded variant to get finger axis actual angles into single <code>double</code> values.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming "hand" is a cSDH object ...</span>

          <span class="comment">// Get actual axis angles of finger 0</span>
          std::vector&lt;double&gt; v = hand.GetFingerActualAngle( 0 );
          <span class="comment">// v is now something like {42.0, -10.0, 47.11}</span>

          <span class="comment">// Get actual axis angles of finger 1</span>
          <span class="keywordtype">double</span> a0, a1, a2;
          hand.GetFingerTargetAngle( 1, a0, a1, a2 );
          <span class="comment">// now a0, a1, a2 are something like 0.0, 24.7 and -5.5 respectively.</span>
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="0ccde4824bca6a75bfc08802e9af4e9b"></a><!-- doxytag: member="SDH::cSDH::GetFingerActualAngle" ref="0ccde4824bca6a75bfc08802e9af4e9b" args="(int iFinger, double &amp;a0, double &amp;a1, double &amp;a2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SDH::cSDH::GetFingerActualAngle           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iFinger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>a0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#15777eae7e03b863055834e2cfe87f7d">GetFingerActualAngle(int)</a>, just returning the actual axis angles in the <em>a0</em>, <em>a1</em> and <em>a2</em> parameters which are given by reference. 
</div>
</div><p>
<a class="anchor" name="aa8171aba2ad6f2cd5cad263a1401816"></a><!-- doxytag: member="SDH::cSDH::GetFingerMinAngle" ref="aa8171aba2ad6f2cd5cad263a1401816" args="(int iFinger)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; SDH::cSDH::GetFingerMinAngle           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iFinger</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the minimum axis angles of a single finger.<p>
The minimum axis angles of finger <em>iFingers</em> axes, stored in the library, are returned.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iFinger</em>&nbsp;</td><td>- index of finger to access. This must be a single index</td></tr>
  </table>
</dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd><ul>
<li>The <em>iFinger</em> index is checked if it is a valid finger index.</li><li>If <em>iFinger</em> is invalid then a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>A list of the selected fingers minimum axis angles</li><li>The values are returned in the configured angle unit system <a class="el" href="class_s_d_h_1_1c_s_d_h.html#bcb9da3cf0236c0e09cdd7af1a78225e" title="unit convert for (axis) angles: default = SDH::cSDH::uc_angle_degrees">uc_angle</a>.</li></ul>
</dd></dl>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#d7070a86df73d6cf51c3e25ca465f337">GetFingerMinAngle(int,double&amp;,double&amp;,double&amp;)</a> for an overloaded variant to get finger axis min angles into single <code>double</code> values.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming "hand" is a cSDH object ...</span>

          <span class="comment">// Get minimum axis angles of finger 0</span>
          std::vector&lt;double&gt; v = hand.GetFingerMinAngle( 0 );
          <span class="comment">// now v is something like {0.0, -90.0, -90.0}</span>


          <span class="comment">// Get target axis angles of finger 1</span>
          <span class="keywordtype">double</span> a0, a1, a2;
          hand.GetFingerMinAngle( 1, a0, a1, a2 );
          <span class="comment">// now a0, a1, a2 are something like 0.0, -90.0, -90.0 respectively.</span>


          <span class="comment">// Or if you change the angle unit system:</span>
          hand.UseRadians();
          v = hand.GetFingerMinAngle( 0 );
          <span class="comment">// now v is something like {0.0, -1.5707963267948966, -1.5707963267948966}</span>
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="ae71bf00895a3428bfb1b928f59ec867"></a><!-- doxytag: member="SDH::cSDH::GetFingerMinAngle" ref="ae71bf00895a3428bfb1b928f59ec867" args="(int iFinger, double &amp;a0, double &amp;a1, double &amp;a2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SDH::cSDH::GetFingerMinAngle           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iFinger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>a0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#b6a45970a183452da7c7307d88e4fddd">GetFingerMinAngle(int)</a>, just returning the finger axis min angles in the <em>a0</em>, <em>a1</em> and <em>a2</em> parameters which are given by reference. 
</div>
</div><p>
<a class="anchor" name="0e322deeefdefd5a6ffc3bec094ad78f"></a><!-- doxytag: member="SDH::cSDH::GetFingerMaxAngle" ref="0e322deeefdefd5a6ffc3bec094ad78f" args="(int iFinger)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; SDH::cSDH::GetFingerMaxAngle           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iFinger</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the maximum axis angles of a single finger.<p>
The maximum axis angles of finger <em>iFingers</em> axes, stored in the library, are returned.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iFinger</em>&nbsp;</td><td>- index of finger to access. This must be a single index</td></tr>
  </table>
</dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd><ul>
<li>The <em>iFinger</em> index is checked if it is a valid finger index.</li><li>If <em>iFinger</em> is invalid then a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>A list of the selected fingers maximum axis angles</li><li>The values are returned in the configured angle unit system <a class="el" href="class_s_d_h_1_1c_s_d_h.html#bcb9da3cf0236c0e09cdd7af1a78225e" title="unit convert for (axis) angles: default = SDH::cSDH::uc_angle_degrees">uc_angle</a>.</li></ul>
</dd></dl>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#eb5e5c49e9c9547931f6d1cf12ad400c">GetFingerMaxAngle(int,double&amp;,double&amp;,double&amp;)</a> for an overloaded variant to get finger axis max angles into single <code>double</code> values.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming "hand" is a cSDH object ...</span>

          <span class="comment">// Get maximum axis angles of finger 0</span>
          std::vector&lt;double&gt; v = hand.GetFingerMaxAngle( 0 );
          <span class="comment">// now v is something like {90.0, 90.0, 90.0}</span>


          <span class="comment">// Get target axis angles of finger 1</span>
          <span class="keywordtype">double</span> a0, a1, a2;
          hand.GetFingerMaxAngle( 1, a0, a1, a2 );
          <span class="comment">// now a0, a1, a2 are something like 90.0, 90.0, 90.0 respectively.</span>


          <span class="comment">// Or if you change the angle unit system:</span>
          hand.UseRadians();
          v = hand.GetFingerMaxAngle( 0 );
          <span class="comment">// now v is something like {1.5707963267948966, 1.5707963267948966, 1.5707963267948966}</span>
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="efd262ffbc73f97c60f6abe3156d42ba"></a><!-- doxytag: member="SDH::cSDH::GetFingerMaxAngle" ref="efd262ffbc73f97c60f6abe3156d42ba" args="(int iFinger, double &amp;a0, double &amp;a1, double &amp;a2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SDH::cSDH::GetFingerMaxAngle           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iFinger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>a0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#2eb23046335fb06eb5d82b05dffa60a3">GetFingerMaxAngle(int)</a>, just returning the finger axis max angles in the <em>a0</em>, <em>a1</em> and <em>a2</em> parameters which are given by reference. 
</div>
</div><p>
<a class="anchor" name="760d6b6685148b72735f355eb9f7b3b2"></a><!-- doxytag: member="SDH::cSDH::GetFingerXYZ" ref="760d6b6685148b72735f355eb9f7b3b2" args="(int iFinger, std::vector&lt; double &gt; const &amp;angles)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; SDH::cSDH::GetFingerXYZ           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iFinger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>angles</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the cartesian xyz finger tip position of a single finger from the given axis angles (forward kinematics).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iFinger</em>&nbsp;</td><td>- index of finger to access. This must be a single index </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>angles</em>&nbsp;</td><td>- a vector of NUMBER_OF_AXES_PER_FINGER angles. The values are expected in the configured angle unit system <a class="el" href="class_s_d_h_1_1c_s_d_h.html#bcb9da3cf0236c0e09cdd7af1a78225e" title="unit convert for (axis) angles: default = SDH::cSDH::uc_angle_degrees">uc_angle</a>.</td></tr>
  </table>
</dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd><ul>
<li>The <em>iFinger</em> index is checked if it is a valid finger index.</li><li>The angles are checked if they are in the allowed range [0 .. <a class="el" href="class_s_d_h_1_1c_s_d_h.html#bd406a461d7fd466b6ae8708b1011e0c" title="Maximum allowed axis angles (in internal units (degrees)), including the virtual...">f_max_angle_v</a>], i.e. it is checked that <code>angles</code>[i], converted to internal units, is in <code></code>[0 .. <code>f_max_angle_v</code>[finger_axis_index[iFinger][i]]].</li><li>If any index or value is invalid then a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>A vector of the x,y,z values of the finger tip position</li><li>The values are returned in the configured position unit system <a class="el" href="class_s_d_h_1_1c_s_d_h.html#b16893e67eb1273cd95adcd6c0d5e631" title="unit converter for position: default = SDH::cSDH::uc_position_millimeter">uc_position</a>.</li></ul>
</dd></dl>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#1077543dc0254aa62b296def80ad3130">GetFingerXYZ(int,double,double,double)</a> for an overloaded variant to get finger tip position from single <code>double</code> values.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming "hand" is a cSDH object ...</span>

          <span class="comment">// Get actual finger angles of finger 0:</span>
          std::vector&lt;double&gt; angles = hand.GetFingerActualAngle( 0 );

          <span class="comment">// Get actual finger tip position of finger 0:</span>
          std::vector&lt;double&gt; position = hand.GetFingerXYZ( 0, angles );
          <span class="comment">// now position is something like {18.821618775581801, 32.600000000000001, 174.0}</span>
          <span class="comment">// (assuming that finger 0 is at axis angles {0,0,0})</span>

          <span class="comment">// Get finger tip position of finger 2 at axis angles {90,-90,-90}:</span>
          position = hand.GetFingerXYZ( 2, 90, -90, -90 );
          <span class="comment">// now position is something like {18.821618775581804, 119.60000000000002, -53.0}</span>

          <span class="comment">// Or if you change the angle unit system:</span>
          hand.UseRadians();
          position = hand.GetFingerXYZ( 0, 1.5707963267948966, -1.5707963267948966, -1.5707963267948966 );
          <span class="comment">// now position is still something like {18.821618775581804, 119.60000000000002, -53.0}</span>

          <span class="comment">// Or if you change the position unit system too:</span>
          hand.uc_position = &amp;<a class="code" href="class_s_d_h_1_1c_s_d_h.html#9c39c381b642d85d059c98b593af7178" title="Converter for position: external unit = meter.">cSDH::uc_position_meter</a>
          position = hand.GetFingerXYZ( 0, 1.5707963267948966, -1.5707963267948966, -1.5707963267948966 );
          <span class="comment">// now position is still something like {0.018821618775581, 0.119.60000000000002, -0.052999999999}</span>
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="d547b00ac9cfdaf6d0a6d4cfcccf598a"></a><!-- doxytag: member="SDH::cSDH::GetFingerXYZ" ref="d547b00ac9cfdaf6d0a6d4cfcccf598a" args="(int iFinger, double a0, double a1, double a2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; SDH::cSDH::GetFingerXYZ           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iFinger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>a0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#ba34c83c19e7c5338e6fc09bbf1cebcf">SetFingerTargetAngle(int,std::vector&lt;double&gt;const&amp;)</a>, just with individual finger axis angles <em>a0</em>, <em>a1</em> and <em>a2</em>. 
</div>
</div><p>
<a class="anchor" name="aff8495428a7994c9c2133c92544e8bf"></a><!-- doxytag: member="SDH::cSDH::MoveFinger" ref="aff8495428a7994c9c2133c92544e8bf" args="(std::vector&lt; int &gt;const &amp;fingers, bool sequ=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SDH::cSDH::MoveFinger           </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt;const &amp;&nbsp;</td>
          <td class="paramname"> <em>fingers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>sequ</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Move selected finger(s) to the previously set target pose with the previously set velocity profile, (maximum) target velocities and target accelerations.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fingers</em>&nbsp;</td><td>- A vector of finger indices to access. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sequ</em>&nbsp;</td><td>- flag: if true (default) then the function executes sequentially and returns not until after the SDH has finished the movement. If false then the function returns immediately after the movement command has been sent to the SDH (the currently set target axis angles for other fingers will then be <b>overwritten</b> with their current actual axis angles).</td></tr>
  </table>
</dl>
<ul>
<li>The indices in <em>fingers</em> are checked if they are valid finger indices.</li><li>If any index is invalid then no movement is performed, instead a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The expected/elapsed execution time for the movement in the configured time unit system <a class="el" href="class_s_d_h_1_1c_s_d_h.html#7479296b9f0c7300dc50452c7c929bc2" title="unit convert for times: default = uc_time_seconds">uc_time</a></dd></dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd><ul>
<li>The axes will be enabled automatically.</li><li>Currently the actual movement velocity of an axis is determined by the SDH firmware to make the movements of all involved axes start and end synchronously at the same time. Therefore the axis that needs the longest time for its movement at its given maximum velocity determines the velocities of all the other axes.</li><li>Other fingers than <em>iFinger</em> will <b>NOT</b> move, even if target axis angles for their axes have been set. (Exception: as axis 0 is used by finger 0 and 2 these two fingers cannot be moved completely idependent of each other.)</li><li>If <em>sequ</em> is true then the currently set target axis angles for other fingers will be restored upon return of the function.</li><li>If <em>sequ</em> is false then the currently set target axis angles for other fingers will be <b>overwritten</b> with their current actual axis angles</li></ul>
</dd></dl>
See also <a class="el" href="class_s_d_h_1_1c_s_d_h.html#ca98ac669705fe8491fb860a97c4ea21">MoveFinger(int,bool)</a> for an overloaded variant to move a single finger.<p>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming 'hand' is a cSDH object ...</span>

          <span class="comment">// Set a new target pose for finger 0:</span>
          hand.SetFingerTargetAngle( 0, 0.0, 0.0, 0.0 );

          <span class="comment">// Set a new target pose for finger 1</span>
          hand.SetFingerTargetAngle( 1, 0.0, -10.0, -10.0 );

          <span class="comment">// Set a new target pose for finger 2</span>
          hand.SetFingerTargetAngle( 2, 20.0, -20.0, -20.0 );

          <span class="comment">// Move finger 0 only (and finger 2 partly as axis 0 also belongs to finger 2);</span>
          hand.MoveFinger( 0, <span class="keyword">true</span> );
          <span class="comment">// The finger 0 has been moved to {20,0,0}</span>
          <span class="comment">// (axis 0 is 'wrong' since the target angle for axis 0 has been overwritten</span>
          <span class="comment">//  while setting the target angles for finger 2);</span>

          <span class="comment">// The target poses for finger 1 and 2 are still set since the</span>
          <span class="comment">// last MoveFinger() call was sequentially.</span>
          <span class="comment">// So move finger 1 now:</span>
          <span class="keywordtype">double</span> t = hand.MoveFinger( 1, <span class="keyword">false</span> );

          <span class="comment">// wait until the non-sequential call has finished:</span>
          <a class="code" href="namespace_s_d_h.html#57c7b26a892e19cbc34a44b8056f81aa">SleepSec</a>( t );

          <span class="comment">// The finger 1 has been moved to {0,-10,-10}.</span>

          <span class="comment">// The target angles for finger 2 have been overwritten since the</span>
          <span class="comment">// last MoveFinger() call was non-sequentially.</span>

          <span class="comment">// Therefore this next call will just keep the fingers in their</span>
          <span class="comment">// current positions:</span>
          hand.MoveFinger( hand.All, <span class="keyword">true</span> );


          <span class="comment">// Set new target angles for all axes ("home pose");</span>
          hand.SetAxisTargetAngle( hand.All, 0.0 );

          <span class="comment">// Now move all axes back to home pose:</span>
          hand.MoveHand();
</pre></div></dd></dl>
<dl compact><dt><b><a class="el" href="bug.html#_bug000022">Bug:</a></b></dt><dd>With SDH firmware &lt; 0.0.2.7 calling <a class="el" href="class_s_d_h_1_1c_s_d_h.html#67baba337dd775a0c8798b7f82738d6d">MoveFinger()</a> while some axes are moving in eCT_POSE controller type will make the joints jerk. This is resolved in SDH firmware 0.0.2.7 for the eCT_POSE controller type with velocity profile eVP_RAMP. For the eCT_POSE controller type with velocity profile eVP_SIN_SQUARE changing target points/ velocities while moving will still make the axes jerk. <br>
<b>=&gt; Partly resolved in SDH firmware 0.0.2.7</b> </dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="d0192d4ab6ae17eb4dda3314decbb1fa"></a><!-- doxytag: member="SDH::cSDH::MoveFinger" ref="d0192d4ab6ae17eb4dda3314decbb1fa" args="(int iFinger, bool sequ=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SDH::cSDH::MoveFinger           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iFinger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>sequ</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <a class="el" href="class_s_d_h_1_1c_s_d_h.html#67baba337dd775a0c8798b7f82738d6d">MoveFinger(std::vector&lt;int&gt;const&amp;,bool)</a>, just for a single finger <em>iFinger</em> (or all fingers if <a class="el" href="class_s_d_h_1_1c_s_d_h_base.html#ab61ed07c53bf24bc87ff5103e74f45a8e09b2cc8bc776a705cd2665fc555881" title="A meta-value that means &quot;access all possible values&quot;.">All</a> is given). 
</div>
</div><p>
<a class="anchor" name="151e9915f406308789f14a8b1afafc8e"></a><!-- doxytag: member="SDH::cSDH::MoveHand" ref="151e9915f406308789f14a8b1afafc8e" args="(bool sequ=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SDH::cSDH::MoveHand           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>sequ</em> = <code>true</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Move all fingers to the previously set target pose with the previously set (maximum) velocities.<p>
This is just a shortcut to <a class="el" href="class_s_d_h_1_1c_s_d_h.html#ca98ac669705fe8491fb860a97c4ea21">MoveFinger(int,bool)</a> with <em>iFinger</em> set to <code>hand.All</code> and <em>sequ</em> as indicated, so see there for details and examples.<p>
<dl compact><dt><b><a class="el" href="bug.html#_bug000023">Bug:</a></b></dt><dd>With SDH firmware &lt; 0.0.2.7 calling <a class="el" href="class_s_d_h_1_1c_s_d_h.html#91ecc6595c68f2c6f00d31ffaea22a60">MoveHand()</a> while some axes are moving in eCT_POSE controller type will make the joints jerk. This is resolved in SDH firmware 0.0.2.7 for the eCT_POSE controller type with velocity profile eVP_RAMP. For the eCT_POSE controller type with velocity profile eVP_SIN_SQUARE changing target points/ velocities while moving will still make the axes jerk. <br>
<b>=&gt; Parltly resolved in SDH firmware 0.0.2.7</b> </dd></dl>

</div>
</div><p>
<a class="anchor" name="897e52482bbf1f44b070cd8be816b357"></a><!-- doxytag: member="SDH::cSDH::GetGripMaxVelocity" ref="897e52482bbf1f44b070cd8be816b357" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SDH::cSDH::GetGripMaxVelocity           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the maximum velocity of grip skills<p>
The maximum velocity is currently not read from the SDH, but is stored in the library.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><ul>
<li>a single double value is returned representing the velocity in the <a class="el" href="class_s_d_h_1_1c_s_d_h.html#81c208eb64b0954dfef4182575ff6bc9" title="unit convert for (axis) angular velocities: default = SDH::cSDH::uc_angular_velocity_degrees_per_sec...">uc_angular_velocity</a> unit system</li></ul>
</dd></dl>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">         <span class="comment">// Assuming "hand" is a cSDH object ...</span>

         <span class="comment">// Get maximum grip skill velocity</span>
         <span class="keywordtype">double</span> v = hand.GetGripMaxVelocity();
         <span class="comment">// v is now something like 100.0</span>

         <span class="comment">// Or if you change the velocity unit system:</span>
         hand.UseRadians();
         v = hand.GetGripMaxVelocity();
         <span class="comment">// now v is something like 1.7453292519943295</span>
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<a class="anchor" name="5084831a54a6a8e94be7e70295cc92fe"></a><!-- doxytag: member="SDH::cSDH::GripHand" ref="5084831a54a6a8e94be7e70295cc92fe" args="(eGraspId grip, double close, double velocity, bool sequ=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SDH::cSDH::GripHand           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_s_d_h_1_1c_s_d_h_base.html#77b4811e6b0d574a30fe4ccf7d5e7672">eGraspId</a>&nbsp;</td>
          <td class="paramname"> <em>grip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>close</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>velocity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>sequ</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%">  throw (<a class="el" href="class_s_d_h_1_1c_s_d_h_library_exception.html">cSDHLibraryException</a>*)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Perform one of the internal <a class="el" href="class_s_d_h_1_1c_s_d_h_base.html#77b4811e6b0d574a30fe4ccf7d5e7672" title="The enum values of the known grasps.">eGraspId</a> "grips" or "grasps"<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>THIS DOES NOT WORK WITH SDH FIRMWARE PRIOR TO 0.0.2.6 AND SDHLIBRARY-CPP PRIOR to 0.0.1.12 This was a feature in the ancient times of the SDH1 and now does work again for SDH firmware 0.0.2.6 and newer and SDHLIBRARY-CPP 0.0.1.12 and newer. We intend to further improve this feature (e.g. store user defined grips within the SDH) in the future, but a particular deadline a has not been determined yet.</dd></dl>
<dl compact><dt><b><a class="el" href="bug.html#_bug000024">Bug:</a></b></dt><dd>With SDH firmware &gt; 0.0.2.6 and SDHLibrary &lt; 0.0.1.12 <a class="el" href="class_s_d_h_1_1c_s_d_h.html#1af5350393024630009896e5191a5f94">GripHand()</a> does not work (<a href="https://192.168.101.101/mechatronik/show_bug.cgi?id=575">Bug 575</a>) <br>
<b>=&gt; Resolved in SDHLibrary 0.0.1.12</b></dd></dl>
<dl compact><dt><b><a class="el" href="bug.html#_bug000024">Bug:</a></b></dt><dd>With SDH firmware &lt; 0.0.2.6 <a class="el" href="class_s_d_h_1_1c_s_d_h.html#1af5350393024630009896e5191a5f94">GripHand()</a> does not work and might yield undefined behaviour there <br>
<b>=&gt; Resolved in SDH firmware 0.0.2.6</b></dd></dl>
<dl compact><dt><b><a class="el" href="bug.html#_bug000024">Bug:</a></b></dt><dd>Currently the performing of a skill or grip with <a class="el" href="class_s_d_h_1_1c_s_d_h.html#1af5350393024630009896e5191a5f94">GripHand()</a> can <b>NOT</b> be interrupted!!! Even if the command is sent with <em>sequ=false</em> it <b>cannot</b> be stoped or emergency stopped.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>grip</em>&nbsp;</td><td>- The index of the grip to perform [0..eGID_DIMENSION-1] (s.a. eGraspId) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>close</em>&nbsp;</td><td>- close-ratio: [0.0 .. 1.0] where 0.0 is 'fully opened' and 1.0 is 'fully closed' </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>velocity</em>&nbsp;</td><td>- maximum allowed angular axis velocity in the chosen external unit system <a class="el" href="class_s_d_h_1_1c_s_d_h.html#81c208eb64b0954dfef4182575ff6bc9" title="unit convert for (axis) angular velocities: default = SDH::cSDH::uc_angular_velocity_degrees_per_sec...">uc_angular_velocity</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sequ</em>&nbsp;</td><td>- flag: if true (default) then the function executes sequentially and returns not until after the SDH has finished the movement. If false then the function returns immediately after the movement command has been sent to the SDH.</td></tr>
  </table>
</dl>
<ul>
<li>The <em>close</em> and <em>velocity</em> values are checked if they are in their allowed range.</li><li>If <b>any</b> value is invalid then <b>no</b> grip is perfomed, instead a <a class="el" href="class_s_d_h_1_1c_s_d_h_error_invalid_parameter.html" title="Derived exception class for exceptions related to invalid parameters.">SDH::cSDHErrorInvalidParameter</a>* exception is thrown.</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The expected/elapsed execution time for the movement in the configured time unit system <a class="el" href="class_s_d_h_1_1c_s_d_h.html#7479296b9f0c7300dc50452c7c929bc2" title="unit convert for times: default = uc_time_seconds">uc_time</a>.</dd></dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd><ul>
<li>Currently the actual movement velocity of an axis is determined by the SDH firmware to make the movements of all involved axes start and end synchronously at the same time. Therefore the axis that needs the longest time for its movement at its given maximum velocity determines the velocities of all the other axes.</li><li>The currently set target axis angles are not changed by this command</li><li>The movement uses the eMotorCurrentMode motor current modes "eMCM_GRIP" while gripping and then changes the motor current mode to "eMCM_HOLD". After the movement previously set motor currents set for mode "eMCM_MOVE" are <b>overwritten!</b> </li></ul>
</dd></dl>
<dl class="user" compact><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment">          <span class="comment">// Assuming 'hand' is a cSDH object ...</span>

          <span class="comment">// Perform a fully opened centrical grip at 50/s:</span>
          hand.GripHand( hand.eGID_CENTRICAL, 0.0, 50.0, <span class="keyword">true</span> );

          <span class="comment">// Now close it 50% with 30/s:</span>
          hand.GripHand( hand.eGID_CENTRICAL, 0.5, 30.0, <span class="keyword">true</span> );

          <span class="comment">// Then close it completely with 20/s:</span>
          hand.GripHand( hand.eGID_CENTRICAL, 1.0, 20.0, <span class="keyword">true</span> );
</pre></div></dd></dl>
<hr>
 
</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="128db2c199bab6ee328be4df7fd7f24f"></a><!-- doxytag: member="SDH::cSDH::uc_angle_degrees" ref="128db2c199bab6ee328be4df7fd7f24f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a> const <a class="el" href="class_s_d_h_1_1c_s_d_h.html#128db2c199bab6ee328be4df7fd7f24f">SDH::cSDH::uc_angle_degrees</a><code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Default converter for angles (internal unit == external unit): degrees. 
<p>

</div>
</div><p>
<a class="anchor" name="d471654c3963c7fa871061a5dde8f609"></a><!-- doxytag: member="SDH::cSDH::uc_angle_radians" ref="d471654c3963c7fa871061a5dde8f609" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a> const <a class="el" href="class_s_d_h_1_1c_s_d_h.html#d471654c3963c7fa871061a5dde8f609">SDH::cSDH::uc_angle_radians</a><code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converter for angles: external unit = radians. 
<p>

</div>
</div><p>
<a class="anchor" name="b9dcca0719b243ad2313e4587e3716d5"></a><!-- doxytag: member="SDH::cSDH::uc_time_seconds" ref="b9dcca0719b243ad2313e4587e3716d5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a> const <a class="el" href="class_s_d_h_1_1c_s_d_h.html#b9dcca0719b243ad2313e4587e3716d5">SDH::cSDH::uc_time_seconds</a><code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Default converter for times (internal unit == external unit): seconds. 
<p>

</div>
</div><p>
<a class="anchor" name="4b647e0946acd200b019b29169951ab4"></a><!-- doxytag: member="SDH::cSDH::uc_time_milliseconds" ref="4b647e0946acd200b019b29169951ab4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a> const <a class="el" href="class_s_d_h_1_1c_s_d_h.html#4b647e0946acd200b019b29169951ab4">SDH::cSDH::uc_time_milliseconds</a><code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converter for times: external unit = milliseconds. 
<p>

</div>
</div><p>
<a class="anchor" name="3a16fe0f08ebb82d79edf1a7fa502c2f"></a><!-- doxytag: member="SDH::cSDH::uc_temperature_celsius" ref="3a16fe0f08ebb82d79edf1a7fa502c2f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a> const <a class="el" href="class_s_d_h_1_1c_s_d_h.html#3a16fe0f08ebb82d79edf1a7fa502c2f">SDH::cSDH::uc_temperature_celsius</a><code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Default converter for temparatures (internal unit == external unit): degrees celsius. 
<p>

</div>
</div><p>
<a class="anchor" name="91a8319e68109aeec7f97008572f7177"></a><!-- doxytag: member="SDH::cSDH::uc_temperature_fahrenheit" ref="91a8319e68109aeec7f97008572f7177" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a> const <a class="el" href="class_s_d_h_1_1c_s_d_h.html#91a8319e68109aeec7f97008572f7177">SDH::cSDH::uc_temperature_fahrenheit</a><code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converter for temperatures: external unit = degrees fahrenheit. 
<p>

</div>
</div><p>
<a class="anchor" name="15ff510d1954ea58e34251fcc3a5cb34"></a><!-- doxytag: member="SDH::cSDH::uc_angular_velocity_degrees_per_second" ref="15ff510d1954ea58e34251fcc3a5cb34" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a> const <a class="el" href="class_s_d_h_1_1c_s_d_h.html#15ff510d1954ea58e34251fcc3a5cb34">SDH::cSDH::uc_angular_velocity_degrees_per_second</a><code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Default converter for angular velocities (internal unit == external unit): degrees / second. 
<p>

</div>
</div><p>
<a class="anchor" name="a4de0ead7be9184d43f2d9a4dbdeb534"></a><!-- doxytag: member="SDH::cSDH::uc_angular_velocity_radians_per_second" ref="a4de0ead7be9184d43f2d9a4dbdeb534" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a> const <a class="el" href="class_s_d_h_1_1c_s_d_h.html#a4de0ead7be9184d43f2d9a4dbdeb534">SDH::cSDH::uc_angular_velocity_radians_per_second</a><code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converter for angular velocieties: external unit = radians/second. 
<p>

</div>
</div><p>
<a class="anchor" name="37e1c49a2cc7d6599306c71ed2b2b00f"></a><!-- doxytag: member="SDH::cSDH::uc_angular_acceleration_degrees_per_second_squared" ref="37e1c49a2cc7d6599306c71ed2b2b00f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a> const <a class="el" href="class_s_d_h_1_1c_s_d_h.html#37e1c49a2cc7d6599306c71ed2b2b00f">SDH::cSDH::uc_angular_acceleration_degrees_per_second_squared</a><code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Default converter for angular accelerations (internal unit == external unit): degrees / second. 
<p>

</div>
</div><p>
<a class="anchor" name="c512eedd92c67e9322f0157b7656c204"></a><!-- doxytag: member="SDH::cSDH::uc_angular_acceleration_radians_per_second_squared" ref="c512eedd92c67e9322f0157b7656c204" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a> const <a class="el" href="class_s_d_h_1_1c_s_d_h.html#c512eedd92c67e9322f0157b7656c204">SDH::cSDH::uc_angular_acceleration_radians_per_second_squared</a><code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converter for angular velocieties: external unit = radians/second. 
<p>

</div>
</div><p>
<a class="anchor" name="d81dfd6cad39b84734a1bc39e48e2fdd"></a><!-- doxytag: member="SDH::cSDH::uc_motor_current_ampere" ref="d81dfd6cad39b84734a1bc39e48e2fdd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a> const <a class="el" href="class_s_d_h_1_1c_s_d_h.html#d81dfd6cad39b84734a1bc39e48e2fdd">SDH::cSDH::uc_motor_current_ampere</a><code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Default converter for motor current (internal unit == external unit): Ampere. 
<p>

</div>
</div><p>
<a class="anchor" name="002297a9389ad44c6b6b635f62fddad6"></a><!-- doxytag: member="SDH::cSDH::uc_motor_current_milliampere" ref="002297a9389ad44c6b6b635f62fddad6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a> const <a class="el" href="class_s_d_h_1_1c_s_d_h.html#002297a9389ad44c6b6b635f62fddad6">SDH::cSDH::uc_motor_current_milliampere</a><code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converter for motor current: external unit = milli Ampere. 
<p>

</div>
</div><p>
<a class="anchor" name="2a5abd24424bf5a92c3b74819d26cdc5"></a><!-- doxytag: member="SDH::cSDH::uc_position_millimeter" ref="2a5abd24424bf5a92c3b74819d26cdc5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a> const <a class="el" href="class_s_d_h_1_1c_s_d_h.html#2a5abd24424bf5a92c3b74819d26cdc5">SDH::cSDH::uc_position_millimeter</a><code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Default converter for position (internal unit == external unit): millimeter. 
<p>

</div>
</div><p>
<a class="anchor" name="9c39c381b642d85d059c98b593af7178"></a><!-- doxytag: member="SDH::cSDH::uc_position_meter" ref="9c39c381b642d85d059c98b593af7178" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a> const <a class="el" href="class_s_d_h_1_1c_s_d_h.html#9c39c381b642d85d059c98b593af7178">SDH::cSDH::uc_position_meter</a><code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converter for position: external unit = meter. 
<p>

</div>
</div><p>
<a class="anchor" name="3cd0859b0389fc608884ae8efd027d41"></a><!-- doxytag: member="SDH::cSDH::NUMBER_OF_AXES_PER_FINGER" ref="3cd0859b0389fc608884ae8efd027d41" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_s_d_h_1_1c_s_d_h.html#3cd0859b0389fc608884ae8efd027d41">SDH::cSDH::NUMBER_OF_AXES_PER_FINGER</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The number of axis per finger (for finger 1 this includes the "virtual" base axis). 
<p>

</div>
</div><p>
<a class="anchor" name="35c9f020727af4798822aae99f333275"></a><!-- doxytag: member="SDH::cSDH::NUMBER_OF_VIRTUAL_AXES" ref="35c9f020727af4798822aae99f333275" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_s_d_h_1_1c_s_d_h.html#35c9f020727af4798822aae99f333275">SDH::cSDH::NUMBER_OF_VIRTUAL_AXES</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The number of virtual axes. 
<p>

</div>
</div><p>
<a class="anchor" name="4ab4ed09ed69f35e554de6c4e4bd5368"></a><!-- doxytag: member="SDH::cSDH::nb_all_axes" ref="4ab4ed09ed69f35e554de6c4e4bd5368" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_s_d_h_1_1c_s_d_h.html#4ab4ed09ed69f35e554de6c4e4bd5368">SDH::cSDH::nb_all_axes</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The number of all axes including virtual axes. 
<p>

</div>
</div><p>
<a class="anchor" name="662368ab129bb5c1fdfe6d4daad79957"></a><!-- doxytag: member="SDH::cSDH::finger_number_of_axes" ref="662368ab129bb5c1fdfe6d4daad79957" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; <a class="el" href="class_s_d_h_1_1c_s_d_h.html#662368ab129bb5c1fdfe6d4daad79957">SDH::cSDH::finger_number_of_axes</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Mapping of finger index to number of real axes of fingers:. 
<p>

</div>
</div><p>
<a class="anchor" name="df0c8a9654dd2009d3d5d8402ec3cc83"></a><!-- doxytag: member="SDH::cSDH::finger_axis_index" ref="df0c8a9654dd2009d3d5d8402ec3cc83" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;int&gt; &gt; <a class="el" href="class_s_d_h_1_1c_s_d_h.html#df0c8a9654dd2009d3d5d8402ec3cc83">SDH::cSDH::finger_axis_index</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Mapping of finger index, finger axis index to axis index:. 
<p>

</div>
</div><p>
<a class="anchor" name="8000fdeb249c0ba27c0e4af39271324f"></a><!-- doxytag: member="SDH::cSDH::f_zeros_v" ref="8000fdeb249c0ba27c0e4af39271324f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; <a class="el" href="class_s_d_h_1_1c_s_d_h.html#8000fdeb249c0ba27c0e4af39271324f">SDH::cSDH::f_zeros_v</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Vector of 3 epsilon values. 
<p>
Vector of 3 0.0 values 
</div>
</div><p>
<a class="anchor" name="c365f6580d9d323ce4c4f62b2ee55c5c"></a><!-- doxytag: member="SDH::cSDH::f_ones_v" ref="c365f6580d9d323ce4c4f62b2ee55c5c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; <a class="el" href="class_s_d_h_1_1c_s_d_h.html#c365f6580d9d323ce4c4f62b2ee55c5c">SDH::cSDH::f_ones_v</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Vector of 3 1.0 values. 
<p>

</div>
</div><p>
<a class="anchor" name="7d5ad2d98ddf0bedb5727077b2d174b1"></a><!-- doxytag: member="SDH::cSDH::zeros_v" ref="7d5ad2d98ddf0bedb5727077b2d174b1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; <a class="el" href="class_s_d_h_1_1c_s_d_h.html#7d5ad2d98ddf0bedb5727077b2d174b1">SDH::cSDH::zeros_v</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Vector of nb_all_axes 0.0 values. 
<p>

</div>
</div><p>
<a class="anchor" name="fcc291c929ce6272f9bfd57023e7e291"></a><!-- doxytag: member="SDH::cSDH::ones_v" ref="fcc291c929ce6272f9bfd57023e7e291" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; <a class="el" href="class_s_d_h_1_1c_s_d_h.html#fcc291c929ce6272f9bfd57023e7e291">SDH::cSDH::ones_v</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Vector of nb_all_axes 1.0 values. 
<p>

</div>
</div><p>
<a class="anchor" name="251ba34b893b1869a762e8e8884d09c8"></a><!-- doxytag: member="SDH::cSDH::f_min_motor_current_v" ref="251ba34b893b1869a762e8e8884d09c8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; <a class="el" href="class_s_d_h_1_1c_s_d_h.html#251ba34b893b1869a762e8e8884d09c8">SDH::cSDH::f_min_motor_current_v</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Minimum allowed motor currents (in internal units (Ampere)), including the virtual axis. 
<p>

</div>
</div><p>
<a class="anchor" name="c2a56629fe34ac72d6cc1ad5cbde2ed0"></a><!-- doxytag: member="SDH::cSDH::f_max_motor_current_v" ref="c2a56629fe34ac72d6cc1ad5cbde2ed0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; <a class="el" href="class_s_d_h_1_1c_s_d_h.html#c2a56629fe34ac72d6cc1ad5cbde2ed0">SDH::cSDH::f_max_motor_current_v</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Maximum allowed motor currents (in internal units (Ampere)), including the virtual axis. 
<p>

</div>
</div><p>
<a class="anchor" name="c65462197f02ea542d4a34206c866a20"></a><!-- doxytag: member="SDH::cSDH::f_min_angle_v" ref="c65462197f02ea542d4a34206c866a20" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; <a class="el" href="class_s_d_h_1_1c_s_d_h.html#c65462197f02ea542d4a34206c866a20">SDH::cSDH::f_min_angle_v</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Minimum allowed axis angles (in internal units (degrees)), including the virtual axis. 
<p>

</div>
</div><p>
<a class="anchor" name="bd406a461d7fd466b6ae8708b1011e0c"></a><!-- doxytag: member="SDH::cSDH::f_max_angle_v" ref="bd406a461d7fd466b6ae8708b1011e0c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; <a class="el" href="class_s_d_h_1_1c_s_d_h.html#bd406a461d7fd466b6ae8708b1011e0c">SDH::cSDH::f_max_angle_v</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Maximum allowed axis angles (in internal units (degrees)), including the virtual axis. 
<p>

</div>
</div><p>
<a class="anchor" name="b7e83851fdc4d64017b62e1a062ea742"></a><!-- doxytag: member="SDH::cSDH::f_min_velocity_v" ref="b7e83851fdc4d64017b62e1a062ea742" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; <a class="el" href="class_s_d_h_1_1c_s_d_h.html#b7e83851fdc4d64017b62e1a062ea742">SDH::cSDH::f_min_velocity_v</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Minimum allowed axis velocity (in internal units (degrees/second)), including the virtual axis. 
<p>

</div>
</div><p>
<a class="anchor" name="3ec3baeb713e23b6585be21d54f43b21"></a><!-- doxytag: member="SDH::cSDH::f_max_velocity_v" ref="3ec3baeb713e23b6585be21d54f43b21" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; <a class="el" href="class_s_d_h_1_1c_s_d_h.html#3ec3baeb713e23b6585be21d54f43b21">SDH::cSDH::f_max_velocity_v</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Maximum allowed axis velocity (in internal units (degrees/second)), including the virtual axis. 
<p>

</div>
</div><p>
<a class="anchor" name="51c6309e76ea3cf2de543cffd4bc94d6"></a><!-- doxytag: member="SDH::cSDH::f_min_acceleration_v" ref="51c6309e76ea3cf2de543cffd4bc94d6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; <a class="el" href="class_s_d_h_1_1c_s_d_h.html#51c6309e76ea3cf2de543cffd4bc94d6">SDH::cSDH::f_min_acceleration_v</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Minimum allowed axis acceleration (in internal units (degrees/(second * second))), including the virtual axis. 
<p>

</div>
</div><p>
<a class="anchor" name="c9d421f2e8f0c6da67071f3b8a07eff0"></a><!-- doxytag: member="SDH::cSDH::f_max_acceleration_v" ref="c9d421f2e8f0c6da67071f3b8a07eff0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; <a class="el" href="class_s_d_h_1_1c_s_d_h.html#c9d421f2e8f0c6da67071f3b8a07eff0">SDH::cSDH::f_max_acceleration_v</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Maximum allowed axis acceleration (in internal units (degrees/(second * second))), including the virtual axis. 
<p>

</div>
</div><p>
<a class="anchor" name="c8da2aa15adef9b959c9d4322f9fc2f1"></a><!-- doxytag: member="SDH::cSDH::grip_max_velocity" ref="c8da2aa15adef9b959c9d4322f9fc2f1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="class_s_d_h_1_1c_s_d_h.html#c8da2aa15adef9b959c9d4322f9fc2f1">SDH::cSDH::grip_max_velocity</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Maximum allowed grip velocity (in internal units (degrees/second)). 
<p>

</div>
</div><p>
<a class="anchor" name="bc579960bc538eb63ed84012d3971a4b"></a><!-- doxytag: member="SDH::cSDH::l1" ref="bc579960bc538eb63ed84012d3971a4b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="class_s_d_h_1_1c_s_d_h.html#bc579960bc538eb63ed84012d3971a4b">SDH::cSDH::l1</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
length of limb 1 (proximal joint to distal joint) in mm 
<p>

</div>
</div><p>
<a class="anchor" name="ccaacfad7c5bcc0a9287ae2a235bc95c"></a><!-- doxytag: member="SDH::cSDH::l2" ref="ccaacfad7c5bcc0a9287ae2a235bc95c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="class_s_d_h_1_1c_s_d_h.html#ccaacfad7c5bcc0a9287ae2a235bc95c">SDH::cSDH::l2</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
length of limb 2 (distal joint to fingertip) in mm 
<p>

</div>
</div><p>
<a class="anchor" name="87537330abbd2528f9dccaa105e427f6"></a><!-- doxytag: member="SDH::cSDH::d" ref="87537330abbd2528f9dccaa105e427f6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="class_s_d_h_1_1c_s_d_h.html#87537330abbd2528f9dccaa105e427f6">SDH::cSDH::d</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="74c5c97f01a7a5452fa58412360f20af"></a><!-- doxytag: member="SDH::cSDH::h" ref="74c5c97f01a7a5452fa58412360f20af" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="class_s_d_h_1_1c_s_d_h.html#74c5c97f01a7a5452fa58412360f20af">SDH::cSDH::h</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="892296c192f86303bd4c2dad020996d0"></a><!-- doxytag: member="SDH::cSDH::offset" ref="892296c192f86303bd4c2dad020996d0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;double&gt; &gt; <a class="el" href="class_s_d_h_1_1c_s_d_h.html#892296c192f86303bd4c2dad020996d0">SDH::cSDH::offset</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
list of xyz-vectors for all fingers with offset from (0,0,0) of proximal joint in mm 
</div>
</div><p>
<a class="anchor" name="3b788fb2f79a32502a29f0550c659539"></a><!-- doxytag: member="SDH::cSDH::com" ref="3b788fb2f79a32502a29f0550c659539" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_d_h_1_1c_serial_base.html">cSerialBase</a>* <a class="el" href="class_s_d_h_1_1c_s_d_h.html#3b788fb2f79a32502a29f0550c659539">SDH::cSDH::com</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="e21dadd89dbf2e0316414ea0127d9326"></a><!-- doxytag: member="SDH::cSDH::comm_interface" ref="e21dadd89dbf2e0316414ea0127d9326" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_d_h_1_1c_s_d_h_serial.html">cSDHSerial</a> <a class="el" href="class_s_d_h_1_1c_s_d_h.html#e21dadd89dbf2e0316414ea0127d9326">SDH::cSDH::comm_interface</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The object to interface with the SDH attached via serial RS232 or CAN. 
<p>

</div>
</div><p>
<a class="anchor" name="157b6e1209a43939b0baf5193ca62ddc"></a><!-- doxytag: member="SDH::cSDH::all_axes" ref="157b6e1209a43939b0baf5193ca62ddc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; <a class="el" href="class_s_d_h_1_1c_s_d_h.html#157b6e1209a43939b0baf5193ca62ddc">SDH::cSDH::all_axes</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A vector with indices of all axes (in natural order), including the virtual axis. 
<p>

</div>
</div><p>
<a class="anchor" name="4b213bcda9acbcee7030bc6e5d48d6cf"></a><!-- doxytag: member="SDH::cSDH::all_real_axes" ref="4b213bcda9acbcee7030bc6e5d48d6cf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; <a class="el" href="class_s_d_h_1_1c_s_d_h.html#4b213bcda9acbcee7030bc6e5d48d6cf">SDH::cSDH::all_real_axes</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A vector with indices of all real axes (in natural order), excluding the virtual axis. 
<p>

</div>
</div><p>
<a class="anchor" name="c799c1a91dd82c1d71f627b5496a0afa"></a><!-- doxytag: member="SDH::cSDH::all_fingers" ref="c799c1a91dd82c1d71f627b5496a0afa" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; <a class="el" href="class_s_d_h_1_1c_s_d_h.html#c799c1a91dd82c1d71f627b5496a0afa">SDH::cSDH::all_fingers</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A vector with indices of all fingers (in natural order). 
<p>

</div>
</div><p>
<a class="anchor" name="eb72f5095c4a1ad79964b9ef4a5c7bc4"></a><!-- doxytag: member="SDH::cSDH::all_temperature_sensors" ref="eb72f5095c4a1ad79964b9ef4a5c7bc4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; <a class="el" href="class_s_d_h_1_1c_s_d_h.html#eb72f5095c4a1ad79964b9ef4a5c7bc4">SDH::cSDH::all_temperature_sensors</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A vector with indices of all temperature sensors. 
<p>

</div>
</div><p>
<a class="anchor" name="bcb9da3cf0236c0e09cdd7af1a78225e"></a><!-- doxytag: member="SDH::cSDH::uc_angle" ref="bcb9da3cf0236c0e09cdd7af1a78225e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a>* <a class="el" href="class_s_d_h_1_1c_s_d_h.html#bcb9da3cf0236c0e09cdd7af1a78225e">SDH::cSDH::uc_angle</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
unit convert for (axis) angles: default = <a class="el" href="class_s_d_h_1_1c_s_d_h.html#128db2c199bab6ee328be4df7fd7f24f" title="Default converter for angles (internal unit == external unit): degrees.">SDH::cSDH::uc_angle_degrees</a> 
<p>

</div>
</div><p>
<a class="anchor" name="81c208eb64b0954dfef4182575ff6bc9"></a><!-- doxytag: member="SDH::cSDH::uc_angular_velocity" ref="81c208eb64b0954dfef4182575ff6bc9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a>* <a class="el" href="class_s_d_h_1_1c_s_d_h.html#81c208eb64b0954dfef4182575ff6bc9">SDH::cSDH::uc_angular_velocity</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
unit convert for (axis) angular velocities: default = <a class="el" href="class_s_d_h_1_1c_s_d_h.html#15ff510d1954ea58e34251fcc3a5cb34" title="Default converter for angular velocities (internal unit == external unit): degrees...">SDH::cSDH::uc_angular_velocity_degrees_per_second</a> 
<p>

</div>
</div><p>
<a class="anchor" name="8dc039c618c3383d5fefd85d41866f9e"></a><!-- doxytag: member="SDH::cSDH::uc_angular_acceleration" ref="8dc039c618c3383d5fefd85d41866f9e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a>* <a class="el" href="class_s_d_h_1_1c_s_d_h.html#8dc039c618c3383d5fefd85d41866f9e">SDH::cSDH::uc_angular_acceleration</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
unit convert for (axis) angular accelerations: default = <a class="el" href="class_s_d_h_1_1c_s_d_h.html#37e1c49a2cc7d6599306c71ed2b2b00f" title="Default converter for angular accelerations (internal unit == external unit): degrees...">SDH::cSDH::uc_angular_acceleration_degrees_per_second_squared</a> 
<p>

</div>
</div><p>
<a class="anchor" name="7479296b9f0c7300dc50452c7c929bc2"></a><!-- doxytag: member="SDH::cSDH::uc_time" ref="7479296b9f0c7300dc50452c7c929bc2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a>* <a class="el" href="class_s_d_h_1_1c_s_d_h.html#7479296b9f0c7300dc50452c7c929bc2">SDH::cSDH::uc_time</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
unit convert for times: default = uc_time_seconds 
<p>

</div>
</div><p>
<a class="anchor" name="844b1311f5be6eb5474157d9c24e7a5e"></a><!-- doxytag: member="SDH::cSDH::uc_temperature" ref="844b1311f5be6eb5474157d9c24e7a5e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a>* <a class="el" href="class_s_d_h_1_1c_s_d_h.html#844b1311f5be6eb5474157d9c24e7a5e">SDH::cSDH::uc_temperature</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
unit convert for temperatures: default = <a class="el" href="class_s_d_h_1_1c_s_d_h.html#3a16fe0f08ebb82d79edf1a7fa502c2f" title="Default converter for temparatures (internal unit == external unit): degrees celsius...">SDH::cSDH::uc_temperature_celsius</a> 
<p>

</div>
</div><p>
<a class="anchor" name="57bb98bd30adf2189a62f31388bc6bae"></a><!-- doxytag: member="SDH::cSDH::uc_motor_current" ref="57bb98bd30adf2189a62f31388bc6bae" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a>* <a class="el" href="class_s_d_h_1_1c_s_d_h.html#57bb98bd30adf2189a62f31388bc6bae">SDH::cSDH::uc_motor_current</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
unit converter for motor curent: default = <a class="el" href="class_s_d_h_1_1c_s_d_h.html#d81dfd6cad39b84734a1bc39e48e2fdd" title="Default converter for motor current (internal unit == external unit): Ampere.">SDH::cSDH::uc_motor_current_ampere</a> 
<p>

</div>
</div><p>
<a class="anchor" name="b16893e67eb1273cd95adcd6c0d5e631"></a><!-- doxytag: member="SDH::cSDH::uc_position" ref="b16893e67eb1273cd95adcd6c0d5e631" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a>* <a class="el" href="class_s_d_h_1_1c_s_d_h.html#b16893e67eb1273cd95adcd6c0d5e631">SDH::cSDH::uc_position</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
unit converter for position: default = <a class="el" href="class_s_d_h_1_1c_s_d_h.html#2a5abd24424bf5a92c3b74819d26cdc5" title="Default converter for position (internal unit == external unit): millimeter.">SDH::cSDH::uc_position_millimeter</a> 
<p>

</div>
</div><p>
<a class="anchor" name="662368ab129bb5c1fdfe6d4daad79957"></a><!-- doxytag: member="SDH::cSDH::finger_number_of_axes" ref="662368ab129bb5c1fdfe6d4daad79957" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; <a class="el" href="class_s_d_h_1_1c_s_d_h.html#662368ab129bb5c1fdfe6d4daad79957">SDH::cSDH::finger_number_of_axes</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Mapping of finger index to number of real axes of fingers:. 
<p>

</div>
</div><p>
<a class="anchor" name="df0c8a9654dd2009d3d5d8402ec3cc83"></a><!-- doxytag: member="SDH::cSDH::finger_axis_index" ref="df0c8a9654dd2009d3d5d8402ec3cc83" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;int&gt; &gt; <a class="el" href="class_s_d_h_1_1c_s_d_h.html#df0c8a9654dd2009d3d5d8402ec3cc83">SDH::cSDH::finger_axis_index</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Mapping of finger index, finger axis index to axis index:. 
<p>

</div>
</div><p>
<a class="anchor" name="8000fdeb249c0ba27c0e4af39271324f"></a><!-- doxytag: member="SDH::cSDH::f_zeros_v" ref="8000fdeb249c0ba27c0e4af39271324f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; <a class="el" href="class_s_d_h_1_1c_s_d_h.html#8000fdeb249c0ba27c0e4af39271324f">SDH::cSDH::f_zeros_v</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Vector of 3 epsilon values. 
<p>
Vector of 3 0.0 values 
</div>
</div><p>
<a class="anchor" name="c365f6580d9d323ce4c4f62b2ee55c5c"></a><!-- doxytag: member="SDH::cSDH::f_ones_v" ref="c365f6580d9d323ce4c4f62b2ee55c5c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; <a class="el" href="class_s_d_h_1_1c_s_d_h.html#c365f6580d9d323ce4c4f62b2ee55c5c">SDH::cSDH::f_ones_v</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Vector of 3 1.0 values. 
<p>

</div>
</div><p>
<a class="anchor" name="7d5ad2d98ddf0bedb5727077b2d174b1"></a><!-- doxytag: member="SDH::cSDH::zeros_v" ref="7d5ad2d98ddf0bedb5727077b2d174b1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; <a class="el" href="class_s_d_h_1_1c_s_d_h.html#7d5ad2d98ddf0bedb5727077b2d174b1">SDH::cSDH::zeros_v</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Vector of nb_all_axes 0.0 values. 
<p>

</div>
</div><p>
<a class="anchor" name="fcc291c929ce6272f9bfd57023e7e291"></a><!-- doxytag: member="SDH::cSDH::ones_v" ref="fcc291c929ce6272f9bfd57023e7e291" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; <a class="el" href="class_s_d_h_1_1c_s_d_h.html#fcc291c929ce6272f9bfd57023e7e291">SDH::cSDH::ones_v</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Vector of nb_all_axes 1.0 values. 
<p>

</div>
</div><p>
<a class="anchor" name="251ba34b893b1869a762e8e8884d09c8"></a><!-- doxytag: member="SDH::cSDH::f_min_motor_current_v" ref="251ba34b893b1869a762e8e8884d09c8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; <a class="el" href="class_s_d_h_1_1c_s_d_h.html#251ba34b893b1869a762e8e8884d09c8">SDH::cSDH::f_min_motor_current_v</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Minimum allowed motor currents (in internal units (Ampere)), including the virtual axis. 
<p>

</div>
</div><p>
<a class="anchor" name="c2a56629fe34ac72d6cc1ad5cbde2ed0"></a><!-- doxytag: member="SDH::cSDH::f_max_motor_current_v" ref="c2a56629fe34ac72d6cc1ad5cbde2ed0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; <a class="el" href="class_s_d_h_1_1c_s_d_h.html#c2a56629fe34ac72d6cc1ad5cbde2ed0">SDH::cSDH::f_max_motor_current_v</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Maximum allowed motor currents (in internal units (Ampere)), including the virtual axis. 
<p>

</div>
</div><p>
<a class="anchor" name="c65462197f02ea542d4a34206c866a20"></a><!-- doxytag: member="SDH::cSDH::f_min_angle_v" ref="c65462197f02ea542d4a34206c866a20" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; <a class="el" href="class_s_d_h_1_1c_s_d_h.html#c65462197f02ea542d4a34206c866a20">SDH::cSDH::f_min_angle_v</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Minimum allowed axis angles (in internal units (degrees)), including the virtual axis. 
<p>

</div>
</div><p>
<a class="anchor" name="bd406a461d7fd466b6ae8708b1011e0c"></a><!-- doxytag: member="SDH::cSDH::f_max_angle_v" ref="bd406a461d7fd466b6ae8708b1011e0c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; <a class="el" href="class_s_d_h_1_1c_s_d_h.html#bd406a461d7fd466b6ae8708b1011e0c">SDH::cSDH::f_max_angle_v</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Maximum allowed axis angles (in internal units (degrees)), including the virtual axis. 
<p>

</div>
</div><p>
<a class="anchor" name="b7e83851fdc4d64017b62e1a062ea742"></a><!-- doxytag: member="SDH::cSDH::f_min_velocity_v" ref="b7e83851fdc4d64017b62e1a062ea742" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; <a class="el" href="class_s_d_h_1_1c_s_d_h.html#b7e83851fdc4d64017b62e1a062ea742">SDH::cSDH::f_min_velocity_v</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Minimum allowed axis velocity (in internal units (degrees/second)), including the virtual axis. 
<p>

</div>
</div><p>
<a class="anchor" name="3ec3baeb713e23b6585be21d54f43b21"></a><!-- doxytag: member="SDH::cSDH::f_max_velocity_v" ref="3ec3baeb713e23b6585be21d54f43b21" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; <a class="el" href="class_s_d_h_1_1c_s_d_h.html#3ec3baeb713e23b6585be21d54f43b21">SDH::cSDH::f_max_velocity_v</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Maximum allowed axis velocity (in internal units (degrees/second)), including the virtual axis. 
<p>

</div>
</div><p>
<a class="anchor" name="51c6309e76ea3cf2de543cffd4bc94d6"></a><!-- doxytag: member="SDH::cSDH::f_min_acceleration_v" ref="51c6309e76ea3cf2de543cffd4bc94d6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; <a class="el" href="class_s_d_h_1_1c_s_d_h.html#51c6309e76ea3cf2de543cffd4bc94d6">SDH::cSDH::f_min_acceleration_v</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Minimum allowed axis acceleration (in internal units (degrees/(second * second))), including the virtual axis. 
<p>

</div>
</div><p>
<a class="anchor" name="c9d421f2e8f0c6da67071f3b8a07eff0"></a><!-- doxytag: member="SDH::cSDH::f_max_acceleration_v" ref="c9d421f2e8f0c6da67071f3b8a07eff0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; <a class="el" href="class_s_d_h_1_1c_s_d_h.html#c9d421f2e8f0c6da67071f3b8a07eff0">SDH::cSDH::f_max_acceleration_v</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Maximum allowed axis acceleration (in internal units (degrees/(second * second))), including the virtual axis. 
<p>

</div>
</div><p>
<a class="anchor" name="892296c192f86303bd4c2dad020996d0"></a><!-- doxytag: member="SDH::cSDH::offset" ref="892296c192f86303bd4c2dad020996d0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;double&gt; &gt; <a class="el" href="class_s_d_h_1_1c_s_d_h.html#892296c192f86303bd4c2dad020996d0">SDH::cSDH::offset</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
list of xyz-vectors for all fingers with offset from (0,0,0) of proximal joint in mm 
</div>
</div><p>
<a class="anchor" name="3b788fb2f79a32502a29f0550c659539"></a><!-- doxytag: member="SDH::cSDH::com" ref="3b788fb2f79a32502a29f0550c659539" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_d_h_1_1c_serial_base.html">cSerialBase</a>* <a class="el" href="class_s_d_h_1_1c_s_d_h.html#3b788fb2f79a32502a29f0550c659539">SDH::cSDH::com</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="157b6e1209a43939b0baf5193ca62ddc"></a><!-- doxytag: member="SDH::cSDH::all_axes" ref="157b6e1209a43939b0baf5193ca62ddc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; <a class="el" href="class_s_d_h_1_1c_s_d_h.html#157b6e1209a43939b0baf5193ca62ddc">SDH::cSDH::all_axes</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A vector with indices of all axes (in natural order), including the virtual axis. 
<p>

</div>
</div><p>
<a class="anchor" name="4b213bcda9acbcee7030bc6e5d48d6cf"></a><!-- doxytag: member="SDH::cSDH::all_real_axes" ref="4b213bcda9acbcee7030bc6e5d48d6cf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; <a class="el" href="class_s_d_h_1_1c_s_d_h.html#4b213bcda9acbcee7030bc6e5d48d6cf">SDH::cSDH::all_real_axes</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A vector with indices of all real axes (in natural order), excluding the virtual axis. 
<p>

</div>
</div><p>
<a class="anchor" name="c799c1a91dd82c1d71f627b5496a0afa"></a><!-- doxytag: member="SDH::cSDH::all_fingers" ref="c799c1a91dd82c1d71f627b5496a0afa" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; <a class="el" href="class_s_d_h_1_1c_s_d_h.html#c799c1a91dd82c1d71f627b5496a0afa">SDH::cSDH::all_fingers</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A vector with indices of all fingers (in natural order). 
<p>

</div>
</div><p>
<a class="anchor" name="eb72f5095c4a1ad79964b9ef4a5c7bc4"></a><!-- doxytag: member="SDH::cSDH::all_temperature_sensors" ref="eb72f5095c4a1ad79964b9ef4a5c7bc4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; <a class="el" href="class_s_d_h_1_1c_s_d_h.html#eb72f5095c4a1ad79964b9ef4a5c7bc4">SDH::cSDH::all_temperature_sensors</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A vector with indices of all temperature sensors. 
<p>

</div>
</div><p>
<a class="anchor" name="bcb9da3cf0236c0e09cdd7af1a78225e"></a><!-- doxytag: member="SDH::cSDH::uc_angle" ref="bcb9da3cf0236c0e09cdd7af1a78225e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a>* <a class="el" href="class_s_d_h_1_1c_s_d_h.html#bcb9da3cf0236c0e09cdd7af1a78225e">SDH::cSDH::uc_angle</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
unit convert for (axis) angles: default = <a class="el" href="class_s_d_h_1_1c_s_d_h.html#128db2c199bab6ee328be4df7fd7f24f" title="Default converter for angles (internal unit == external unit): degrees.">SDH::cSDH::uc_angle_degrees</a> 
<p>

</div>
</div><p>
<a class="anchor" name="81c208eb64b0954dfef4182575ff6bc9"></a><!-- doxytag: member="SDH::cSDH::uc_angular_velocity" ref="81c208eb64b0954dfef4182575ff6bc9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a>* <a class="el" href="class_s_d_h_1_1c_s_d_h.html#81c208eb64b0954dfef4182575ff6bc9">SDH::cSDH::uc_angular_velocity</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
unit convert for (axis) angular velocities: default = <a class="el" href="class_s_d_h_1_1c_s_d_h.html#15ff510d1954ea58e34251fcc3a5cb34" title="Default converter for angular velocities (internal unit == external unit): degrees...">SDH::cSDH::uc_angular_velocity_degrees_per_second</a> 
<p>

</div>
</div><p>
<a class="anchor" name="8dc039c618c3383d5fefd85d41866f9e"></a><!-- doxytag: member="SDH::cSDH::uc_angular_acceleration" ref="8dc039c618c3383d5fefd85d41866f9e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a>* <a class="el" href="class_s_d_h_1_1c_s_d_h.html#8dc039c618c3383d5fefd85d41866f9e">SDH::cSDH::uc_angular_acceleration</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
unit convert for (axis) angular accelerations: default = <a class="el" href="class_s_d_h_1_1c_s_d_h.html#37e1c49a2cc7d6599306c71ed2b2b00f" title="Default converter for angular accelerations (internal unit == external unit): degrees...">SDH::cSDH::uc_angular_acceleration_degrees_per_second_squared</a> 
<p>

</div>
</div><p>
<a class="anchor" name="7479296b9f0c7300dc50452c7c929bc2"></a><!-- doxytag: member="SDH::cSDH::uc_time" ref="7479296b9f0c7300dc50452c7c929bc2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a>* <a class="el" href="class_s_d_h_1_1c_s_d_h.html#7479296b9f0c7300dc50452c7c929bc2">SDH::cSDH::uc_time</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
unit convert for times: default = uc_time_seconds 
<p>

</div>
</div><p>
<a class="anchor" name="844b1311f5be6eb5474157d9c24e7a5e"></a><!-- doxytag: member="SDH::cSDH::uc_temperature" ref="844b1311f5be6eb5474157d9c24e7a5e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a>* <a class="el" href="class_s_d_h_1_1c_s_d_h.html#844b1311f5be6eb5474157d9c24e7a5e">SDH::cSDH::uc_temperature</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
unit convert for temperatures: default = <a class="el" href="class_s_d_h_1_1c_s_d_h.html#3a16fe0f08ebb82d79edf1a7fa502c2f" title="Default converter for temparatures (internal unit == external unit): degrees celsius...">SDH::cSDH::uc_temperature_celsius</a> 
<p>

</div>
</div><p>
<a class="anchor" name="57bb98bd30adf2189a62f31388bc6bae"></a><!-- doxytag: member="SDH::cSDH::uc_motor_current" ref="57bb98bd30adf2189a62f31388bc6bae" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a>* <a class="el" href="class_s_d_h_1_1c_s_d_h.html#57bb98bd30adf2189a62f31388bc6bae">SDH::cSDH::uc_motor_current</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
unit converter for motor curent: default = <a class="el" href="class_s_d_h_1_1c_s_d_h.html#d81dfd6cad39b84734a1bc39e48e2fdd" title="Default converter for motor current (internal unit == external unit): Ampere.">SDH::cSDH::uc_motor_current_ampere</a> 
<p>

</div>
</div><p>
<a class="anchor" name="b16893e67eb1273cd95adcd6c0d5e631"></a><!-- doxytag: member="SDH::cSDH::uc_position" ref="b16893e67eb1273cd95adcd6c0d5e631" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_s_d_h_1_1c_unit_converter.html">cUnitConverter</a>* <a class="el" href="class_s_d_h_1_1c_s_d_h.html#b16893e67eb1273cd95adcd6c0d5e631">SDH::cSDH::uc_position</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
unit converter for position: default = <a class="el" href="class_s_d_h_1_1c_s_d_h.html#2a5abd24424bf5a92c3b74819d26cdc5" title="Default converter for position (internal unit == external unit): millimeter.">SDH::cSDH::uc_position_millimeter</a> 
<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>cpp.desire.final/sdh/<a class="el" href="cpp_8desire_8final_2sdh_2sdh_8h.html">sdh.h</a><li>sdh/<a class="el" href="sdh_2sdh_8h.html">sdh.h</a><li>cpp.desire.final/sdh/<a class="el" href="cpp_8desire_8final_2sdh_2sdh_8cpp.html">sdh.cpp</a><li>sdh/<a class="el" href="sdh_2sdh_8cpp.html">sdh.cpp</a></ul>
</div>
<!-- //! \cond ignore_me   doxygen cannot parse html files, so just ignore it -->
<hr size="1">
    <table width="100%" style="background-color:#0b2c55; color:white;">
      <tr> 
	<th style="text-align: left;"><address><small>
	    Generated on Tue Feb 2 12:52:10 2010 for project <b>SDHLibrary-CPP</b> by&nbsp;<a href="http://www.doxygen.org/index.html"><img src="http://www.stack.nl/~dimitri/doxygen/doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5
	  </small></address></th> 
	<th style="text-align: right;"><address><small>
	    <a href="mailto:dirk.osswald@de.schunk.com">dirk.osswald@de.schunk.com</a>
	    <a href="http://www.de.schunk.com"><img src="http://www.de.schunk.com/schunk_files/website_images/schunk_logo_top_navi_v2.gif" alt="SCHUNK GmbH &amp; Co. KG" align="middle" border="0"></a>
	  </small></address></th> 
      </tr>
    </table>
  </body>
</html>
<!-- //! \endcond -->  
