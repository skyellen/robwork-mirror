/********************************************************************************
 * Copyright 2013 The Robotics Group, The Maersk Mc-Kinney Moller Institute,
 * Faculty of Engineering, University of Southern Denmark
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ********************************************************************************/

#ifndef RWSIM_CONTACTS_CONTACT_HPP_
#define RWSIM_CONTACTS_CONTACT_HPP_

/**
 * @file Contact.hpp
 *
 * \copydoc rwsim::contacts::Contact
 */

#include "ContactModel.hpp"
#include <rw/kinematics/Frame.hpp>
#include <rw/math/Transform3D.hpp>

namespace rwsim {
namespace contacts {
//! @addtogroup rwsim_contacts

//! @{
/**
 * @brief A common interface for the most important data for a contact.
 *
 * A contact is given by the two points in contact, a normal, and a depth.
 * Furthermore the contact is generated by a contact strategy, which will use two internal contact models for the geometries in contact.
 * The relative transformation between these contact models is also used to define the contact.
 */
class Contact {
public:
	/**
	 * @brief Create new non-initialized contact.
	 */
	Contact();

	/**
	 * @brief Destruct contact.
	 */
	virtual ~Contact();

	/**
	 * @brief Get the contact model for the first object.
	 *
	 * @return contact model specific to the strategy that created the contact.
	 */
	ContactModel::Ptr getModelA() const;

	/**
	 * @brief Get the contact model for the second object.
	 *
	 * @return contact model specific to the strategy that created the contact.
	 */
	ContactModel::Ptr getModelB() const;

	/**
	 * @brief Get the frame for the first object.
	 *
	 * @return pointer to the frame.
	 */
	const rw::kinematics::Frame* getFrameA() const;

	/**
	 * @brief Get the frame for the second object.
	 *
	 * @return pointer to the frame.
	 */
	const rw::kinematics::Frame* getFrameB() const;

	/**
	 * @brief The relative transform between the two contact models.
	 *
	 * @return the relative transform.
	 */
	rw::math::Transform3D<> aTb() const;

	/**
	 * @brief The contact point on the first object.
	 *
	 * @return the contact point.
	 */
	rw::math::Vector3D<> getPointA() const;

	/**
	 * @brief The contact point on the second object.
	 *
	 * @return the contact point.
	 */
	rw::math::Vector3D<> getPointB() const;

	/**
	 * @brief The contact normal from the first object towards the second object.
	 *
	 * @return the contact normal.
	 */
	rw::math::Vector3D<> getNormal() const;

	/**
	 * @brief The penetration depth between the two objects.
	 *
	 * @return the penetration depth, positive if penetrating, negative if separated.
	 */
	double getDepth() const;

	/**
	 * @brief Set the contact model for the first object.
	 *
	 * @param modelA [in] contact model specific for the contact strategy that generates the contact.
	 */
	void setModelA(ContactModel::Ptr modelA);

	/**
	 * @brief Set the contact model for the second object.
	 *
	 * @param modelB [in] contact model specific for the contact strategy that generates the contact.
	 */
	void setModelB(ContactModel::Ptr modelB);

	/**
	 * @brief Set the frame for the first object.
	 *
	 * @param frame [in] a pointer to the frame.
	 */
	void setFrameA(const rw::kinematics::Frame* frame);

	/**
	 * @brief Set the frame for the second object.
	 *
	 * @param frame [in] a pointer to the frame.
	 */
	void setFrameB(const rw::kinematics::Frame* frame);

	/**
	 * @brief Set the relative transform from the first object to the second object.
	 *
	 * @param aTb [in] the relative transform.
	 */
	void setTransform(rw::math::Transform3D<> aTb);

	/**
	 * @brief Set the contact point on the first object.
	 *
	 * @param pointA [in] contact point.
	 */
	void setPointA(rw::math::Vector3D<> pointA);

	/**
	 * @brief Set the contact point on the second object.
	 *
	 * @param pointB [in] contact point.
	 */
	void setPointB(rw::math::Vector3D<> pointB);

	/**
	 * @brief Set the contact points on both objects at the same time.
	 *
	 * @param pointA [in] contact point on A.
	 * @param pointB [in] contact point on B.
	 */
	void setPoints(rw::math::Vector3D<> pointA, rw::math::Vector3D<> pointB);

	/**
	 * @brief Set the normal from the first object to the second.
	 *
	 * @param normal [in] contact normal.
	 */
	void setNormal(rw::math::Vector3D<> normal);

	/**
	 * @brief Calculate penetration depth automatically.
	 *
	 * Will calculate the penetration depth from the contact points and the normal.
	 */
	void setDepth();

	/**
	 * @brief Set the penetation depth.
	 *
	 * @param depth [in] penetration depth. Positive if penetrating, negative if separated.
	 */
	void setDepth(double depth);

	/**
	 * @brief Clear all result values
	 */
	virtual void clear();

	/**
	 * @brief Stream operator.
	 * @param out [in/out] the stream to write to.
	 * @param contact [in] the contact to print.
	 * @return the same ostream as out parameter.
	 */
	friend std::ostream& operator<<(std::ostream& out, const Contact& contact) {
		out << "Frames: " << contact.getFrameA()->getName() << " <-> " << contact.getFrameB()->getName();
		out << " Points: " << contact.getPointA() << " <-> " << contact.getPointB();
		out << " Normal: " << contact.getNormal() << " Depth: " << contact.getDepth();
		return out;
	}

private:
	ContactModel::Ptr _a, _b;
	const rw::kinematics::Frame * _frameA;
	const rw::kinematics::Frame * _frameB;
	rw::math::Transform3D<> _aTb;
	rw::math::Vector3D<> _pointA, _pointB;
	rw::math::Vector3D<> _normal;
	double _depth;
};
//! @}
} /* namespace contacts */
} /* namespace rwsim */
#endif /* RWSIM_CONTACTS_CONTACT_HPP_ */
