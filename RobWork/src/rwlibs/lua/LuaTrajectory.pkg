
$#include <rw/math.hpp>
$#include <rw/trajectory.hpp>

$#include "LuaKinematics.hpp"
$#include "LuaTrajectory.hpp"

namespace rw { namespace math {

	class Vector2D {
		TOLUA_TEMPLATE_BIND(T,double,float)	
		Vector2D();
		Vector2D(T x, T y);
		
		T& operator[](int i);
		
	};

}
}


namespace rwlua { namespace rw {
    /*
  		These are the classes and functions we export.
	*/
	// typedef rw::trajectory::PathQ PathQ;
	class QPath: public rw::trajectory::QPath
	{
	public:
		QPath();
		QPath(const rw::trajectory::QPath& path);

        void push_back( const rwlua::rw::Q& q );
        void pop_back();
        void resize(int size);
        void clear();
        int size();

        rwlua::rw::Q& operator[] (int index);
	};

	// typedef rw::trajectory::TimedQ TimedQ;
	class TimedQ {
	public:
	    TimedQ(double time, rwlua::rw::Q q);

	    double& getTime();
	    rwlua::rw::Q& getValue();

        //std::string __tostring() const;
        
	};
	
	// typedef rw::trajectory::TimedQ TimedQPath;
    class TimedQPath
    {
    public:
        TimedQPath();

        TimedQPath(const rw::trajectory::TimedQPath& path);

        //void add(double time, rwlua::rw::Q value);

		void push_back( const rwlua::rw::TimedQ& tq );
        void pop_back();
        void resize(int size);
        void clear();
        int size();

		rwlua::rw::TimedQ& operator[] (int index);
    };



	class StatePath: public rw::trajectory::StatePath
	{
	public:
		StatePath();

		StatePath(const rw::trajectory::StatePath& path);
		
		void push_back( const rwlua::rw::State& state );
        void pop_back();
        void resize(int size);
        void clear();
        int size();

		rwlua::rw::State& operator[] (int index);
	};

	// typedef rw::trajectory::TimedState TimedState;
	class TimedState {
	public:
	    TimedState(double time, rwlua::rw::State state);

	    double& getTime();
	    rwlua::rw::State& getValue();

        //std::string __tostring() const;
        
	};

	class TimedStatePath: public rw::trajectory::TimedStatePath
	{
	public:
		TimedStatePath();
		TimedStatePath(const rw::trajectory::TimedStatePath& path);
		
		//void add(double time, rwlua::rw::Q value);

		void push_back @ add( const rwlua::rw::TimedState& tq );
        void pop_back @ pop();
        void resize(int size);
        void clear();
        int size();

		rwlua::rw::TimedState& operator[] (int index);

	};
	
	
}}

/*
  We provide a rw module of wrapper functions and utility functions.

  These functions are compiled into the executable, so that the user never has
  to worry about the installation of the rw module.

  Also the user need not know about what namespace all of the above classes are
  actually located in.
*/
$[
 
	function rwlibs.lua.TimedQPath:add(time, arr)
	    -- todo: add possibility of arr to be an Q
		self:push_back( rwlibs.lua.TimedQ(time, rwlibs.lua.Q(#arr,arr) ) )
	end

	function rwlibs.lua.TimedStatePath:add(time, state)
		self:push_back( rwlibs.lua.TimedState(time, state ) )
	end

$]
