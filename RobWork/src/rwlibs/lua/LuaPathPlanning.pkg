
$#include <rw/math.hpp>
$#include <rw/trajectory.hpp>
$#include <rw/pathplanning.hpp>
$#include <rwlibs/pathplanners/rrt/RRTPlanner.hpp>
$#include <rwlibs/pathplanners/sbl/SBLPlanner.hpp>
$#include <rwlibs/pathplanners/prm/PRMPlanner.hpp>
$#include <rwlibs/pathoptimization/clearance/ClearanceOptimizer.hpp>
$#include <rwlibs/pathoptimization/clearance/MinimumClearanceCalculator.hpp>
$#include <rwlibs/pathoptimization/pathlength/PathLengthOptimizer.hpp>


$#include "LuaKinematics.hpp"
$#include "LuaTrajectory.hpp"
$#include "LuaPathPlanning.hpp"

namespace rwlibs { namespace lua { 
	
	class QSampler {
	public:
		typedef rw::common::Ptr<rwlibs::lua::QSampler> Ptr;		
	}
	
	
	
	class PlannerConstraint {
	public:
			typedef rw::common::Ptr<rwlibs::lua::PlannerConstraint> Ptr;
	}
	
	
	class StopCriteria {
	public:
		typedef rw::common::Ptr<rwlibs::lua::StopCriteria> Ptr;
		
		static StopCriteria::Ptr stopAfter(double time);
		static StopCriteria::Ptr stopNever();
		static StopCriteria::Ptr stopNow();
		static StopCriteria::Ptr stopByFlag(bool* stop);
		//static StopCriteria::Ptr stopByFun(boost::function<bool ()> fun);
		static StopCriteria::Ptr stopCnt(int cnt);
		static StopCriteria::Ptr stopEither(
            const StopCriteria::Ptr& a,
            const StopCriteria::Ptr& b);
		
	};
	
	
	
	class QToQPlanner {
	public:
		typedef rw::common::Ptr<rwlibs::lua::QToQPlanner> Ptr;
		
		bool query(const rwlibs::lua::Q& from,
				   const rwlibs::lua::Q& to,
				   rwlibs::lua::QPath& path,
				   const StopCriteria& stop);

		bool query(const rwlibs::lua::Q& from,
				   const rwlibs::lua::Q& to,
				   rwlibs::lua::QPath& path,
				   double time);

		bool query(const rwlibs::lua::Q& from,
				   const rwlibs::lua::Q& to,
				   rwlibs::lua::QPath& path); 

	};
	
	


	class RRTPlanner {
	public:
/*
		static rwlibs::lua::QToQPlanner::Ptr
			makeQToQPlanner(
            	const rw::pathplanning::PlannerConstraint& constraint,
            	rw::pathplanning::QSampler::Ptr sampler,
            	rw::math::QMetric::Ptr metric,
            	double extend,
            	PlannerType type);


        static rwlibs::lua::QToQPlanner::Ptr
        	makeQToQPlanner(
        		const rwlibs::lua::PlannerConstraint& constraint,
            	rwlibs::lua::Device::Ptr device,
            	PlannerType type);
*/
	};
	
}}

/*
  We provide a rw module of wrapper functions and utility functions.

  These functions are compiled into the executable, so that the user never has
  to worry about the installation of the rw module.

  Also the user need not know about what namespace all of the above classes are
  actually located in.
*/
/*
$[
 
	function rwlibs.lua.TimedQPath:add(time, arr)
		self:push_back( rwlibs.lua.TimedQ(time, rwlibs.lua.Q(#arr,arr) ) )
	end

	function rwlibs.lua.TimedStatePath:add(time, state)
		self:push_back( rwlibs.lua.TimedState(time, state ) )
	end

$]
*/
