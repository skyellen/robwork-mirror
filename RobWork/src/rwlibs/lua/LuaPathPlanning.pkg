
$#include <rw/math.hpp>
$#include <rw/trajectory.hpp>
$#include <rw/pathplanning.hpp>
$#include <rwlibs/pathplanners/rrt/RRTPlanner.hpp>
$#include <rwlibs/pathplanners/sbl/SBLPlanner.hpp>
$#include <rwlibs/pathplanners/prm/PRMPlanner.hpp>
$#include <rwlibs/pathoptimization/clearance/ClearanceOptimizer.hpp>
$#include <rwlibs/pathoptimization/clearance/MinimumClearanceCalculator.hpp>
$#include <rwlibs/pathoptimization/pathlength/PathLengthOptimizer.hpp>


$#include "LuaKinematics.hpp"
$#include "LuaTrajectory.hpp"
$#include "LuaPathPlanning.hpp"

namespace rwlua { namespace rw {
	
	class QSampler {
	public:
		typedef ::rw::common::Ptr<rwlua::rw::QSampler> Ptr;
	}
	
	
	
	class PlannerConstraint {
	public:
			typedef ::rw::common::Ptr<rwlua::rw::PlannerConstraint> Ptr;
	}
	
	
	class StopCriteria {
	public:
		typedef ::rw::common::Ptr<rwlua::rw::StopCriteria> Ptr;
		
		static StopCriteria::Ptr stopAfter(double time);
		static StopCriteria::Ptr stopNever();
		static StopCriteria::Ptr stopNow();
		static StopCriteria::Ptr stopByFlag(bool* stop);
		//static StopCriteria::Ptr stopByFun(boost::function<bool ()> fun);
		static StopCriteria::Ptr stopCnt(int cnt);
		static StopCriteria::Ptr stopEither(
            const StopCriteria::Ptr& a,
            const StopCriteria::Ptr& b);
		
	};
	
	
	
	class QToQPlanner {
	public:
		typedef rw::common::Ptr<rwlua::rw::QToQPlanner> Ptr;
		
		bool query(const rwlua::rw::Q& from,
				   const rwlua::rw::Q& to,
				   rwlua::rw::QPath& path,
				   const StopCriteria& stop);

		bool query(const rwlua::rw::Q& from,
				   const rwlua::rw::Q& to,
				   rwlua::rw::QPath& path,
				   double time);

		bool query(const rwlua::rw::Q& from,
				   const rwlua::rw::Q& to,
				   rwlua::rw::QPath& path);

	};
	
	


	class RRTPlanner {
	public:
/*
		static rwlua::rw::QToQPlanner::Ptr
			makeQToQPlanner(
            	const rw::pathplanning::PlannerConstraint& constraint,
            	rw::pathplanning::QSampler::Ptr sampler,
            	rw::math::QMetric::Ptr metric,
            	double extend,
            	PlannerType type);


        static rwlua::rw::QToQPlanner::Ptr
        	makeQToQPlanner(
        		const rwlua::rw::PlannerConstraint& constraint,
            	rwlua::rw::Device::Ptr device,
            	PlannerType type);
*/
	};
	
}}

/*
  We provide a rw module of wrapper functions and utility functions.

  These functions are compiled into the executable, so that the user never has
  to worry about the installation of the rw module.

  Also the user need not know about what namespace all of the above classes are
  actually located in.
*/
/*
$[
 
	function rwlibs.lua.TimedQPath:add(time, arr)
		self:push_back( rwlibs.lua.TimedQ(time, rwlibs.lua.Q(#arr,arr) ) )
	end

	function rwlibs.lua.TimedStatePath:add(time, state)
		self:push_back( rwlibs.lua.TimedState(time, state ) )
	end

$]
*/
