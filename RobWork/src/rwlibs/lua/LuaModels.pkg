
$#include <rw/math.hpp>

$#include "LuaModels.hpp"


$using namespace rwlibs::lua;
namespace rwlibs {
namespace lua { 


	class State;
	class Frame;

	class Q;
	class Vector3D;


    /* Class: rwlibs::lua::models::Device
  		These are the classes and functions we export.
  		
  	   See Also:
  	   	<rw::models::Device>
	*/		
	class Device
	{
	public:
		// Constructor: Device 
		Device(rw::models::DevicePtr device);

		// Function: setQ
        void setQ(const Q& q, State& state) const;
        // Function: getQ
        Q getQ(const State& state) const;

		// Function: getAccLimits
        Q getAccLimits() const;
        void setAccLimits(const Q& lim);

        Q getVelLimits() const;
        void setVelLimits(const Q& lim);

        Q getMinPosLimits() const;
        Q getMaxPosLimits() const;

        void setPosLimits(const Q& min,const Q& max);

        unsigned int getDOF() const;

        std::string getName() const;
        void setName(const std::string& name);

        Frame getBase();
        const Frame getBase() const;
        Frame getEnd();

        Transform3D bTf(const Frame* f, const State& state) const;
        Transform3D bTe(const State& state) const;
        Transform3D wTb(const State& state) const;

        Jacobian bJe(const State& state) const;
        Jacobian bJf(const Frame* frame, const State& state) const;

		rw::models::DevicePtr get() const;
		rw::models::DevicePtr _dev;
	};

    class WorkCell
    {
    public:
    	WorkCell();
    	WorkCell(rw::models::WorkCellPtr wc);

        std::string getName();

        Frame getWorldFrame() const;

        Frame findFrame(const std::string& name) const;

        Device findDevice(const std::string& name) const;

        State getDefaultState() const;

    	rw::models::WorkCellPtr get() const;
    	rw::models::WorkCellPtr get();

    	rw::models::WorkCellPtr _wc;
    	std::string __tostring() const;
    };
	
    std::string toStringJacobian(Jacobian& jac);
	
}}

/*
  We provide a rw module of wrapper functions and utility functions.

  These functions are compiled into the executable, so that the user never has
  to worry about the installation of the rw module.

  Also the user need not know about what namespace all of the above classes are
  actually located in.
*/
$[

  function rwlibs.lua.Jacobian:__tostring()
      return toStringJacobian( self );
  end

$]
