
$#include <rw/math.hpp>

$#include "LuaMath.hpp"

namespace rwlibs { 

namespace lua {

namespace math {
    /*
  These are the classes and functions we export.
*/

    //----------------------------------------------------------------------
    // Math
    //----------------------------------------------------------------------
	/*
		Class: rwlibs::lua::math::Q
		Wraps rw::math::Q
				
		See Also:
			<rw::math::Q>
	*/
    class Q : public rw::math::Q
    {
    public:
        // first we define functions that are native to Q
		/*
			Constructor: Q
			initialize object					
		*/
        Q(int n, double vals[n]);

        // rw::amth::Q functions
       	/*
			Function: size
			Returns the dimension of this Q
		*/
        size_t size() const;
       	
       	/*
			Function: size
			Returns the dimension of this Q
		*/
        double& operator[](unsigned int i) ;
        Q operator-() const;
		
		// Group: Arithmetic Operations
		
		// Function: operator-
        Q operator-(const Q& b);
        
        // Function: operator+
        Q operator+(const Q& b);
        
        // Function: operator*
        Q operator*(double s);
        
        // operator: /
        Q operator/(double s);

        double norm2();
        double norm1();
        double normInf();


        // necesary copy constructor from rw type to lua type
        explicit Q(const rw::math::Q& q);

        // specific lua functions


        bool operator==(const Q& q);
        std::string __tostring() const;
    };

    class Vector3D: rw::math::Vector3D<double>
    {
    public:
        explicit Vector3D(const rw::math::Vector3D<double>& v);
        Vector3D(double x,double y, double z);

        size_t size() const;

        // lua functions
        Vector3D operator*(double scale) const;
        Vector3D operator+(const Vector3D& other) const;
        Vector3D operator-(const Vector3D& other) const;
        bool operator==(const Vector3D& q);

        double norm2();
        double norm1();
        double normInf();

        double& operator[](unsigned int i) ;

        std::string __tostring() const;
    };

    class Rotation3D: rw::math::Rotation3D<double>
    {
    public:
        // Lua methods:
        explicit Rotation3D(const rw::math::Rotation3D<double>& R);

        Rotation3D(double vals[9]);
        Rotation3D operator*(const Rotation3D& other) const;
        Vector3D operator*(const Vector3D& vec) const;
        Rotation3D inverse() const;

        static const Rotation3D& identity();
        static Rotation3D skew(const Vector3D& v);
        bool equal(const Rotation3D& rot, double precision);

        EAA operator*(const EAA& other) const;

        bool operator==(const Rotation3D &rhs) const;
        //double& operator[](unsigned int i) ;

        std::string __tostring() const;
    };

    class EAA: rw::math::EAA<double>
    {
    public:
        // Lua methods:
        EAA(const rw::math::EAA<double>& eaa);
        EAA(const rw::math::Rotation3D<double>& rot);

        EAA(double vals[3]);
        EAA(const Vector3D& v1, const Vector3D& v2);

        double angle() const;
        Vector3D axis() const;

        const double& operator[](unsigned int i) const;

        //EAA operator*(const Rotation3D& other) const;

        Rotation3D toRotation3D() const;

        bool operator==(const EAA &rhs) const;
        std::string __tostring() const;
    };

    class RPY: rw::math::RPY<double>
    {
    public:
        // Lua methods:
        RPY(const rw::math::RPY<double>& eaa);
        RPY(const rw::math::Rotation3D<double>& rot);

        RPY(double vals[3]);
        //RPY(const Vector3D& v1, const Vector3D& v2);

        Rotation3D toRotation3D() const;

        bool operator==(const RPY &rhs) const;

        std::string __tostring() const;
    };

    class Quaternion: rw::math::Quaternion<double>
    {
    public:
        // Lua methods:
        Quaternion(const rw::math::Quaternion<double>& eaa);
        Quaternion(const rw::math::Rotation3D<double>& rot);
        Quaternion(double vals[4]);

        Quaternion operator*(const Quaternion& other) const;
        Quaternion operator*(double s);

        void normalize();

        Rotation3D toRotation3D() const;
        Quaternion slerp(const Quaternion& v, const double t) const;

        double getQx @ x() const;
        double getQy @ y() const;
        double getQz @ z() const;
        double getQw @ w() const;

        bool operator==(const Quaternion &rhs) const;

        std::string __tostring() const;
    };

    //Quaternion operator*(double s, const Quaternion& v);

    class Transform3D: rw::math::Transform3D<double>
    {
    public:
        Transform3D(const rw::math::Transform3D<double>& t3d);

        // Lua methods:
        Transform3D(
            const Vector3D& position,
            const Rotation3D& rotation);

        Transform3D operator*(const Transform3D& other) const;
        Vector3D operator*(const Vector3D& other) const;
        Transform3D inverse() const;

        static Transform3D DH(double alpha, double a, double d, double theta);
        static Transform3D craigDH(double alpha, double a, double d, double theta);

        Vector3D P() const;
        Rotation3D R() const;

        std::string __tostring() const;
    };

    class Pose6D: rw::math::Pose6D<double>
    {
    public:
		Pose6D(const rw::math::Pose6D<double>& p6d);
        Pose6D(const Vector3D& position,const EAA& rotation);
        Pose6D(const rw::math::Transform3D<double>& t3d);

        Transform3D toTransform3D();
        std::string __tostring() const;
    };

    Rotation3D inverse(const Rotation3D& val);
    Transform3D inverse(const Transform3D& val);

}}}
//extern const double rw::math::Rad2Deg @ R2D;
/*
    class rw::math::Rotation3D<double>
    {
    public:
        // Lua methods:
        rw::math::Rotation3D<double>(double vals[9]);
        rw::math::Rotation3D<double> operator*(const rw::math::Rotation3D<double>& other) const;
        rw::math::Vector3D<double> operator*(const rw::math::Vector3D<double>& vec) const;
        rw::math::Rotation3D<double> inverse() const;

        //std::string __tostring() const;
    };
*/

/*
  We provide a rw module of wrapper functions and utility functions.

  These functions are compiled into the executable, so that the user never has
  to worry about the installation of the rw module.

  Also the user need not know about what namespace all of the above classes are
  actually located in.
*/
//$[


//$]
