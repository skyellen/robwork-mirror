
$#include <rw/math.hpp>
$#include "LuaMath.hpp"

namespace rwlua {
namespace rw {


    /*
     * These are the classes and functions we export.
     */

    //----------------------------------------------------------------------
    // Math
    //----------------------------------------------------------------------
	/*
		Class: rwlibs::lua::Q
		Wraps rw::math::Q
				
		See Also:
			<rw::math::Q>
	*/
   	class Q
    {
    public:
        // first we define functions that are native to Q
		/*
			Constructor: Q
			initialize object					
		*/
		Q();
        Q(int n, double vals[n]);

        // rw::math::Q functions
       	/*
			Function: size
			Returns the dimension of this Q
		*/
        int size() const;
       	
       	/*
			Function: size
			Returns the dimension of this Q
		*/
        double& operator[](unsigned int i) ;
        const Q operator-() const;
		
		// Group: Arithmetic Operations
		
		// Function: operator-
        Q operator-(const Q& b) const;
        
        // Function: operator+
        Q operator+(const Q& b) const;
        
        // Function: operator*
        Q operator*(double s) const;
        
        // operator: /
        Q operator/(double s) const;

        double norm2();
        double norm1();
        double normInf();
    };
  

	
    class Vector3D
    {
    public:
        Vector3D();
        explicit Vector3D(const rw::math::Vector3D<double>& v);
        Vector3D(double x,double y, double z);

        size_t size() const;

        // lua functions
        Vector3D operator*(double scale) const;
        Vector3D operator+(const Vector3D& other) const;
        Vector3D operator-(const Vector3D& other) const;
        bool operator==(const Vector3D& q);

        double norm2();
        double norm1();
        double normInf();

        double& operator[](unsigned int i) ;

        //std::string __tostring() const;
    };

    class Rotation3D
    {
    public:
        // Lua methods:
        Rotation3D();
        Rotation3D(double v0,double v1,double v2,
        			double v3,double v4,double v5,
        			double v6,double v7,double v8);
        			
        explicit Rotation3D(const rw::math::Rotation3D<double>& R);

        Rotation3D operator*(const Rotation3D& other) const;
        Vector3D operator*(const Vector3D& vec) const;
        //Rotation3D inverse() const;

        static const Rotation3D& identity();
        static Rotation3D skew(const Vector3D& v);
        bool equal(const Rotation3D& rot, double precision);

        //EAA operator*(const EAA& other) const;

        bool operator==(const Rotation3D &rhs) const;
        //double& operator[](unsigned int i) ;

        // std::string __tostring() const;
    };
    
    Rotation3D inverse(const Rotation3D& val);

    class EAA
    {
    public:
        // Lua methods:
        EAA();
        EAA(const rw::math::EAA<double>& eaa);
        EAA(const rw::math::Rotation3D<double>& rot);
        EAA(const Vector3D& axis, double angle);
        EAA(double thetakx, double thetaky, double thetakz);
        EAA(const Vector3D& v1, const Vector3D& v2);

        double angle() const;
        Vector3D axis() const;

        const double& operator[](unsigned int i) const;
		double& operator[](unsigned int i);
        
        //EAA operator*(const Rotation3D& other) const;

        Rotation3D toRotation3D() const;

        //bool operator==(const EAA &rhs) const;
        // std::string __tostring() const;
    };

    class RPY
    {
    public:
        // Lua methods:
        RPY();
        RPY(const rw::math::RPY<double>& eaa);
        RPY(const rw::math::Rotation3D<double>& rot);
        RPY(double roll, double pitch, double yaw);

        //RPY(const Vector3D& v1, const Vector3D& v2);

        Rotation3D toRotation3D() const;

        //bool operator==(const RPY &rhs) const;
        // std::string __tostring() const;
    };

    class Quaternion
    {
    public:
        // Lua methods:
        Quaternion();
        Quaternion(const rw::math::Quaternion<double>& eaa);
        Quaternion(const rw::math::Rotation3D<double>& rot);

        //Quaternion operator*(const Quaternion& other) const;
        Quaternion operator*(double s);

        void normalize();

        Rotation3D toRotation3D() const;
        Quaternion slerp(const Quaternion& v, const double t) const;

        double getQx @ x() const;
        double getQy @ y() const;
        double getQz @ z() const;
        double getQw @ w() const;

        //bool operator==(const Quaternion &rhs) const;
        // std::string __tostring() const;
    };

    //Quaternion operator*(double s, const Quaternion& v);

    class Transform3D
    {
    public:
    	Transform3D();
        Transform3D(const rw::math::Transform3D<double>& t3d);

        // Lua methods:
        Transform3D(
            const Vector3D& position,
            const Rotation3D& rotation);

        Transform3D operator*(const Transform3D& other) const;
        Vector3D operator*(const Vector3D& other) const;
        //Transform3D inverse() const;

        static Transform3D DH(double alpha, double a, double d, double theta);
        static Transform3D craigDH(double alpha, double a, double d, double theta);
		
        Vector3D& P();
        Rotation3D& R();

        // std::string __tostring() const;
    };

    class Pose6D
    {
    public:
    	//Pose6D();
		Pose6D(const rw::math::Pose6D<double>& p6d);
        Pose6D(const Vector3D& position,const EAA& rotation);
        Pose6D(const rw::math::Transform3D<double>& t3d);

        Transform3D toTransform3D();
        // std::string __tostring() const;
    };

    class Jacobian
    {
    public:
        Jacobian(int m, int n);

        int size1() const ;
        int size2() const ;

        double& elem(int i, int j);
    };

    class VelocityScrew6D
    {
    public:
    	VelocityScrew6D();
		VelocityScrew6D(const rw::math::VelocityScrew6D<double>& p6d);
        VelocityScrew6D(const Vector3D& position,const EAA& rotation);
        VelocityScrew6D(const rw::math::Transform3D<double>& t3d);

        // lua functions
        VelocityScrew6D operator*(double scale) const;
        VelocityScrew6D operator+(const VelocityScrew6D& other) const;
        VelocityScrew6D operator-(const VelocityScrew6D& other) const;
        //bool operator==(const VelocityScrew6D& q);

        double norm2();
        double norm1();
        double normInf();


        //Transform3D toTransform3D();
        // std::string __tostring() const;
    };

    
    Transform3D inverse(const Transform3D& val);

    
	//extern double Deg2Rad;
	//extern double Meter2Inch;
	//extern double Inch2Meter;
	//extern double Pi;


    std::string toStringJacobian(Jacobian& jac);
    std::string toStringQ(Q& q);
    std::string toStringRPY(RPY& val);
    std::string toStringEAA(EAA& val);
    std::string toStringTransform3D(Transform3D& val);
    std::string toStringVector3D(Vector3D& q);
    std::string toStringRotation3D(Rotation3D& val);
    std::string toStringQuaternion(Quaternion& val);
    std::string toStringVelocityScrew6D(VelocityScrew6D& val);
	    	
}}




/*
  We provide a rw module of wrapper functions and utility functions.

  These functions are compiled into the executable, so that the user never has
  to worry about the installation of the rw module.

  Also the user need not know about what namespace all of the above classes are
  actually located in.
*/
$[

	--function rwlua.rw.Q(arr)
	--	local tmp = rwlua.rw.Q(#arr,array)
	--	tolua.takeownership(tmp) 
	--	return tmp
	--end

	--function rwlua.rw.Q:new(arr)
	--	return rwlua.rw.Q:new(#arr,arr)
	--end
	
	function rwlua.rw.Jacobian:__tostring()
	    return rwlua.rw.toStringJacobian( self )
	end
	
    function rwlua.rw.Q:__tostring()
        return rwlua.rw.toStringQ( self )
    end

    function rwlua.rw.RPY:__tostring()
        return rwlua.rw.toStringRPY( self )
    end

    function rwlua.rw.EAA:__tostring()
        return rwlua.rw.toStringEAA( self )
    end

    function rwlua.rw.Transform3D:__tostring()
        return rwlua.rw.toStringTransform3D( self )
    end
    
    
    --function rwlua.rw.Rotation3D:__tostring()
    --    return rwlua.rw.toStringRotation3D( self )
    --end
    
    --function rwlua.rw.Vector3D:__tostring()
    --    return rwlua.rw.toStringVector3D( self )
    --end

    function rwlua.rw.Quaternion:__tostring()
        return rwlua.rw.toStringQuaternion( self )
    end

    function rwlua.rw.VelocityScrew6D:__tostring()
        return rwlua.rw.toStringVelocityScrew6D( self )
    end

$]
